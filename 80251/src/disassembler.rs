pub type AddrType = u32;
#[derive(Clone, Copy, Debug)]
pub enum Register {
    R0,
    R1,
    R2,
    R3,
    R4,
    R5,
    R6,
    R7,
    jumpTableGuard1,
    jumpTableGuard2,
    R8,
    R9,
    B,
    ACC,
    R12,
    R13,
    R14,
    R15,
    R16,
    R17,
    R18,
    R19,
    R20,
    R21,
    R22,
    R23,
    R24,
    R25,
    R26,
    R27,
    R28,
    R29,
    R30,
    R31,
    WR0,
    WR2,
    WR4,
    WR6,
    WR8,
    AB,
    WR12,
    WR14,
    WR16,
    WR18,
    WR20,
    WR22,
    WR24,
    WR26,
    WR28,
    WR30,
    DR0,
    DR4,
    DR8,
    DR12,
    DR16,
    DR20,
    DR24,
    DR28,
    R56,
    DPXL,
    DPH,
    DPL,
    R60,
    R61,
    SPH,
    DPTR,
    DPX,
    SPX,
    SP,
    PC,
    PSW,
    contextReg,
}
impl Register {
    fn as_str(&self) -> &'static str {
        match self {
            Self::R0 => "R0",
            Self::R1 => "R1",
            Self::R2 => "R2",
            Self::R3 => "R3",
            Self::R4 => "R4",
            Self::R5 => "R5",
            Self::R6 => "R6",
            Self::R7 => "R7",
            Self::jumpTableGuard1 => "jumpTableGuard1",
            Self::jumpTableGuard2 => "jumpTableGuard2",
            Self::R8 => "R8",
            Self::R9 => "R9",
            Self::B => "B",
            Self::ACC => "ACC",
            Self::R12 => "R12",
            Self::R13 => "R13",
            Self::R14 => "R14",
            Self::R15 => "R15",
            Self::R16 => "R16",
            Self::R17 => "R17",
            Self::R18 => "R18",
            Self::R19 => "R19",
            Self::R20 => "R20",
            Self::R21 => "R21",
            Self::R22 => "R22",
            Self::R23 => "R23",
            Self::R24 => "R24",
            Self::R25 => "R25",
            Self::R26 => "R26",
            Self::R27 => "R27",
            Self::R28 => "R28",
            Self::R29 => "R29",
            Self::R30 => "R30",
            Self::R31 => "R31",
            Self::WR0 => "WR0",
            Self::WR2 => "WR2",
            Self::WR4 => "WR4",
            Self::WR6 => "WR6",
            Self::WR8 => "WR8",
            Self::AB => "AB",
            Self::WR12 => "WR12",
            Self::WR14 => "WR14",
            Self::WR16 => "WR16",
            Self::WR18 => "WR18",
            Self::WR20 => "WR20",
            Self::WR22 => "WR22",
            Self::WR24 => "WR24",
            Self::WR26 => "WR26",
            Self::WR28 => "WR28",
            Self::WR30 => "WR30",
            Self::DR0 => "DR0",
            Self::DR4 => "DR4",
            Self::DR8 => "DR8",
            Self::DR12 => "DR12",
            Self::DR16 => "DR16",
            Self::DR20 => "DR20",
            Self::DR24 => "DR24",
            Self::DR28 => "DR28",
            Self::R56 => "R56",
            Self::DPXL => "DPXL",
            Self::DPH => "DPH",
            Self::DPL => "DPL",
            Self::R60 => "R60",
            Self::R61 => "R61",
            Self::SPH => "SPH",
            Self::DPTR => "DPTR",
            Self::DPX => "DPX",
            Self::SPX => "SPX",
            Self::SP => "SP",
            Self::PC => "PC",
            Self::PSW => "PSW",
            Self::contextReg => "contextReg",
        }
    }
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::R0,
        1 => Register::R1,
        2 => Register::R2,
        3 => Register::R3,
        4 => Register::R4,
        5 => Register::R5,
        6 => Register::R6,
        7 => Register::R7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::R0,
        1 => Register::R1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::R0,
        1 => Register::R1,
        2 => Register::R2,
        3 => Register::R3,
        4 => Register::R4,
        5 => Register::R5,
        6 => Register::R6,
        7 => Register::R7,
        8 => Register::R8,
        9 => Register::R9,
        10 => Register::B,
        11 => Register::ACC,
        12 => Register::R12,
        13 => Register::R13,
        14 => Register::R14,
        15 => Register::R15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::R0,
        1 => Register::R0,
        2 => Register::R2,
        3 => Register::R2,
        4 => Register::R4,
        5 => Register::R3,
        6 => Register::R6,
        7 => Register::R6,
        8 => Register::R8,
        9 => Register::R8,
        10 => Register::B,
        11 => Register::B,
        12 => Register::R12,
        13 => Register::R12,
        14 => Register::R14,
        15 => Register::R14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::R1,
        1 => Register::R1,
        2 => Register::R3,
        3 => Register::R3,
        4 => Register::R5,
        5 => Register::R5,
        6 => Register::R7,
        7 => Register::R7,
        8 => Register::R9,
        9 => Register::R9,
        10 => Register::ACC,
        11 => Register::ACC,
        12 => Register::R13,
        13 => Register::R13,
        14 => Register::R15,
        15 => Register::R15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::WR0,
        1 => Register::WR2,
        2 => Register::WR4,
        3 => Register::WR6,
        4 => Register::WR8,
        5 => Register::AB,
        6 => Register::WR12,
        7 => Register::WR14,
        8 => Register::WR16,
        9 => Register::WR18,
        10 => Register::WR20,
        11 => Register::WR22,
        12 => Register::WR24,
        13 => Register::WR26,
        14 => Register::WR28,
        15 => Register::WR30,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::WR0,
        1 => Register::WR0,
        2 => Register::WR4,
        3 => Register::WR4,
        4 => Register::WR8,
        5 => Register::WR8,
        6 => Register::WR12,
        7 => Register::WR12,
        8 => Register::WR16,
        9 => Register::WR16,
        10 => Register::WR20,
        11 => Register::WR20,
        12 => Register::WR24,
        13 => Register::WR24,
        14 => Register::WR28,
        15 => Register::WR28,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_7_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::WR2,
        1 => Register::WR2,
        2 => Register::WR6,
        3 => Register::WR6,
        4 => Register::AB,
        5 => Register::AB,
        6 => Register::WR14,
        7 => Register::WR14,
        8 => Register::WR18,
        9 => Register::WR18,
        10 => Register::WR22,
        11 => Register::WR22,
        12 => Register::WR26,
        13 => Register::WR26,
        14 => Register::WR30,
        15 => Register::WR30,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_7_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_8_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::DR0,
        1 => Register::DR4,
        2 => Register::DR8,
        3 => Register::DR12,
        4 => Register::DR16,
        5 => Register::DR20,
        6 => Register::DR24,
        7 => Register::DR28,
        8 => Register::DPX,
        9 => Register::SPX,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_8_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_9_value<T>(num: T) -> u8
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => 1,
        1 => 2,
        2 => 4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(hex: bool, num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_9_value(num);
    <DisplayElement>::Number(hex, false, value as u64)
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, bool, u64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(true, false, value) => {
                write!(f, "0x{:x}", value)
            }
            Self::Number(true, true, value) => {
                write!(f, "-0x{:x}", value)
            }
            Self::Number(false, false, value) => value.fmt(f),
            Self::Number(false, true, value) => {
                write!(f, "-{:x}", value)
            }
        }
    }
}
#[doc = "Create token_fields: rifill s13 s13_"]
fn token_7(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 1) & 7) as u8)
}
#[doc = "Create token_fields: addrfill"]
fn token_9(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 4) & 1) as u8)
}
#[doc = "Create token_fields: b_0005"]
fn token_11(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 63) as u8)
}
#[doc = "Create token_fields: oplo sfrlo sfr2lo rm03 wrj03 drk03 s03 rm03_ wrj03_ drk03_ s03_"]
fn token_2(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 15) as u8)
}
#[doc = "Create token_fields: bank bank2 bitbank d7 d7_"]
fn token_17(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 7) & 1) as u8)
}
#[doc = "Create token_fields: lowbyte"]
fn token_20(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 3) & 15) as u8)
}
#[doc = "Create token_fields: adata"]
fn token_25(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 255) as u8)
}
#[doc = "Create token_fields: s23"]
fn token_26(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 2) & 3) as u8)
}
#[doc = "Create token_fields: sfr6 sfr26 sfrbit6"]
fn token_19(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 6) & 1) as u8)
}
#[doc = "Create token_fields: addr16 data16 rel16"]
fn token_21(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 65535) as u16)
}
#[doc = "Create token_fields: addr24 data24"]
fn token_27(tokens: &[u8]) -> u32 {
    let mut bytes = [0u8; 4];
    bytes[3..0].copy_from_slice(&tokens[0..3]);
    let value = u32::from_be_bytes(bytes);
    (((value >> 0) & 16777215) as u32)
}
#[doc = "Create token_fields: b_0607"]
fn token_16(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 6) & 3) as u8)
}
#[doc = "Create token_fields: opaddr bitaddr57 d57 d57_"]
fn token_8(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 5) & 7) as u8)
}
#[doc = "Create token_fields: aaddrfill"]
fn token_24(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 12) & 1) as u8)
}
#[doc = "Create token_fields: b_0107 direct17"]
fn token_13(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 1) & 127) as u8)
}
#[doc = "Create token_fields: b_0207 bitaddr27"]
fn token_14(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 2) & 63) as u8)
}
#[doc = "Create token_fields: ri b_0000 bitaddr0 s0"]
fn token_6(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 1) as u8)
}
#[doc = "Create token_fields: rnfill sfrbit3 s3 s3_"]
fn token_5(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 3) & 1) as u8)
}
#[doc = "Create token_fields: b_0101 s1"]
fn token_12(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 1) & 1) as u8)
}
#[doc = "Create token_fields: opfull direct direct2 bitaddr8 rel8 data"]
fn token_1(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 255) as u8)
}
#[doc = "Create token_fields: aoplo"]
fn token_22(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 15) as u8)
}
#[doc = "Create token_fields: aopaddr"]
fn token_23(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 13) & 7) as u8)
}
#[doc = "Create token_fields: ophi rm47 rm47_d1 rm47_d2 wrj47 wrj47_d1 wrj47_d2 drk47 d47 rm47_ wrj47_ drk47_"]
fn token_3(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 4) & 15) as u8)
}
#[doc = "Create token_fields: rn b_0002 sfrbit bit02"]
fn token_4(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 7) as u8)
}
#[doc = "Create token_fields: sfr mainreg sfr2 mainreg2"]
fn token_18(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 127) as u8)
}
#[doc = "Create token_fields: b_0307 sfrbyte"]
fn token_15(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 3) & 31) as u8)
}
#[doc = "Create token_fields: b_0001 short01"]
fn token_10(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 3) as u8)
}
#[derive(Clone, Copy, Default)]
pub struct ContextMemory(pub u8);
impl ContextMemory {
    pub fn read_phase(&self) -> u8 {
        (((self.0.reverse_bits() >> 7) & 1) as u8)
    }
    pub fn write_phase(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 7)) | ((value as u8 & 1) << 7)).reverse_bits();
    }
    pub fn read_srcMode(&self) -> u8 {
        (((self.0.reverse_bits() >> 6) & 1) as u8)
    }
    pub fn write_srcMode(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 6)) | ((value as u8 & 1) << 6)).reverse_bits();
    }
    pub fn read_A5Prefix(&self) -> u8 {
        (((self.0.reverse_bits() >> 5) & 1) as u8)
    }
    pub fn write_A5Prefix(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 5)) | ((value as u8 & 1) << 5)).reverse_bits();
    }
}
#[derive(Clone)]
pub struct GlobalSet {
    default: ContextMemory,
    branches: std::collections::HashMap<AddrType, ContextMemory>,
}
impl GlobalSet {
    pub fn new(default: ContextMemory) -> Self {
        Self {
            default,
            branches: std::collections::HashMap::new(),
        }
    }
    pub fn set(&mut self, address: Option<AddrType>, set: impl FnOnce(&mut ContextMemory)) {
        let Some (address) = address else { return } ;
        let entry = self
            .branches
            .entry(address)
            .or_insert_with(|| self.default.clone());
        set(entry);
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:645:1, end:645:2))"]
#[derive(Clone, Debug)]
struct instructionVar0 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_phase(u8::try_from(1i128 & 1).unwrap());
        context_instance.write_A5Prefix(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:646:1, end:646:2))"]
#[derive(Clone, Debug)]
struct instructionVar1 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_phase(u8::try_from(1i128 & 1).unwrap());
        context_instance.write_A5Prefix(u8::try_from(0i128 & 1).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:219:1, end:219:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar2 {
    rm47_: u8,
    AtDRkb: TableAtDRkb,
}
impl ADD_instructionVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) =
            TableAtDRkb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:249:1, end:249:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar3 {
    rm47_: u8,
    AtDRkb: TableAtDRkb,
}
impl ANL_instructionVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) =
            TableAtDRkb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:298:1, end:298:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar4 {
    rm47_: u8,
    AtDRkb: TableAtDRkb,
}
impl CMP_instructionVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) =
            TableAtDRkb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:425:1, end:425:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar5 {
    rm47_: u8,
    AtDRkb: TableAtDRkb,
}
impl MOV_instructionVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) =
            TableAtDRkb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:431:1, end:431:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar6 {
    wrj47_: u8,
    AtDRkw: TableAtDRkw,
}
impl MOV_instructionVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkw = if let Some((len, table)) =
            TableAtDRkw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let wrj47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkw, wrj47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:444:1, end:444:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar7 {
    drk47: u8,
    Direct8w: TableDirect8w,
}
impl MOV_instructionVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct8w
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_8_display(self.drk47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct8w = if let Some((len, table)) =
            TableDirect8w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:445:1, end:445:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar8 {
    drk47: u8,
    Direct: TableDirect,
}
impl MOV_instructionVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_8_display(self.drk47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:460:1, end:460:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar9 {
    rm47_: u8,
    AtDRkb: TableAtDRkb,
}
impl MOV_instructionVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtDRkb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm47_),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) =
            TableAtDRkb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:466:1, end:466:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar10 {
    wrj47_: u8,
    AtDRkw: TableAtDRkw,
}
impl MOV_instructionVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtDRkw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj47_),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkw = if let Some((len, table)) =
            TableAtDRkw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let wrj47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkw, wrj47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:542:1, end:542:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar11 {
    rm47_: u8,
    AtDRkb: TableAtDRkb,
}
impl ORL_instructionVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) =
            TableAtDRkb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:561:1, end:561:2))"]
#[derive(Clone, Debug)]
struct PUSH_instructionVar12 {
    Data: TableData,
}
impl PUSH_instructionVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PUSH"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:564:1, end:564:2))"]
#[derive(Clone, Debug)]
struct PUSH_instructionVar13 {
    Data16: TableData16,
}
impl PUSH_instructionVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PUSH"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Data16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16 = if let Some((len, table)) =
            TableData16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:631:1, end:631:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar14 {
    rm47_: u8,
    AtDRkb: TableAtDRkb,
}
impl SUB_instructionVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) =
            TableAtDRkb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:662:1, end:662:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar15 {
    rm47_: u8,
    AtDRkb: TableAtDRkb,
}
impl XRL_instructionVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRkb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkb = if let Some((len, table)) =
            TableAtDRkb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:201:1, end:201:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar16 {
    drk47: u8,
    Data16x0: TableData16x0,
}
impl ADD_instructionVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16x0 = if let Some((len, table)) =
            TableData16x0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x0, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:252:1, end:252:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar17 {
    xBitAddr: TablexBitAddr,
    xBitByteAddr: TablexBitByteAddr,
}
impl ANL_instructionVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("CY,"),
        ];
        display.extend_from_slice(&extend);
        self.xBitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_3(tokens) != 8 {
                return None;
            }
            if token_5(tokens) != 0 {
                return None;
            }
            let bit02 = token_4(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) =
            TablexBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitAddr,
                xBitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:255:1, end:255:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar18 {
    xBitAddr2: TablexBitAddr2,
    xBitByteAddr: TablexBitByteAddr,
}
impl ANL_instructionVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("CY,"),
        ];
        display.extend_from_slice(&extend);
        self.xBitAddr2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_3(tokens) != 15 {
                return None;
            }
            if token_5(tokens) != 0 {
                return None;
            }
            let bit02 = token_4(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr2 = if let Some((len, table)) =
            TablexBitAddr2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitAddr2,
                xBitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:258:1, end:258:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar19 {
    xBitAddr: TablexBitAddr,
    xBitByteAddr: TablexBitByteAddr,
}
impl CLR_instructionVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_3(tokens) != 12 {
                return None;
            }
            if token_5(tokens) != 0 {
                return None;
            }
            let bit02 = token_4(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) =
            TablexBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitAddr,
                xBitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:277:1, end:277:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar20 {
    drk47: u8,
    Data16x0: TableData16x0,
}
impl CMP_instructionVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16x0 = if let Some((len, table)) =
            TableData16x0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x0, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:280:1, end:280:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar21 {
    drk47: u8,
    Data16x1: TableData16x1,
}
impl CMP_instructionVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16x1 = if let Some((len, table)) =
            TableData16x1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x1, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:301:1, end:301:2))"]
#[derive(Clone, Debug)]
struct CPL_instructionVar22 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
}
impl CPL_instructionVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_3(tokens) != 11 {
                return None;
            }
            if token_5(tokens) != 0 {
                return None;
            }
            let bit02 = token_4(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) =
            TablexBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:323:1, end:323:2))"]
#[derive(Clone, Debug)]
struct ECALL_instructionVar23 {
    AtDRkt: TableAtDRkt,
}
impl ECALL_instructionVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ECALL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtDRkt
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkt = if let Some((len, table)) =
            TableAtDRkt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:329:1, end:329:2))"]
#[derive(Clone, Debug)]
struct EJMP_instructionVar24 {
    AtDRkt: TableAtDRkt,
}
impl EJMP_instructionVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EJMP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtDRkt
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRkt = if let Some((len, table)) =
            TableAtDRkt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtDRkt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:454:1, end:454:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar25 {
    drk47: u8,
    Direct16d: TableDirect16d,
}
impl MOV_instructionVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct16d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_8_display(self.drk47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16d = if let Some((len, table)) =
            TableDirect16d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16d, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:500:1, end:500:2))"]
#[derive(Clone, Debug)]
struct MOVH_instructionVar26 {
    drk47: u8,
    Data16x0: TableData16x0,
}
impl MOVH_instructionVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVH"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16x0 = if let Some((len, table)) =
            TableData16x0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x0, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:557:1, end:557:2))"]
#[derive(Clone, Debug)]
struct POP_instructionVar27 {
    drk47: u8,
}
impl POP_instructionVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("POP"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:573:1, end:573:2))"]
#[derive(Clone, Debug)]
struct PUSH_instructionVar28 {
    drk47: u8,
}
impl PUSH_instructionVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PUSH"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:613:1, end:613:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar29 {
    drk47: u8,
    Data16x0: TableData16x0,
}
impl SUB_instructionVar29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16x0 = if let Some((len, table)) =
            TableData16x0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x0, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:311:1, end:311:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar30 {
    drk47: u8,
    Short: TableShort,
}
impl DEC_instructionVar30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEC"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Short
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let Short = if let Some((len, table)) =
            TableShort::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_6(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_12(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Short, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:341:1, end:341:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar31 {
    drk47: u8,
    Short: TableShort,
}
impl INC_instructionVar31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INC"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Short
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let Short = if let Some((len, table)) =
            TableShort::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_6(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_12(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Short, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:344:1, end:344:2))"]
#[derive(Clone, Debug)]
struct JB_instructionVar32 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
    Rel8: TableRel8,
}
impl JB_instructionVar32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c52 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_3(tokens) != 2 {
                return None;
            }
            if token_5(tokens) != 0 {
                return None;
            }
            let bit02 = token_4(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c52(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) =
            TablexBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:347:1, end:347:2))"]
#[derive(Clone, Debug)]
struct JBC_instructionVar33 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
    Rel8: TableRel8,
}
impl JBC_instructionVar33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JBC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_3(tokens) != 1 {
                return None;
            }
            if token_5(tokens) != 0 {
                return None;
            }
            let bit02 = token_4(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) =
            TablexBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:359:1, end:359:2))"]
#[derive(Clone, Debug)]
struct JNB_instructionVar34 {
    xBitAddr: TablexBitAddr,
    xBitByteAddr: TablexBitByteAddr,
    Rel8: TableRel8,
}
impl JNB_instructionVar34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JNB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_3(tokens) != 3 {
                return None;
            }
            if token_5(tokens) != 0 {
                return None;
            }
            let bit02 = token_4(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) =
            TablexBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitAddr,
                xBitByteAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:493:1, end:493:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar35 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
}
impl MOV_instructionVar35 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",CY")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_3(tokens) != 9 {
                return None;
            }
            if token_5(tokens) != 0 {
                return None;
            }
            let bit02 = token_4(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) =
            TablexBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:496:1, end:496:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar36 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr: TablexBitAddr,
}
impl MOV_instructionVar36 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("CY,"),
        ];
        display.extend_from_slice(&extend);
        self.xBitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_3(tokens) != 10 {
                return None;
            }
            if token_5(tokens) != 0 {
                return None;
            }
            let bit02 = token_4(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) =
            TablexBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:545:1, end:545:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar37 {
    xBitAddr: TablexBitAddr,
    xBitByteAddr: TablexBitByteAddr,
}
impl ORL_instructionVar37 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("CY,"),
        ];
        display.extend_from_slice(&extend);
        self.xBitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_3(tokens) != 7 {
                return None;
            }
            if token_5(tokens) != 0 {
                return None;
            }
            let bit02 = token_4(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) =
            TablexBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitAddr,
                xBitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:548:1, end:548:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar38 {
    xBitByteAddr: TablexBitByteAddr,
    xBitAddr2: TablexBitAddr2,
}
impl ORL_instructionVar38 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("CY,"),
        ];
        display.extend_from_slice(&extend);
        self.xBitAddr2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_3(tokens) != 14 {
                return None;
            }
            if token_5(tokens) != 0 {
                return None;
            }
            let bit02 = token_4(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr2 = if let Some((len, table)) =
            TablexBitAddr2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitByteAddr,
                xBitAddr2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:576:1, end:576:2))"]
#[derive(Clone, Debug)]
struct SETB_instructionVar39 {
    xBitAddr: TablexBitAddr,
    xBitByteAddr: TablexBitByteAddr,
}
impl SETB_instructionVar39 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SETB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.xBitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(".")];
        display.extend_from_slice(&extend);
        self.xBitByteAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c68 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_3(tokens) != 13 {
                return None;
            }
            if token_5(tokens) != 0 {
                return None;
            }
            let bit02 = token_4(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let xBitByteAddr = if let Some((len, table)) =
                TablexBitByteAddr::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((xBitByteAddr), (bit02), pattern_len))
        };
        let ((mut xBitByteAddr), (bit02), sub_len) =
            sub_pattern_c68(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let xBitAddr = if let Some((len, table)) =
            TablexBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                xBitAddr,
                xBitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:192:1, end:192:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar40 {
    drk47: u8,
    drk03: u8,
}
impl ADD_instructionVar40 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
            meaning_8_display(self.drk03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_5(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_7(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        let drk03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47, drk03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:216:1, end:216:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar41 {
    rm47_: u8,
    AtWRjb: TableAtWRjb,
}
impl ADD_instructionVar41 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let AtWRjb = if let Some((len, table)) =
            TableAtWRjb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:246:1, end:246:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar42 {
    rm47_: u8,
    AtWRjb: TableAtWRjb,
}
impl ANL_instructionVar42 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let AtWRjb = if let Some((len, table)) =
            TableAtWRjb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:295:1, end:295:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar43 {
    rm47_: u8,
    AtWRjb: TableAtWRjb,
}
impl CMP_instructionVar43 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let AtWRjb = if let Some((len, table)) =
            TableAtWRjb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:422:1, end:422:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar44 {
    rm47_: u8,
    AtWRjb: TableAtWRjb,
}
impl MOV_instructionVar44 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let AtWRjb = if let Some((len, table)) =
            TableAtWRjb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:428:1, end:428:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar45 {
    wrj47_: u8,
    AtWRjw: TableAtWRjw,
}
impl MOV_instructionVar45 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let AtWRjw = if let Some((len, table)) =
            TableAtWRjw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let wrj47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjw, wrj47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:438:1, end:438:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar46 {
    wrj47: u8,
    Direct8w: TableDirect8w,
}
impl MOV_instructionVar46 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct8w
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct8w = if let Some((len, table)) =
            TableDirect8w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:439:1, end:439:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar47 {
    wrj47: u8,
    Direct: TableDirect,
}
impl MOV_instructionVar47 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:457:1, end:457:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar48 {
    rm47_: u8,
    AtWRjb: TableAtWRjb,
}
impl MOV_instructionVar48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtWRjb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm47_),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let AtWRjb = if let Some((len, table)) =
            TableAtWRjb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:463:1, end:463:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar49 {
    wrj47_: u8,
    AtWRjw: TableAtWRjw,
}
impl MOV_instructionVar49 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtWRjw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj47_),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let AtWRjw = if let Some((len, table)) =
            TableAtWRjw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let wrj47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjw, wrj47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:539:1, end:539:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar50 {
    rm47_: u8,
    AtWRjb: TableAtWRjb,
}
impl ORL_instructionVar50 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let AtWRjb = if let Some((len, table)) =
            TableAtWRjb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:628:1, end:628:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar51 {
    rm47_: u8,
    AtWRjb: TableAtWRjb,
}
impl SUB_instructionVar51 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let AtWRjb = if let Some((len, table)) =
            TableAtWRjb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:659:1, end:659:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar52 {
    rm47_: u8,
    AtWRjb: TableAtWRjb,
}
impl XRL_instructionVar52 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47_),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRjb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let AtWRjb = if let Some((len, table)) =
            TableAtWRjb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let rm47_ = token_3(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjb, rm47_ }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:195:1, end:195:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar53 {
    rm47: u8,
    Data: TableData,
}
impl ADD_instructionVar53 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:198:1, end:198:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar54 {
    wrj47: u8,
    Data16: TableData16,
}
impl ADD_instructionVar54 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16 = if let Some((len, table)) =
            TableData16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:204:1, end:204:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar55 {
    rm47: u8,
    Direct: TableDirect,
}
impl ADD_instructionVar55 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:207:1, end:207:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar56 {
    wrj47: u8,
    Direct8w: TableDirect8w,
}
impl ADD_instructionVar56 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct8w = if let Some((len, table)) =
            TableDirect8w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:210:1, end:210:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar57 {
    rm47: u8,
    Direct16b: TableDirect16b,
}
impl ADD_instructionVar57 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16b = if let Some((len, table)) =
            TableDirect16b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:213:1, end:213:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar58 {
    wrj47: u8,
    Direct16w: TableDirect16w,
}
impl ADD_instructionVar58 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16w = if let Some((len, table)) =
            TableDirect16w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:228:1, end:228:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar59 {
    rm47: u8,
    Data: TableData,
}
impl ADD_instructionVar59 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:231:1, end:231:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar60 {
    wrj47: u8,
    Data16: TableData16,
}
impl ANL_instructionVar60 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16 = if let Some((len, table)) =
            TableData16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:234:1, end:234:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar61 {
    rm47: u8,
    Direct: TableDirect,
}
impl ANL_instructionVar61 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:237:1, end:237:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar62 {
    wrj47: u8,
    Direct8w: TableDirect8w,
}
impl ANL_instructionVar62 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct8w = if let Some((len, table)) =
            TableDirect8w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:240:1, end:240:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar63 {
    rm47: u8,
    Direct16b: TableDirect16b,
}
impl ANL_instructionVar63 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16b = if let Some((len, table)) =
            TableDirect16b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:243:1, end:243:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar64 {
    wrj47: u8,
    Direct16w: TableDirect16w,
}
impl ANL_instructionVar64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16w = if let Some((len, table)) =
            TableDirect16w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:268:1, end:268:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar65 {
    drk47: u8,
    drk03: u8,
}
impl CMP_instructionVar65 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
            meaning_8_display(self.drk03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_5(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_7(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        let drk03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47, drk03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:271:1, end:271:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar66 {
    rm47: u8,
    Data: TableData,
}
impl CMP_instructionVar66 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:274:1, end:274:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar67 {
    wrj47: u8,
    Data16: TableData16,
}
impl CMP_instructionVar67 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16 = if let Some((len, table)) =
            TableData16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:283:1, end:283:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar68 {
    rm47: u8,
    Direct: TableDirect,
}
impl CMP_instructionVar68 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:286:1, end:286:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar69 {
    wrj47: u8,
    Direct8w: TableDirect8w,
}
impl CMP_instructionVar69 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct8w = if let Some((len, table)) =
            TableDirect8w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:289:1, end:289:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar70 {
    rm47: u8,
    Direct16b: TableDirect16b,
}
impl CMP_instructionVar70 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16b = if let Some((len, table)) =
            TableDirect16b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:292:1, end:292:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar71 {
    wrj47: u8,
    Direct16w: TableDirect16w,
}
impl CMP_instructionVar71 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16w = if let Some((len, table)) =
            TableDirect16w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:377:1, end:377:2))"]
#[derive(Clone, Debug)]
struct LCALL_instructionVar72 {
    AtWRjw: TableAtWRjw,
}
impl LCALL_instructionVar72 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LCALL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtWRjw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let AtWRjw = if let Some((len, table)) =
            TableAtWRjw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:380:1, end:380:2))"]
#[derive(Clone, Debug)]
struct LJMP_instructionVar73 {
    AtWRjw: TableAtWRjw,
}
impl LJMP_instructionVar73 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LJMP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtWRjw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let AtWRjw = if let Some((len, table)) =
            TableAtWRjw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AtWRjw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:392:1, end:392:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar74 {
    rm47: u8,
    Data: TableData,
}
impl MOV_instructionVar74 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:395:1, end:395:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar75 {
    wrj47: u8,
    Data16: TableData16,
}
impl MOV_instructionVar75 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16 = if let Some((len, table)) =
            TableData16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:398:1, end:398:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar76 {
    drk47: u8,
    Data16x0: TableData16x0,
}
impl MOV_instructionVar76 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16x0 = if let Some((len, table)) =
            TableData16x0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x0, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:401:1, end:401:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar77 {
    drk47: u8,
    Data16x1: TableData16x1,
}
impl MOV_instructionVar77 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16x1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16x1 = if let Some((len, table)) =
            TableData16x1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16x1, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:404:1, end:404:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar78 {
    rm47: u8,
    Direct: TableDirect,
}
impl MOV_instructionVar78 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:407:1, end:407:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar79 {
    wrj47: u8,
    Direct8w: TableDirect8w,
}
impl MOV_instructionVar79 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct8w = if let Some((len, table)) =
            TableDirect8w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:410:1, end:410:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar80 {
    drk47: u8,
    Direct8w: TableDirect8w,
}
impl MOV_instructionVar80 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct8w = if let Some((len, table)) =
            TableDirect8w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:413:1, end:413:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar81 {
    rm47: u8,
    Direct16b: TableDirect16b,
}
impl MOV_instructionVar81 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16b = if let Some((len, table)) =
            TableDirect16b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:416:1, end:416:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar82 {
    wrj47: u8,
    Direct16w: TableDirect16w,
}
impl MOV_instructionVar82 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16w = if let Some((len, table)) =
            TableDirect16w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:419:1, end:419:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar83 {
    drk47: u8,
    Direct16d: TableDirect16d,
}
impl MOV_instructionVar83 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16d
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let drk47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16d = if let Some((len, table)) =
            TableDirect16d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16d, drk47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:434:1, end:434:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar84 {
    rm47: u8,
    Direct: TableDirect,
}
impl MOV_instructionVar84 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_2_display(self.rm47)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:448:1, end:448:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar85 {
    rm47: u8,
    Direct16b: TableDirect16b,
}
impl MOV_instructionVar85 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct16b
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_2_display(self.rm47)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16b = if let Some((len, table)) =
            TableDirect16b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:451:1, end:451:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar86 {
    wrj47: u8,
    Direct16w: TableDirect16w,
}
impl MOV_instructionVar86 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct16w
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16w = if let Some((len, table)) =
            TableDirect16w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:521:1, end:521:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar87 {
    rm47: u8,
    Data: TableData,
}
impl ORL_instructionVar87 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:524:1, end:524:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar88 {
    wrj47: u8,
    Data16: TableData16,
}
impl ORL_instructionVar88 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16 = if let Some((len, table)) =
            TableData16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:527:1, end:527:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar89 {
    rm47: u8,
    Direct: TableDirect,
}
impl ORL_instructionVar89 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:530:1, end:530:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar90 {
    wrj47: u8,
    Direct8w: TableDirect8w,
}
impl ORL_instructionVar90 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct8w = if let Some((len, table)) =
            TableDirect8w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:533:1, end:533:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar91 {
    rm47: u8,
    Direct16b: TableDirect16b,
}
impl ORL_instructionVar91 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16b = if let Some((len, table)) =
            TableDirect16b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:536:1, end:536:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar92 {
    wrj47: u8,
    Direct16w: TableDirect16w,
}
impl ORL_instructionVar92 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16w = if let Some((len, table)) =
            TableDirect16w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:551:1, end:551:2))"]
#[derive(Clone, Debug)]
struct POP_instructionVar93 {
    rm47: u8,
}
impl POP_instructionVar93 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("POP"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_2_display(self.rm47)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:554:1, end:554:2))"]
#[derive(Clone, Debug)]
struct POP_instructionVar94 {
    wrj47: u8,
}
impl POP_instructionVar94 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("POP"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:567:1, end:567:2))"]
#[derive(Clone, Debug)]
struct PUSH_instructionVar95 {
    rm47: u8,
}
impl PUSH_instructionVar95 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PUSH"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_2_display(self.rm47)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:570:1, end:570:2))"]
#[derive(Clone, Debug)]
struct PUSH_instructionVar96 {
    wrj47: u8,
}
impl PUSH_instructionVar96 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PUSH"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:579:1, end:579:2))"]
#[derive(Clone, Debug)]
struct SLL_instructionVar97 {
    rm47: u8,
}
impl SLL_instructionVar97 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SLL"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_2_display(self.rm47)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:582:1, end:582:2))"]
#[derive(Clone, Debug)]
struct SLL_instructionVar98 {
    wrj47: u8,
}
impl SLL_instructionVar98 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SLL"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:585:1, end:585:2))"]
#[derive(Clone, Debug)]
struct SRA_instructionVar99 {
    rm47: u8,
}
impl SRA_instructionVar99 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SRA"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_2_display(self.rm47)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:588:1, end:588:2))"]
#[derive(Clone, Debug)]
struct SRA_instructionVar100 {
    wrj47: u8,
}
impl SRA_instructionVar100 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SRA"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:591:1, end:591:2))"]
#[derive(Clone, Debug)]
struct SRL_instructionVar101 {
    rm47: u8,
}
impl SRL_instructionVar101 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SRL"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_2_display(self.rm47)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:594:1, end:594:2))"]
#[derive(Clone, Debug)]
struct SRL_instructionVar102 {
    wrj47: u8,
}
impl SRL_instructionVar102 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SRL"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:607:1, end:607:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar103 {
    rm47: u8,
    Data: TableData,
}
impl SUB_instructionVar103 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:610:1, end:610:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar104 {
    wrj47: u8,
    Data16: TableData16,
}
impl SUB_instructionVar104 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16 = if let Some((len, table)) =
            TableData16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:616:1, end:616:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar105 {
    rm47: u8,
    Direct: TableDirect,
}
impl SUB_instructionVar105 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:619:1, end:619:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar106 {
    wrj47: u8,
    Direct8w: TableDirect8w,
}
impl SUB_instructionVar106 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct8w = if let Some((len, table)) =
            TableDirect8w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:622:1, end:622:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar107 {
    rm47: u8,
    Direct16b: TableDirect16b,
}
impl SUB_instructionVar107 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16b = if let Some((len, table)) =
            TableDirect16b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:625:1, end:625:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar108 {
    wrj47: u8,
    Direct16w: TableDirect16w,
}
impl SUB_instructionVar108 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16w = if let Some((len, table)) =
            TableDirect16w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:641:1, end:641:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar109 {
    rm47: u8,
    Data: TableData,
}
impl XRL_instructionVar109 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:644:1, end:644:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar110 {
    wrj47: u8,
    Data16: TableData16,
}
impl XRL_instructionVar110 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Data16 = if let Some((len, table)) =
            TableData16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data16, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:647:1, end:647:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar111 {
    rm47: u8,
    Direct: TableDirect,
}
impl XRL_instructionVar111 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:650:1, end:650:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar112 {
    wrj47: u8,
    Direct8w: TableDirect8w,
}
impl XRL_instructionVar112 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct8w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct8w = if let Some((len, table)) =
            TableDirect8w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct8w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:653:1, end:653:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar113 {
    rm47: u8,
    Direct16b: TableDirect16b,
}
impl XRL_instructionVar113 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16b = if let Some((len, table)) =
            TableDirect16b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16b, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:656:1, end:656:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar114 {
    wrj47: u8,
    Direct16w: TableDirect16w,
}
impl XRL_instructionVar114 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct16w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let Direct16w = if let Some((len, table)) =
            TableDirect16w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct16w, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:305:1, end:305:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar115 {
    rm47: u8,
    Short: TableShort,
}
impl DEC_instructionVar115 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEC"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Short
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Short = if let Some((len, table)) =
            TableShort::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_6(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_12(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Short, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:308:1, end:308:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar116 {
    wrj47: u8,
    Short: TableShort,
}
impl DEC_instructionVar116 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEC"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Short
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Short = if let Some((len, table)) =
            TableShort::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_6(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_12(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Short, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:335:1, end:335:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar117 {
    rm47: u8,
    Short: TableShort,
}
impl INC_instructionVar117 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INC"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Short
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Short = if let Some((len, table)) =
            TableShort::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_6(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_12(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Short, rm47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:338:1, end:338:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar118 {
    wrj47: u8,
    Short: TableShort,
}
impl INC_instructionVar118 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INC"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Short
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Short = if let Some((len, table)) =
            TableShort::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_6(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_12(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Short, wrj47 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:604:1, end:604:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar119 {
    drk47: u8,
    drk03: u8,
}
impl SUB_instructionVar119 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
            meaning_8_display(self.drk03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_17(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_8(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_5(tokens_param) == 0 {
                    return Some(((), (), 1));
                }
                if token_7(tokens_param) == 4 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c9(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let drk47 = token_3(tokens_current);
        let drk03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47, drk03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:475:1, end:475:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar120 {
    rm47: u8,
    AtDRk03Dis24b: TableAtDRk03Dis24b,
}
impl MOV_instructionVar120 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRk03Dis24b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_5(tokens_param) == 0 {
                        return Some(((), (), 1));
                    }
                    if token_7(tokens_param) == 4 {
                        return Some(((), (), 1));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c9(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let rm47 = token_3(tokens);
            let drk03 = token_2(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (rm47, drk03), pattern_len))
        };
        let ((), (rm47, drk03), sub_len) = sub_pattern_c58(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRk03Dis24b = if let Some((len, table)) =
            TableAtDRk03Dis24b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtDRk03Dis24b,
                rm47,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:478:1, end:478:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar121 {
    wrj47: u8,
    AtDRk03Dis24w: TableAtDRk03Dis24w,
}
impl MOV_instructionVar121 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtDRk03Dis24w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_5(tokens_param) == 0 {
                        return Some(((), (), 1));
                    }
                    if token_7(tokens_param) == 4 {
                        return Some(((), (), 1));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c9(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let wrj47 = token_3(tokens);
            let drk03 = token_2(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (wrj47, drk03), pattern_len))
        };
        let ((), (wrj47, drk03), sub_len) = sub_pattern_c58(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRk03Dis24w = if let Some((len, table)) =
            TableAtDRk03Dis24w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtDRk03Dis24w,
                wrj47,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:487:1, end:487:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar122 {
    rm03: u8,
    AtDRk47Dis24b: TableAtDRk47Dis24b,
}
impl MOV_instructionVar122 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtDRk47Dis24b
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_2_display(self.rm03)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_17(tokens_param) == 0 {
                        return Some(((), (), 1));
                    }
                    if token_8(tokens_param) == 4 {
                        return Some(((), (), 1));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c9(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let drk47 = token_3(tokens);
            let rm03 = token_2(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (drk47, rm03), pattern_len))
        };
        let ((), (drk47, rm03), sub_len) = sub_pattern_c58(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRk47Dis24b = if let Some((len, table)) =
            TableAtDRk47Dis24b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtDRk47Dis24b,
                rm03,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:490:1, end:490:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar123 {
    wrj03: u8,
    AtDRk47Dis24w: TableAtDRk47Dis24w,
}
impl MOV_instructionVar123 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtDRk47Dis24w
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let mut sub_pattern_c59 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c9 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_17(tokens_param) == 0 {
                        return Some(((), (), 1));
                    }
                    if token_8(tokens_param) == 4 {
                        return Some(((), (), 1));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c9(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let wrj03 = token_2(tokens);
            let drk47 = token_3(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (wrj03, drk47), pattern_len))
        };
        let ((), (wrj03, drk47), sub_len) = sub_pattern_c59(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let AtDRk47Dis24w = if let Some((len, table)) =
            TableAtDRk47Dis24w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtDRk47Dis24w,
                wrj03,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:675:1, end:675:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar124 {
    Areg: TableAreg,
    Data: TableData,
}
impl ANL_instructionVar124 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:679:1, end:679:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar125 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl ANL_instructionVar125 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:680:1, end:680:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar126 {
    CY: TableCY,
    BitByteAddr: TableBitByteAddr,
    BitAddr2: TableBitAddr2,
}
impl ANL_instructionVar126 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr2 = if let Some((len, table)) =
            TableBitAddr2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitByteAddr,
                BitAddr2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:700:1, end:700:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar127 {
    BitByteAddr: TableBitByteAddr,
    BitAddr: TableBitAddr,
}
impl CLR_instructionVar127 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitByteAddr,
                BitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:710:1, end:710:2))"]
#[derive(Clone, Debug)]
struct CPL_instructionVar128 {
    Areg: TableAreg,
}
impl CPL_instructionVar128 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:711:1, end:711:2))"]
#[derive(Clone, Debug)]
struct CPL_instructionVar129 {
    CY: TableCY,
}
impl CPL_instructionVar129 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CY }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:713:1, end:713:2))"]
#[derive(Clone, Debug)]
struct CPL_instructionVar130 {
    BitByteAddr: TableBitByteAddr,
    BitAddr: TableBitAddr,
}
impl CPL_instructionVar130 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitByteAddr,
                BitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:749:1, end:749:2))"]
#[derive(Clone, Debug)]
struct JB_instructionVar131 {
    BitByteAddr: TableBitByteAddr,
    BitAddr: TableBitAddr,
    Rel8: TableRel8,
}
impl JB_instructionVar131 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitByteAddr,
                BitAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:750:1, end:750:2))"]
#[derive(Clone, Debug)]
struct JBC_instructionVar132 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
    Rel8: TableRel8,
}
impl JBC_instructionVar132 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JBC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:764:1, end:764:2))"]
#[derive(Clone, Debug)]
struct JNB_instructionVar133 {
    BitByteAddr: TableBitByteAddr,
    BitAddr: TableBitAddr,
    Rel8: TableRel8,
}
impl JNB_instructionVar133 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JNB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitByteAddr,
                BitAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:809:1, end:809:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar134 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl MOV_instructionVar134 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:810:1, end:810:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar135 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl MOV_instructionVar135 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:842:1, end:842:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar136 {
    CY: TableCY,
    BitByteAddr: TableBitByteAddr,
    BitAddr: TableBitAddr,
}
impl ORL_instructionVar136 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitByteAddr,
                BitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:843:1, end:843:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar137 {
    CY: TableCY,
    BitAddr2: TableBitAddr2,
    BitByteAddr: TableBitByteAddr,
}
impl ORL_instructionVar137 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr2 = if let Some((len, table)) =
            TableBitAddr2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr2,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:886:1, end:886:2))"]
#[derive(Clone, Debug)]
struct SETB_instructionVar138 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl SETB_instructionVar138 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SETB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:186:1, end:186:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar139 {
    rm47: u8,
    rm03: u8,
}
impl ADD_instructionVar139 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        let rm03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:189:1, end:189:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar140 {
    wrj47: u8,
    wrj03: u8,
}
impl ADD_instructionVar140 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        let wrj03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:222:1, end:222:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar141 {
    rm47: u8,
    rm03: u8,
}
impl ANL_instructionVar141 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        let rm03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:225:1, end:225:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar142 {
    wrj47: u8,
    wrj03: u8,
}
impl ANL_instructionVar142 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        let wrj03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:261:1, end:261:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar143 {
    rm47: u8,
    rm03: u8,
}
impl CMP_instructionVar143 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm03 = token_2(tokens_current);
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:265:1, end:265:2))"]
#[derive(Clone, Debug)]
struct CMP_instructionVar144 {
    wrj47: u8,
    wrj03: u8,
}
impl CMP_instructionVar144 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMP"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        let wrj03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:314:1, end:314:2))"]
#[derive(Clone, Debug)]
struct DIV_instructionVar145 {
    rm47: u8,
    rm03: u8,
}
impl DIV_instructionVar145 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DIV"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        let rm47_d2 = token_3(tokens_current);
        let rm47_d1 = token_3(tokens_current);
        let rm03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:317:1, end:317:2))"]
#[derive(Clone, Debug)]
struct DIV_instructionVar146 {
    wrj47: u8,
    wrj03: u8,
}
impl DIV_instructionVar146 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DIV"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj03 = token_2(tokens_current);
        let wrj47 = token_3(tokens_current);
        let wrj47_d1 = token_3(tokens_current);
        let wrj47_d2 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:320:1, end:320:2))"]
#[derive(Clone, Debug)]
struct ECALL_instructionVar147 {
    Addr24: TableAddr24,
}
impl ECALL_instructionVar147 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ECALL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3;
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:326:1, end:326:2))"]
#[derive(Clone, Debug)]
struct EJMP_instructionVar148 {
    Addr24: TableAddr24,
}
impl EJMP_instructionVar148 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EJMP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3;
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:332:1, end:332:2))"]
#[derive(Clone, Debug)]
struct ERET_instructionVar149 {}
impl ERET_instructionVar149 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ERET"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:350:1, end:350:2))"]
#[derive(Clone, Debug)]
struct JE_instructionVar150 {
    Rel8: TableRel8,
}
impl JE_instructionVar150 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:353:1, end:353:2))"]
#[derive(Clone, Debug)]
struct JG_instructionVar151 {
    Rel8: TableRel8,
}
impl JG_instructionVar151 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JG"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:356:1, end:356:2))"]
#[derive(Clone, Debug)]
struct JLE_instructionVar152 {
    Rel8: TableRel8,
}
impl JLE_instructionVar152 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JLE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:362:1, end:362:2))"]
#[derive(Clone, Debug)]
struct JNE_instructionVar153 {
    Rel8: TableRel8,
}
impl JNE_instructionVar153 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JNE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:365:1, end:365:2))"]
#[derive(Clone, Debug)]
struct JSG_instructionVar154 {
    Rel8: TableRel8,
}
impl JSG_instructionVar154 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JSG"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:368:1, end:368:2))"]
#[derive(Clone, Debug)]
struct JSGE_instructionVar155 {
    Rel8: TableRel8,
}
impl JSGE_instructionVar155 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JSGE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:371:1, end:371:2))"]
#[derive(Clone, Debug)]
struct JSL_instructionVar156 {
    Rel8: TableRel8,
}
impl JSL_instructionVar156 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JSL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:374:1, end:374:2))"]
#[derive(Clone, Debug)]
struct JSLE_instructionVar157 {
    Rel8: TableRel8,
}
impl JSLE_instructionVar157 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JSLE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:383:1, end:383:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar158 {
    rm47: u8,
    rm03: u8,
}
impl MOV_instructionVar158 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm03 = token_2(tokens_current);
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:386:1, end:386:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar159 {
    wrj47: u8,
    wrj03: u8,
}
impl MOV_instructionVar159 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj03 = token_2(tokens_current);
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:389:1, end:389:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar160 {
    drk47: u8,
    drk03: u8,
}
impl MOV_instructionVar160 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal(","),
            meaning_8_display(self.drk03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let drk47 = token_3(tokens_current);
        let drk03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47, drk03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:469:1, end:469:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar161 {
    rm47: u8,
    AtWRj03Dis16b: TableAtWRj03Dis16b,
}
impl MOV_instructionVar161 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRj03Dis16b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3;
        let AtWRj03Dis16b = if let Some((len, table)) =
            TableAtWRj03Dis16b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtWRj03Dis16b,
                rm47,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:472:1, end:472:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar162 {
    wrj47: u8,
    AtWRj03Dis16w: TableAtWRj03Dis16w,
}
impl MOV_instructionVar162 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.AtWRj03Dis16w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3;
        let AtWRj03Dis16w = if let Some((len, table)) =
            TableAtWRj03Dis16w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtWRj03Dis16w,
                wrj47,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:481:1, end:481:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar163 {
    rm03: u8,
    AtWRj47Dis16b: TableAtWRj47Dis16b,
}
impl MOV_instructionVar163 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtWRj47Dis16b
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_2_display(self.rm03)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3;
        let AtWRj47Dis16b = if let Some((len, table)) =
            TableAtWRj47Dis16b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtWRj47Dis16b,
                rm03,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:484:1, end:484:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar164 {
    wrj03: u8,
    AtWRj47Dis16w: TableAtWRj47Dis16w,
}
impl MOV_instructionVar164 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.AtWRj47Dis16w
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3;
        let AtWRj47Dis16w = if let Some((len, table)) =
            TableAtWRj47Dis16w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let wrj03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AtWRj47Dis16w,
                wrj03,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:503:1, end:503:2))"]
#[derive(Clone, Debug)]
struct MOVZ_instructionVar165 {
    wrj47: u8,
    rm03: u8,
}
impl MOVZ_instructionVar165 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVZ"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        let rm03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:506:1, end:506:2))"]
#[derive(Clone, Debug)]
struct MOVZ_instructionVar166 {
    wrj47: u8,
    rm03: u8,
}
impl MOVZ_instructionVar166 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVZ"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm03 = token_2(tokens_current);
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:509:1, end:509:2))"]
#[derive(Clone, Debug)]
struct MUL_instructionVar167 {
    rm47: u8,
    rm03: u8,
}
impl MUL_instructionVar167 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MUL"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47_d2 = token_3(tokens_current);
        let rm47 = token_3(tokens_current);
        let rm03 = token_2(tokens_current);
        let rm47_d1 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:512:1, end:512:2))"]
#[derive(Clone, Debug)]
struct MUL_instructionVar168 {
    wrj47: u8,
    wrj03: u8,
}
impl MUL_instructionVar168 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MUL"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        let wrj47_d1 = token_3(tokens_current);
        let wrj47_d2 = token_3(tokens_current);
        let wrj03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:515:1, end:515:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar169 {
    rm47: u8,
    rm03: u8,
}
impl ORL_instructionVar169 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        let rm03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:518:1, end:518:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar170 {
    wrj47: u8,
    wrj03: u8,
}
impl ORL_instructionVar170 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj03 = token_2(tokens_current);
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:598:1, end:598:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar171 {
    rm47: u8,
    rm03: u8,
}
impl SUB_instructionVar171 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm03 = token_2(tokens_current);
        let rm47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:601:1, end:601:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar172 {
    wrj47: u8,
    wrj03: u8,
}
impl SUB_instructionVar172 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj47 = token_3(tokens_current);
        let wrj03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:635:1, end:635:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar173 {
    rm47: u8,
    rm03: u8,
}
impl XRL_instructionVar173 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.rm47),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.rm03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rm47 = token_3(tokens_current);
        let rm03 = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm47, rm03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:638:1, end:638:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar174 {
    wrj47: u8,
    wrj03: u8,
}
impl XRL_instructionVar174 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.wrj03),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let wrj03 = token_2(tokens_current);
        let wrj47 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, wrj03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:656:1, end:656:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar175 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl ADD_instructionVar175 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:658:1, end:658:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar176 {
    Areg: TableAreg,
    Data: TableData,
}
impl ADD_instructionVar176 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:661:1, end:661:2))"]
#[derive(Clone, Debug)]
struct ADDC_instructionVar177 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl ADDC_instructionVar177 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:663:1, end:663:2))"]
#[derive(Clone, Debug)]
struct ADDC_instructionVar178 {
    Areg: TableAreg,
    Data: TableData,
}
impl ADDC_instructionVar178 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:673:1, end:673:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar179 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl ANL_instructionVar179 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:676:1, end:676:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar180 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl ANL_instructionVar180 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:677:1, end:677:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar181 {
    Direct: TableDirect,
    Data: TableData,
}
impl ANL_instructionVar181 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:682:1, end:682:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar182 {
    CY: TableCY,
    BitByteAddr: TableBitByteAddr,
    BitAddr: TableBitAddr,
}
impl ANL_instructionVar182 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitByteAddr,
                BitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:683:1, end:683:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar183 {
    CY: TableCY,
    BitByteAddr: TableBitByteAddr,
    BitAddr2: TableBitAddr2,
}
impl ANL_instructionVar183 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr2 = if let Some((len, table)) =
            TableBitAddr2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitByteAddr,
                BitAddr2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:692:1, end:692:2))"]
#[derive(Clone, Debug)]
struct CJNE_instructionVar184 {
    Areg: TableAreg,
    Direct: TableDirect,
    Rel8: TableRel8,
}
impl CJNE_instructionVar184 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CJNE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct, Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:693:1, end:693:2))"]
#[derive(Clone, Debug)]
struct CJNE_instructionVar185 {
    Areg: TableAreg,
    Data: TableData,
    Rel8: TableRel8,
}
impl CJNE_instructionVar185 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CJNE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data, Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:697:1, end:697:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar186 {
    Areg: TableAreg,
}
impl CLR_instructionVar186 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:698:1, end:698:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar187 {
    CY: TableCY,
}
impl CLR_instructionVar187 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CY }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:702:1, end:702:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar188 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl CLR_instructionVar188 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:715:1, end:715:2))"]
#[derive(Clone, Debug)]
struct CPL_instructionVar189 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl CPL_instructionVar189 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:722:1, end:722:2))"]
#[derive(Clone, Debug)]
struct DA_instructionVar190 {
    Areg: TableAreg,
}
impl DA_instructionVar190 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:724:1, end:724:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar191 {
    Areg: TableAreg,
}
impl DEC_instructionVar191 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:726:1, end:726:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar192 {
    Direct: TableDirect,
}
impl DEC_instructionVar192 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:729:1, end:729:2))"]
#[derive(Clone, Debug)]
struct DIV_instructionVar193 {
    ABreg: TableABreg,
}
impl DIV_instructionVar193 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DIV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ABreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let ABreg = if let Some((len, table)) =
            TableABreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ABreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:733:1, end:733:2))"]
#[derive(Clone, Debug)]
struct DJNZ_instructionVar194 {
    Direct: TableDirect,
    Rel8: TableRel8,
}
impl DJNZ_instructionVar194 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DJNZ"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:735:1, end:735:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar195 {
    Areg: TableAreg,
}
impl INC_instructionVar195 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:737:1, end:737:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar196 {
    Direct: TableDirect,
}
impl INC_instructionVar196 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:747:1, end:747:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar197 {
    DPTRreg: TableDPTRreg,
}
impl INC_instructionVar197 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.DPTRreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let DPTRreg = if let Some((len, table)) =
            TableDPTRreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { DPTRreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:752:1, end:752:2))"]
#[derive(Clone, Debug)]
struct JB_instructionVar198 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
    Rel8: TableRel8,
}
impl JB_instructionVar198 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:753:1, end:753:2))"]
#[derive(Clone, Debug)]
struct JBC_instructionVar199 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
    Rel8: TableRel8,
}
impl JBC_instructionVar199 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JBC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:761:1, end:761:2))"]
#[derive(Clone, Debug)]
struct JC_instructionVar200 {
    Rel8: TableRel8,
}
impl JC_instructionVar200 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:762:1, end:762:2))"]
#[derive(Clone, Debug)]
struct JMP_instructionVar201 {
    ADPTR: TableADPTR,
}
impl JMP_instructionVar201 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JMP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ADPTR
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let ADPTR = if let Some((len, table)) =
            TableADPTR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ADPTR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:766:1, end:766:2))"]
#[derive(Clone, Debug)]
struct JNB_instructionVar202 {
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
    Rel8: TableRel8,
}
impl JNB_instructionVar202 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JNB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitAddr,
                BitByteAddr,
                Rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:773:1, end:773:2))"]
#[derive(Clone, Debug)]
struct JNC_instructionVar203 {
    Rel8: TableRel8,
}
impl JNC_instructionVar203 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JNC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:774:1, end:774:2))"]
#[derive(Clone, Debug)]
struct JNZ_instructionVar204 {
    Rel8: TableRel8,
}
impl JNZ_instructionVar204 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JNZ"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:775:1, end:775:2))"]
#[derive(Clone, Debug)]
struct JZ_instructionVar205 {
    Rel8: TableRel8,
}
impl JZ_instructionVar205 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JZ"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:784:1, end:784:2))"]
#[derive(Clone, Debug)]
struct LCALL_instructionVar206 {
    Addr16: TableAddr16,
}
impl LCALL_instructionVar206 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LCALL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Addr16 = if let Some((len, table)) =
            TableAddr16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:785:1, end:785:2))"]
#[derive(Clone, Debug)]
struct LJMP_instructionVar207 {
    Addr16: TableAddr16,
}
impl LJMP_instructionVar207 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LJMP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Addr16 = if let Some((len, table)) =
            TableAddr16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:789:1, end:789:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar208 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl MOV_instructionVar208 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:791:1, end:791:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar209 {
    Areg: TableAreg,
    Data: TableData,
}
impl MOV_instructionVar209 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:795:1, end:795:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar210 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl MOV_instructionVar210 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:797:1, end:797:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar211 {
    Direct: TableDirect,
    Direct2: TableDirect2,
}
impl MOV_instructionVar211 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Direct2 = if let Some((len, table)) =
            TableDirect2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, Direct2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:799:1, end:799:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar212 {
    Direct: TableDirect,
    Data: TableData,
}
impl MOV_instructionVar212 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:806:1, end:806:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar213 {
    DPTRreg: TableDPTRreg,
    Data16: TableData16,
}
impl MOV_instructionVar213 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.DPTRreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let DPTRreg = if let Some((len, table)) =
            TableDPTRreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Data16 = if let Some((len, table)) =
            TableData16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { DPTRreg, Data16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:812:1, end:812:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar214 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl MOV_instructionVar214 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:813:1, end:813:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar215 {
    CY: TableCY,
    BitByteAddr: TableBitByteAddr,
    BitAddr: TableBitAddr,
}
impl MOV_instructionVar215 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitByteAddr,
                BitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:822:1, end:822:2))"]
#[derive(Clone, Debug)]
struct MOVC_instructionVar216 {
    Areg: TableAreg,
    ADPTR: TableADPTR,
}
impl MOVC_instructionVar216 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ADPTR
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let ADPTR = if let Some((len, table)) =
            TableADPTR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, ADPTR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:823:1, end:823:2))"]
#[derive(Clone, Debug)]
struct MOVC_instructionVar217 {
    Areg: TableAreg,
    APC: TableAPC,
}
impl MOVC_instructionVar217 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.APC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let APC = if let Some((len, table)) =
            TableAPC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, APC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:826:1, end:826:2))"]
#[derive(Clone, Debug)]
struct MOVX_instructionVar218 {
    Areg: TableAreg,
    ATDPTR: TableATDPTR,
}
impl MOVX_instructionVar218 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVX"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ATDPTR
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ATDPTR = if let Some((len, table)) =
            TableATDPTR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, ATDPTR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:828:1, end:828:2))"]
#[derive(Clone, Debug)]
struct MOVX_instructionVar219 {
    Areg: TableAreg,
    ATDPTR: TableATDPTR,
}
impl MOVX_instructionVar219 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVX"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ATDPTR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ATDPTR = if let Some((len, table)) =
            TableATDPTR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, ATDPTR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:830:1, end:830:2))"]
#[derive(Clone, Debug)]
struct MUL_instructionVar220 {
    ABreg: TableABreg,
}
impl MUL_instructionVar220 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MUL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ABreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let ABreg = if let Some((len, table)) =
            TableABreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ABreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:833:1, end:833:2))"]
#[derive(Clone, Debug)]
struct NOP_instructionVar221 {}
impl NOP_instructionVar221 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("NOP"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:836:1, end:836:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar222 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl ORL_instructionVar222 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:838:1, end:838:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar223 {
    Areg: TableAreg,
    Data: TableData,
}
impl ORL_instructionVar223 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:839:1, end:839:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar224 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl ORL_instructionVar224 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:840:1, end:840:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar225 {
    Areg: TableAreg,
    Direct: TableDirect,
    Data: TableData,
}
impl ORL_instructionVar225 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:845:1, end:845:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar226 {
    CY: TableCY,
    BitAddr: TableBitAddr,
    BitByteAddr: TableBitByteAddr,
}
impl ORL_instructionVar226 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitAddr,
                BitByteAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:846:1, end:846:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar227 {
    CY: TableCY,
    BitByteAddr: TableBitByteAddr,
    BitAddr2: TableBitAddr2,
}
impl ORL_instructionVar227 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.BitAddr2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr2 = if let Some((len, table)) =
            TableBitAddr2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CY,
                BitByteAddr,
                BitAddr2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:855:1, end:855:2))"]
#[derive(Clone, Debug)]
struct POP_instructionVar228 {
    Direct: TableDirect,
}
impl POP_instructionVar228 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("POP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:857:1, end:857:2))"]
#[derive(Clone, Debug)]
struct PUSH_instructionVar229 {
    Direct: TableDirect,
}
impl PUSH_instructionVar229 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PUSH"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:859:1, end:859:2))"]
#[derive(Clone, Debug)]
struct RET_instructionVar230 {}
impl RET_instructionVar230 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RET"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:869:1, end:869:2))"]
#[derive(Clone, Debug)]
struct RETI_instructionVar231 {}
impl RETI_instructionVar231 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RETI"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:879:1, end:879:2))"]
#[derive(Clone, Debug)]
struct RL_instructionVar232 {
    Areg: TableAreg,
}
impl RL_instructionVar232 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:880:1, end:880:2))"]
#[derive(Clone, Debug)]
struct RLC_instructionVar233 {
    Areg: TableAreg,
}
impl RLC_instructionVar233 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RLC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:881:1, end:881:2))"]
#[derive(Clone, Debug)]
struct RR_instructionVar234 {
    Areg: TableAreg,
}
impl RR_instructionVar234 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:882:1, end:882:2))"]
#[derive(Clone, Debug)]
struct RRC_instructionVar235 {
    Areg: TableAreg,
}
impl RRC_instructionVar235 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RRC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:884:1, end:884:2))"]
#[derive(Clone, Debug)]
struct SETB_instructionVar236 {
    CY: TableCY,
}
impl SETB_instructionVar236 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SETB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CY
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let CY = if let Some((len, table)) =
            TableCY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CY }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:888:1, end:888:2))"]
#[derive(Clone, Debug)]
struct SETB_instructionVar237 {
    BitByteAddr: TableBitByteAddr,
    BitAddr: TableBitAddr,
}
impl SETB_instructionVar237 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SETB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BitAddr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let BitAddr = if let Some((len, table)) =
            TableBitAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BitByteAddr = if let Some((len, table)) =
            TableBitByteAddr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sfrbit = token_4(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                BitByteAddr,
                BitAddr,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:895:1, end:895:2))"]
#[derive(Clone, Debug)]
struct SJMP_instructionVar238 {
    Rel8: TableRel8,
}
impl SJMP_instructionVar238 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SJMP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:898:1, end:898:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar239 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl SUBB_instructionVar239 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:900:1, end:900:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar240 {
    Areg: TableAreg,
    Data: TableData,
}
impl SUBB_instructionVar240 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:902:1, end:902:2))"]
#[derive(Clone, Debug)]
struct SWAP_instructionVar241 {
    Areg: TableAreg,
}
impl SWAP_instructionVar241 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SWAP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:905:1, end:905:2))"]
#[derive(Clone, Debug)]
struct XCH_instructionVar242 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl XCH_instructionVar242 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XCH"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:912:1, end:912:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar243 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl XRL_instructionVar243 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:914:1, end:914:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar244 {
    Areg: TableAreg,
    Data: TableData,
}
impl XRL_instructionVar244 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:915:1, end:915:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar245 {
    Areg: TableAreg,
    Direct: TableDirect,
}
impl XRL_instructionVar245 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:916:1, end:916:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar246 {
    Direct: TableDirect,
    Data: TableData,
}
impl XRL_instructionVar246 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:652:1, end:652:2))"]
#[derive(Clone, Debug)]
struct ACALL_instructionVar247 {
    Addr11: TableAddr11,
}
impl ACALL_instructionVar247 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ACALL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Addr11 = if let Some((len, table)) =
            TableAddr11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:657:1, end:657:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar248 {
    Areg: TableAreg,
    Ri: TableRi,
}
impl ADD_instructionVar248 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:662:1, end:662:2))"]
#[derive(Clone, Debug)]
struct ADDC_instructionVar249 {
    Areg: TableAreg,
    Ri: TableRi,
}
impl ADDC_instructionVar249 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:674:1, end:674:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar250 {
    Areg: TableAreg,
    Ri: TableRi,
}
impl ANL_instructionVar250 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:695:1, end:695:2))"]
#[derive(Clone, Debug)]
struct CJNE_instructionVar251 {
    Ri: TableRi,
    Data: TableData,
    Rel8: TableRel8,
}
impl CJNE_instructionVar251 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CJNE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Data, Rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:727:1, end:727:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar252 {
    Ri: TableRi,
}
impl DEC_instructionVar252 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:746:1, end:746:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar253 {
    Ri: TableRi,
}
impl INC_instructionVar253 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:790:1, end:790:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar254 {
    Ri: TableRi,
    Areg: TableAreg,
}
impl MOV_instructionVar254 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:798:1, end:798:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar255 {
    Ri: TableRi,
    Direct: TableDirect,
}
impl MOV_instructionVar255 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:800:1, end:800:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar256 {
    Ri: TableRi,
    Areg: TableAreg,
}
impl MOV_instructionVar256 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:801:1, end:801:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar257 {
    Ri: TableRi,
    Direct: TableDirect,
}
impl MOV_instructionVar257 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Direct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:802:1, end:802:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar258 {
    Ri: TableRi,
    Data: TableData,
}
impl MOV_instructionVar258 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Data }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:825:1, end:825:2))"]
#[derive(Clone, Debug)]
struct MOVX_instructionVar259 {
    RiX: TableRiX,
    Areg: TableAreg,
}
impl MOVX_instructionVar259 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVX"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RiX
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let RiX = if let Some((len, table)) =
            TableRiX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RiX, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:827:1, end:827:2))"]
#[derive(Clone, Debug)]
struct MOVX_instructionVar260 {
    Areg: TableAreg,
    RiX: TableRiX,
}
impl MOVX_instructionVar260 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVX"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RiX
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let RiX = if let Some((len, table)) =
            TableRiX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, RiX }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:837:1, end:837:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar261 {
    Ri: TableRi,
    Areg: TableAreg,
}
impl ORL_instructionVar261 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:899:1, end:899:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar262 {
    Areg: TableAreg,
    Ri: TableRi,
}
impl SUBB_instructionVar262 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, Ri }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:906:1, end:906:2))"]
#[derive(Clone, Debug)]
struct XCH_instructionVar263 {
    Ri: TableRi,
    Areg: TableAreg,
}
impl XCH_instructionVar263 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XCH"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:913:1, end:913:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar264 {
    Ri: TableRi,
    Areg: TableAreg,
}
impl XRL_instructionVar264 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:655:1, end:655:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar265 {
    rn: u8,
    Areg: TableAreg,
}
impl ADD_instructionVar265 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:660:1, end:660:2))"]
#[derive(Clone, Debug)]
struct ADDC_instructionVar266 {
    rn: u8,
    Areg: TableAreg,
}
impl ADDC_instructionVar266 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:669:1, end:669:2))"]
#[derive(Clone, Debug)]
struct AJMP_instructionVar267 {
    Addr11: TableAddr11,
}
impl AJMP_instructionVar267 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("AJMP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Addr11 = if let Some((len, table)) =
            TableAddr11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:672:1, end:672:2))"]
#[derive(Clone, Debug)]
struct ANL_instructionVar268 {
    rn: u8,
    Areg: TableAreg,
}
impl ANL_instructionVar268 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:694:1, end:694:2))"]
#[derive(Clone, Debug)]
struct CJNE_instructionVar269 {
    rn: u8,
    Data: TableData,
    Rel8: TableRel8,
}
impl CJNE_instructionVar269 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CJNE"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, Rel8, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:725:1, end:725:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar270 {
    rn: u8,
}
impl DEC_instructionVar270 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEC"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_0_display(self.rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:732:1, end:732:2))"]
#[derive(Clone, Debug)]
struct DJNZ_instructionVar271 {
    rn: u8,
    Rel8: TableRel8,
}
impl DJNZ_instructionVar271 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DJNZ"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Rel8 = if let Some((len, table)) =
            TableRel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel8, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:736:1, end:736:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar272 {
    rn: u8,
}
impl INC_instructionVar272 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INC"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_0_display(self.rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:788:1, end:788:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar273 {
    rn: u8,
    Areg: TableAreg,
}
impl MOV_instructionVar273 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:792:1, end:792:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar274 {
    rn: u8,
    Areg: TableAreg,
}
impl MOV_instructionVar274 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:793:1, end:793:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar275 {
    rn: u8,
    Direct: TableDirect,
}
impl MOV_instructionVar275 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:794:1, end:794:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar276 {
    rn: u8,
    Data: TableData,
}
impl MOV_instructionVar276 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Data
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Data = if let Some((len, table)) =
            TableData::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Data, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:796:1, end:796:2))"]
#[derive(Clone, Debug)]
struct MOV_instructionVar277 {
    rn: u8,
    Direct: TableDirect,
}
impl MOV_instructionVar277 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOV"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:835:1, end:835:2))"]
#[derive(Clone, Debug)]
struct ORL_instructionVar278 {
    rn: u8,
    Areg: TableAreg,
}
impl ORL_instructionVar278 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:897:1, end:897:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar279 {
    rn: u8,
    Areg: TableAreg,
}
impl SUBB_instructionVar279 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:904:1, end:904:2))"]
#[derive(Clone, Debug)]
struct XCH_instructionVar280 {
    rn: u8,
    Areg: TableAreg,
}
impl XCH_instructionVar280 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XCH"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:909:1, end:909:2))"]
#[derive(Clone, Debug)]
struct XCHD_instructionVar281 {
    Ri: TableRi,
    Areg: TableAreg,
}
impl XCHD_instructionVar281 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XCHD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ri
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Ri = if let Some((len, table)) =
            TableRi::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ri, Areg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:911:1, end:911:2))"]
#[derive(Clone, Debug)]
struct XRL_instructionVar282 {
    rn: u8,
    Areg: TableAreg,
}
impl XRL_instructionVar282 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XRL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Areg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 0 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 0;
                    if context_instance.read_srcMode() != 1 {
                        return None;
                    }
                    if context_instance.read_A5Prefix() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c2(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Areg = if let Some((len, table)) =
            TableAreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Areg, rn }))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(instructionVar0),
    Var1(instructionVar1),
    Var2(ADD_instructionVar2),
    Var3(ANL_instructionVar3),
    Var4(CMP_instructionVar4),
    Var5(MOV_instructionVar5),
    Var6(MOV_instructionVar6),
    Var7(MOV_instructionVar7),
    Var8(MOV_instructionVar8),
    Var9(MOV_instructionVar9),
    Var10(MOV_instructionVar10),
    Var11(ORL_instructionVar11),
    Var12(PUSH_instructionVar12),
    Var13(PUSH_instructionVar13),
    Var14(SUB_instructionVar14),
    Var15(XRL_instructionVar15),
    Var16(ADD_instructionVar16),
    Var17(ANL_instructionVar17),
    Var18(ANL_instructionVar18),
    Var19(CLR_instructionVar19),
    Var20(CMP_instructionVar20),
    Var21(CMP_instructionVar21),
    Var22(CPL_instructionVar22),
    Var23(ECALL_instructionVar23),
    Var24(EJMP_instructionVar24),
    Var25(MOV_instructionVar25),
    Var26(MOVH_instructionVar26),
    Var27(POP_instructionVar27),
    Var28(PUSH_instructionVar28),
    Var29(SUB_instructionVar29),
    Var30(DEC_instructionVar30),
    Var31(INC_instructionVar31),
    Var32(JB_instructionVar32),
    Var33(JBC_instructionVar33),
    Var34(JNB_instructionVar34),
    Var35(MOV_instructionVar35),
    Var36(MOV_instructionVar36),
    Var37(ORL_instructionVar37),
    Var38(ORL_instructionVar38),
    Var39(SETB_instructionVar39),
    Var40(ADD_instructionVar40),
    Var41(ADD_instructionVar41),
    Var42(ANL_instructionVar42),
    Var43(CMP_instructionVar43),
    Var44(MOV_instructionVar44),
    Var45(MOV_instructionVar45),
    Var46(MOV_instructionVar46),
    Var47(MOV_instructionVar47),
    Var48(MOV_instructionVar48),
    Var49(MOV_instructionVar49),
    Var50(ORL_instructionVar50),
    Var51(SUB_instructionVar51),
    Var52(XRL_instructionVar52),
    Var53(ADD_instructionVar53),
    Var54(ADD_instructionVar54),
    Var55(ADD_instructionVar55),
    Var56(ADD_instructionVar56),
    Var57(ADD_instructionVar57),
    Var58(ADD_instructionVar58),
    Var59(ADD_instructionVar59),
    Var60(ANL_instructionVar60),
    Var61(ANL_instructionVar61),
    Var62(ANL_instructionVar62),
    Var63(ANL_instructionVar63),
    Var64(ANL_instructionVar64),
    Var65(CMP_instructionVar65),
    Var66(CMP_instructionVar66),
    Var67(CMP_instructionVar67),
    Var68(CMP_instructionVar68),
    Var69(CMP_instructionVar69),
    Var70(CMP_instructionVar70),
    Var71(CMP_instructionVar71),
    Var72(LCALL_instructionVar72),
    Var73(LJMP_instructionVar73),
    Var74(MOV_instructionVar74),
    Var75(MOV_instructionVar75),
    Var76(MOV_instructionVar76),
    Var77(MOV_instructionVar77),
    Var78(MOV_instructionVar78),
    Var79(MOV_instructionVar79),
    Var80(MOV_instructionVar80),
    Var81(MOV_instructionVar81),
    Var82(MOV_instructionVar82),
    Var83(MOV_instructionVar83),
    Var84(MOV_instructionVar84),
    Var85(MOV_instructionVar85),
    Var86(MOV_instructionVar86),
    Var87(ORL_instructionVar87),
    Var88(ORL_instructionVar88),
    Var89(ORL_instructionVar89),
    Var90(ORL_instructionVar90),
    Var91(ORL_instructionVar91),
    Var92(ORL_instructionVar92),
    Var93(POP_instructionVar93),
    Var94(POP_instructionVar94),
    Var95(PUSH_instructionVar95),
    Var96(PUSH_instructionVar96),
    Var97(SLL_instructionVar97),
    Var98(SLL_instructionVar98),
    Var99(SRA_instructionVar99),
    Var100(SRA_instructionVar100),
    Var101(SRL_instructionVar101),
    Var102(SRL_instructionVar102),
    Var103(SUB_instructionVar103),
    Var104(SUB_instructionVar104),
    Var105(SUB_instructionVar105),
    Var106(SUB_instructionVar106),
    Var107(SUB_instructionVar107),
    Var108(SUB_instructionVar108),
    Var109(XRL_instructionVar109),
    Var110(XRL_instructionVar110),
    Var111(XRL_instructionVar111),
    Var112(XRL_instructionVar112),
    Var113(XRL_instructionVar113),
    Var114(XRL_instructionVar114),
    Var115(DEC_instructionVar115),
    Var116(DEC_instructionVar116),
    Var117(INC_instructionVar117),
    Var118(INC_instructionVar118),
    Var119(SUB_instructionVar119),
    Var120(MOV_instructionVar120),
    Var121(MOV_instructionVar121),
    Var122(MOV_instructionVar122),
    Var123(MOV_instructionVar123),
    Var124(ANL_instructionVar124),
    Var125(ANL_instructionVar125),
    Var126(ANL_instructionVar126),
    Var127(CLR_instructionVar127),
    Var128(CPL_instructionVar128),
    Var129(CPL_instructionVar129),
    Var130(CPL_instructionVar130),
    Var131(JB_instructionVar131),
    Var132(JBC_instructionVar132),
    Var133(JNB_instructionVar133),
    Var134(MOV_instructionVar134),
    Var135(MOV_instructionVar135),
    Var136(ORL_instructionVar136),
    Var137(ORL_instructionVar137),
    Var138(SETB_instructionVar138),
    Var139(ADD_instructionVar139),
    Var140(ADD_instructionVar140),
    Var141(ANL_instructionVar141),
    Var142(ANL_instructionVar142),
    Var143(CMP_instructionVar143),
    Var144(CMP_instructionVar144),
    Var145(DIV_instructionVar145),
    Var146(DIV_instructionVar146),
    Var147(ECALL_instructionVar147),
    Var148(EJMP_instructionVar148),
    Var149(ERET_instructionVar149),
    Var150(JE_instructionVar150),
    Var151(JG_instructionVar151),
    Var152(JLE_instructionVar152),
    Var153(JNE_instructionVar153),
    Var154(JSG_instructionVar154),
    Var155(JSGE_instructionVar155),
    Var156(JSL_instructionVar156),
    Var157(JSLE_instructionVar157),
    Var158(MOV_instructionVar158),
    Var159(MOV_instructionVar159),
    Var160(MOV_instructionVar160),
    Var161(MOV_instructionVar161),
    Var162(MOV_instructionVar162),
    Var163(MOV_instructionVar163),
    Var164(MOV_instructionVar164),
    Var165(MOVZ_instructionVar165),
    Var166(MOVZ_instructionVar166),
    Var167(MUL_instructionVar167),
    Var168(MUL_instructionVar168),
    Var169(ORL_instructionVar169),
    Var170(ORL_instructionVar170),
    Var171(SUB_instructionVar171),
    Var172(SUB_instructionVar172),
    Var173(XRL_instructionVar173),
    Var174(XRL_instructionVar174),
    Var175(ADD_instructionVar175),
    Var176(ADD_instructionVar176),
    Var177(ADDC_instructionVar177),
    Var178(ADDC_instructionVar178),
    Var179(ANL_instructionVar179),
    Var180(ANL_instructionVar180),
    Var181(ANL_instructionVar181),
    Var182(ANL_instructionVar182),
    Var183(ANL_instructionVar183),
    Var184(CJNE_instructionVar184),
    Var185(CJNE_instructionVar185),
    Var186(CLR_instructionVar186),
    Var187(CLR_instructionVar187),
    Var188(CLR_instructionVar188),
    Var189(CPL_instructionVar189),
    Var190(DA_instructionVar190),
    Var191(DEC_instructionVar191),
    Var192(DEC_instructionVar192),
    Var193(DIV_instructionVar193),
    Var194(DJNZ_instructionVar194),
    Var195(INC_instructionVar195),
    Var196(INC_instructionVar196),
    Var197(INC_instructionVar197),
    Var198(JB_instructionVar198),
    Var199(JBC_instructionVar199),
    Var200(JC_instructionVar200),
    Var201(JMP_instructionVar201),
    Var202(JNB_instructionVar202),
    Var203(JNC_instructionVar203),
    Var204(JNZ_instructionVar204),
    Var205(JZ_instructionVar205),
    Var206(LCALL_instructionVar206),
    Var207(LJMP_instructionVar207),
    Var208(MOV_instructionVar208),
    Var209(MOV_instructionVar209),
    Var210(MOV_instructionVar210),
    Var211(MOV_instructionVar211),
    Var212(MOV_instructionVar212),
    Var213(MOV_instructionVar213),
    Var214(MOV_instructionVar214),
    Var215(MOV_instructionVar215),
    Var216(MOVC_instructionVar216),
    Var217(MOVC_instructionVar217),
    Var218(MOVX_instructionVar218),
    Var219(MOVX_instructionVar219),
    Var220(MUL_instructionVar220),
    Var221(NOP_instructionVar221),
    Var222(ORL_instructionVar222),
    Var223(ORL_instructionVar223),
    Var224(ORL_instructionVar224),
    Var225(ORL_instructionVar225),
    Var226(ORL_instructionVar226),
    Var227(ORL_instructionVar227),
    Var228(POP_instructionVar228),
    Var229(PUSH_instructionVar229),
    Var230(RET_instructionVar230),
    Var231(RETI_instructionVar231),
    Var232(RL_instructionVar232),
    Var233(RLC_instructionVar233),
    Var234(RR_instructionVar234),
    Var235(RRC_instructionVar235),
    Var236(SETB_instructionVar236),
    Var237(SETB_instructionVar237),
    Var238(SJMP_instructionVar238),
    Var239(SUBB_instructionVar239),
    Var240(SUBB_instructionVar240),
    Var241(SWAP_instructionVar241),
    Var242(XCH_instructionVar242),
    Var243(XRL_instructionVar243),
    Var244(XRL_instructionVar244),
    Var245(XRL_instructionVar245),
    Var246(XRL_instructionVar246),
    Var247(ACALL_instructionVar247),
    Var248(ADD_instructionVar248),
    Var249(ADDC_instructionVar249),
    Var250(ANL_instructionVar250),
    Var251(CJNE_instructionVar251),
    Var252(DEC_instructionVar252),
    Var253(INC_instructionVar253),
    Var254(MOV_instructionVar254),
    Var255(MOV_instructionVar255),
    Var256(MOV_instructionVar256),
    Var257(MOV_instructionVar257),
    Var258(MOV_instructionVar258),
    Var259(MOVX_instructionVar259),
    Var260(MOVX_instructionVar260),
    Var261(ORL_instructionVar261),
    Var262(SUBB_instructionVar262),
    Var263(XCH_instructionVar263),
    Var264(XRL_instructionVar264),
    Var265(ADD_instructionVar265),
    Var266(ADDC_instructionVar266),
    Var267(AJMP_instructionVar267),
    Var268(ANL_instructionVar268),
    Var269(CJNE_instructionVar269),
    Var270(DEC_instructionVar270),
    Var271(DJNZ_instructionVar271),
    Var272(INC_instructionVar272),
    Var273(MOV_instructionVar273),
    Var274(MOV_instructionVar274),
    Var275(MOV_instructionVar275),
    Var276(MOV_instructionVar276),
    Var277(MOV_instructionVar277),
    Var278(ORL_instructionVar278),
    Var279(SUBB_instructionVar279),
    Var280(XCH_instructionVar280),
    Var281(XCHD_instructionVar281),
    Var282(XRL_instructionVar282),
}
impl Tableinstruction {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var35(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var36(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var37(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var38(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var39(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var40(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var41(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var42(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var43(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var44(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var45(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var46(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var47(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var48(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var49(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var50(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var51(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var52(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var53(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var54(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var55(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var56(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var57(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var58(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var59(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var60(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var61(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var62(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var63(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var64(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var65(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var66(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var67(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var68(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var69(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var70(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var71(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var72(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var73(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var74(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var75(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var76(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var77(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var78(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var79(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var80(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var81(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var82(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var83(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var84(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var85(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var86(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var87(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var88(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var89(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var90(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var91(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var92(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var93(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var94(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var95(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var96(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var97(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var98(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var99(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var100(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var101(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var102(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var103(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var104(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var105(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var106(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var107(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var108(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var109(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var110(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var111(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var112(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var113(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var114(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var115(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var116(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var117(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var118(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var119(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var120(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var121(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var122(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var123(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var124(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var125(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var126(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var127(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var128(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var129(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var130(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var131(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var132(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var133(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var134(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var135(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var136(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var137(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var138(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var139(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var140(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var141(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var142(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var143(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var144(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var145(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var146(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var147(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var148(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var149(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var150(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var151(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var152(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var153(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var154(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var155(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var156(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var157(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var158(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var159(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var160(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var161(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var162(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var163(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var164(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var165(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var166(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var167(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var168(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var169(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var170(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var171(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var172(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var173(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var174(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var175(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var176(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var177(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var178(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var179(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var180(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var181(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var182(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var183(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var184(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var185(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var186(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var187(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var188(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var189(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var190(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var191(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var192(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var193(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var194(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var195(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var196(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var197(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var198(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var199(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var200(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var201(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var202(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var203(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var204(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var205(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var206(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var207(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var208(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var209(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var210(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var211(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var212(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var213(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var214(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var215(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var216(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var217(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var218(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var219(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var220(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var221(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var222(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var223(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var224(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var225(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var226(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var227(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var228(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var229(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var230(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var231(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var232(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var233(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var234(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var235(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var236(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var237(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var238(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var239(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var240(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var241(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var242(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var243(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var244(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var245(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var246(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var247(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var248(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var249(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var250(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var251(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var252(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var253(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var254(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var255(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var256(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var257(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var258(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var259(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var260(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var261(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var262(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var263(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var264(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var265(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var266(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var267(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var268(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var269(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var270(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var271(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var272(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var273(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var274(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var275(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var276(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var277(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var278(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var279(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var280(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var281(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var282(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 1 == 0 && (tokens_param[0] & 255) == 165 {
            if let Some((inst_len, parsed)) =
                instructionVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 1 == 0 {
            if let Some((inst_len, parsed)) =
                instructionVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 46
            && (tokens_param[1] & 15) == 11
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 94
            && (tokens_param[1] & 15) == 11
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 190
            && (tokens_param[1] & 15) == 11
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 126
            && (tokens_param[1] & 15) == 11
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 11
            && (tokens_param[1] & 15) == 10
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 122
            && (tokens_param[1] & 15) == 13
            && (tokens_param[2] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 122
            && (tokens_param[1] & 15) == 13
            && (tokens_param[2] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 122
            && (tokens_param[1] & 15) == 11
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 27
            && (tokens_param[1] & 15) == 10
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 15) == 11
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 202 && (tokens_param[1] & 255) == 2
        {
            if let Some((inst_len, parsed)) =
                PUSH_instructionVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 202 && (tokens_param[1] & 255) == 6
        {
            if let Some((inst_len, parsed)) =
                PUSH_instructionVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 158
            && (tokens_param[1] & 15) == 11
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 110
            && (tokens_param[1] & 15) == 11
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 46 && (tokens_param[1] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 169
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 169
            && (tokens_param[1] & 248) == 240
        {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 169
            && (tokens_param[1] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                CLR_instructionVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 190 && (tokens_param[1] & 15) == 8
        {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 190 && (tokens_param[1] & 15) == 12
        {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 169
            && (tokens_param[1] & 248) == 176
        {
            if let Some((inst_len, parsed)) =
                CPL_instructionVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 153 && (tokens_param[1] & 15) == 8
        {
            if let Some((inst_len, parsed)) =
                ECALL_instructionVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 137 && (tokens_param[1] & 15) == 8
        {
            if let Some((inst_len, parsed)) =
                EJMP_instructionVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 122 && (tokens_param[1] & 15) == 15
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 126 && (tokens_param[1] & 15) == 12
        {
            if let Some((inst_len, parsed)) =
                MOVH_instructionVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 218 && (tokens_param[1] & 15) == 11
        {
            if let Some((inst_len, parsed)) =
                POP_instructionVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 202 && (tokens_param[1] & 15) == 11
        {
            if let Some((inst_len, parsed)) =
                PUSH_instructionVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 158 && (tokens_param[1] & 15) == 8
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 27 && (tokens_param[1] & 12) == 12
        {
            if let Some((inst_len, parsed)) =
                DEC_instructionVar30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 11 && (tokens_param[1] & 12) == 12
        {
            if let Some((inst_len, parsed)) =
                INC_instructionVar31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 169
            && (tokens_param[1] & 248) == 32
        {
            if let Some((inst_len, parsed)) =
                JB_instructionVar32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 169
            && (tokens_param[1] & 248) == 16
        {
            if let Some((inst_len, parsed)) =
                JBC_instructionVar33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 169
            && (tokens_param[1] & 248) == 48
        {
            if let Some((inst_len, parsed)) =
                JNB_instructionVar34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 169
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar35::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var35(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 169
            && (tokens_param[1] & 248) == 160
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar36::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var36(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 169
            && (tokens_param[1] & 248) == 112
        {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar37::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var37(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 169
            && (tokens_param[1] & 248) == 224
        {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar38::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var38(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 169
            && (tokens_param[1] & 248) == 208
        {
            if let Some((inst_len, parsed)) =
                SETB_instructionVar39::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var39(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 47 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar40::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var40(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 46
            && (tokens_param[1] & 15) == 9
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar41::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var41(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 94
            && (tokens_param[1] & 15) == 9
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar42::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var42(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 190
            && (tokens_param[1] & 15) == 9
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar43::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var43(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 126
            && (tokens_param[1] & 15) == 9
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar44::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var44(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 11
            && (tokens_param[1] & 15) == 8
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar45::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var45(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 122
            && (tokens_param[1] & 15) == 5
            && (tokens_param[2] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar46::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var46(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 122
            && (tokens_param[1] & 15) == 5
            && (tokens_param[2] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar47::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var47(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 122
            && (tokens_param[1] & 15) == 9
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar48::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var48(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 27
            && (tokens_param[1] & 15) == 8
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar49::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var49(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 15) == 9
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar50::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var50(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 158
            && (tokens_param[1] & 15) == 9
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar51::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var51(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 110
            && (tokens_param[1] & 15) == 9
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar52::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var52(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 46 && (tokens_param[1] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar53::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var53(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 46 && (tokens_param[1] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar54::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var54(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 46 && (tokens_param[1] & 15) == 1 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar55::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var55(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 46 && (tokens_param[1] & 15) == 5 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar56::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var56(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 46 && (tokens_param[1] & 15) == 3 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar57::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var57(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 46 && (tokens_param[1] & 15) == 7 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar58::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var58(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 94 && (tokens_param[1] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar59::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var59(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 94 && (tokens_param[1] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar60::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var60(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 94 && (tokens_param[1] & 15) == 1 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar61::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var61(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 94 && (tokens_param[1] & 15) == 5 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar62::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var62(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 94 && (tokens_param[1] & 15) == 3 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar63::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var63(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 94 && (tokens_param[1] & 15) == 7 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar64::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var64(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 191 {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar65::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var65(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 190 && (tokens_param[1] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar66::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var66(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 190 && (tokens_param[1] & 15) == 4
        {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar67::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var67(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 190 && (tokens_param[1] & 15) == 1
        {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar68::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var68(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 190 && (tokens_param[1] & 15) == 5
        {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar69::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var69(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 190 && (tokens_param[1] & 15) == 3
        {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar70::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var70(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 190 && (tokens_param[1] & 15) == 7
        {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar71::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var71(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 153 && (tokens_param[1] & 15) == 4
        {
            if let Some((inst_len, parsed)) =
                LCALL_instructionVar72::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var72(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 137 && (tokens_param[1] & 15) == 4
        {
            if let Some((inst_len, parsed)) =
                LJMP_instructionVar73::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var73(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 126 && (tokens_param[1] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar74::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var74(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 126 && (tokens_param[1] & 15) == 4
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar75::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var75(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 126 && (tokens_param[1] & 15) == 8
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar76::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var76(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 126 && (tokens_param[1] & 15) == 12
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar77::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var77(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 126 && (tokens_param[1] & 15) == 1
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar78::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var78(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 126 && (tokens_param[1] & 15) == 5
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar79::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var79(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 126 && (tokens_param[1] & 15) == 13
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar80::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var80(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 126 && (tokens_param[1] & 15) == 3
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar81::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var81(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 126 && (tokens_param[1] & 15) == 7
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar82::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var82(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 126 && (tokens_param[1] & 15) == 15
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar83::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var83(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 122 && (tokens_param[1] & 15) == 1
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar84::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var84(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 122 && (tokens_param[1] & 15) == 3
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar85::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var85(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 122 && (tokens_param[1] & 15) == 7
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar86::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var86(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 78 && (tokens_param[1] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar87::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var87(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 78 && (tokens_param[1] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar88::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var88(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 78 && (tokens_param[1] & 15) == 1 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar89::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var89(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 79 && (tokens_param[1] & 15) == 5 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar90::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var90(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 78 && (tokens_param[1] & 15) == 3 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar91::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var91(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 78 && (tokens_param[1] & 15) == 7 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar92::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var92(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 218 && (tokens_param[1] & 15) == 8
        {
            if let Some((inst_len, parsed)) =
                POP_instructionVar93::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var93(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 218 && (tokens_param[1] & 15) == 9
        {
            if let Some((inst_len, parsed)) =
                POP_instructionVar94::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var94(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 202 && (tokens_param[1] & 15) == 8
        {
            if let Some((inst_len, parsed)) =
                PUSH_instructionVar95::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var95(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 202 && (tokens_param[1] & 15) == 9
        {
            if let Some((inst_len, parsed)) =
                PUSH_instructionVar96::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var96(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 62 && (tokens_param[1] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                SLL_instructionVar97::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var97(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 62 && (tokens_param[1] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                SLL_instructionVar98::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var98(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 14 && (tokens_param[1] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                SRA_instructionVar99::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var99(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 14 && (tokens_param[1] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                SRA_instructionVar100::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var100(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 30 && (tokens_param[1] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                SRL_instructionVar101::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var101(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 30 && (tokens_param[1] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                SRL_instructionVar102::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var102(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 158 && (tokens_param[1] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar103::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var103(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 158 && (tokens_param[1] & 15) == 4
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar104::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var104(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 158 && (tokens_param[1] & 15) == 1
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar105::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var105(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 158 && (tokens_param[1] & 15) == 5
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar106::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var106(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 158 && (tokens_param[1] & 15) == 3
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar107::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var107(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 158 && (tokens_param[1] & 15) == 7
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar108::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var108(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 110 && (tokens_param[1] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar109::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var109(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 110 && (tokens_param[1] & 15) == 4
        {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar110::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var110(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 110 && (tokens_param[1] & 15) == 1
        {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar111::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var111(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 110 && (tokens_param[1] & 15) == 5
        {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar112::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var112(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 110 && (tokens_param[1] & 15) == 3
        {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar113::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var113(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 110 && (tokens_param[1] & 15) == 7
        {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar114::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var114(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 27 && (tokens_param[1] & 12) == 0 {
            if let Some((inst_len, parsed)) =
                DEC_instructionVar115::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var115(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 27 && (tokens_param[1] & 12) == 4 {
            if let Some((inst_len, parsed)) =
                DEC_instructionVar116::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var116(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 11 && (tokens_param[1] & 12) == 0 {
            if let Some((inst_len, parsed)) =
                INC_instructionVar117::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var117(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 11 && (tokens_param[1] & 12) == 4 {
            if let Some((inst_len, parsed)) =
                INC_instructionVar118::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var118(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 159 {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar119::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var119(parsed)));
            }
        }
        if tokens_param.len() >= 5 && (tokens_param[0] & 255) == 41 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar120::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var120(parsed)));
            }
        }
        if tokens_param.len() >= 5 && (tokens_param[0] & 255) == 105 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar121::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var121(parsed)));
            }
        }
        if tokens_param.len() >= 5 && (tokens_param[0] & 255) == 57 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar122::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var122(parsed)));
            }
        }
        if tokens_param.len() >= 5 && (tokens_param[0] & 255) == 121 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar123::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var123(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 84 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar124::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var124(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && (tokens_param[0] & 255) == 130
            && (tokens_param[1] & 232) == 224
        {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar125::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var125(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && (tokens_param[0] & 255) == 176
            && (tokens_param[1] & 232) == 224
        {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar126::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var126(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && (tokens_param[0] & 255) == 194
            && (tokens_param[1] & 232) == 224
        {
            if let Some((inst_len, parsed)) =
                CLR_instructionVar127::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var127(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 244 {
            if let Some((inst_len, parsed)) =
                CPL_instructionVar128::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var128(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 179 {
            if let Some((inst_len, parsed)) =
                CPL_instructionVar129::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var129(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && (tokens_param[0] & 255) == 178
            && (tokens_param[1] & 232) == 224
        {
            if let Some((inst_len, parsed)) =
                CPL_instructionVar130::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var130(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 232) == 224
        {
            if let Some((inst_len, parsed)) =
                JB_instructionVar131::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var131(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 232) == 224
        {
            if let Some((inst_len, parsed)) =
                JBC_instructionVar132::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var132(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 232) == 224
        {
            if let Some((inst_len, parsed)) =
                JNB_instructionVar133::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var133(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && (tokens_param[0] & 255) == 162
            && (tokens_param[1] & 232) == 224
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar134::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var134(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && (tokens_param[0] & 255) == 146
            && (tokens_param[1] & 232) == 224
        {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar135::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var135(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && (tokens_param[0] & 255) == 114
            && (tokens_param[1] & 232) == 224
        {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar136::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var136(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && (tokens_param[0] & 255) == 160
            && (tokens_param[1] & 232) == 224
        {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar137::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var137(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && (tokens_param[0] & 255) == 210
            && (tokens_param[1] & 232) == 224
        {
            if let Some((inst_len, parsed)) =
                SETB_instructionVar138::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var138(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 44 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar139::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var139(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 45 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar140::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var140(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 92 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar141::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var141(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 93 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar142::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var142(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 188 {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar143::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var143(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 189 {
            if let Some((inst_len, parsed)) =
                CMP_instructionVar144::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var144(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 140 {
            if let Some((inst_len, parsed)) =
                DIV_instructionVar145::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var145(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 141 {
            if let Some((inst_len, parsed)) =
                DIV_instructionVar146::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var146(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 154 {
            if let Some((inst_len, parsed)) =
                ECALL_instructionVar147::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var147(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 138 {
            if let Some((inst_len, parsed)) =
                EJMP_instructionVar148::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var148(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 170 {
            if let Some((inst_len, parsed)) =
                ERET_instructionVar149::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var149(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 104 {
            if let Some((inst_len, parsed)) =
                JE_instructionVar150::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var150(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 56 {
            if let Some((inst_len, parsed)) =
                JG_instructionVar151::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var151(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 40 {
            if let Some((inst_len, parsed)) =
                JLE_instructionVar152::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var152(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 120 {
            if let Some((inst_len, parsed)) =
                JNE_instructionVar153::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var153(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 24 {
            if let Some((inst_len, parsed)) =
                JSG_instructionVar154::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var154(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 88 {
            if let Some((inst_len, parsed)) =
                JSGE_instructionVar155::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var155(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 72 {
            if let Some((inst_len, parsed)) =
                JSL_instructionVar156::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var156(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 8 {
            if let Some((inst_len, parsed)) =
                JSLE_instructionVar157::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var157(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 124 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar158::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var158(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 125 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar159::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var159(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 127 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar160::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var160(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 9 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar161::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var161(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 73 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar162::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var162(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 25 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar163::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var163(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 89 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar164::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var164(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 26 {
            if let Some((inst_len, parsed)) =
                MOVZ_instructionVar165::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var165(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 10 {
            if let Some((inst_len, parsed)) =
                MOVZ_instructionVar166::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var166(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 172 {
            if let Some((inst_len, parsed)) =
                MUL_instructionVar167::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var167(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 173 {
            if let Some((inst_len, parsed)) =
                MUL_instructionVar168::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var168(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 76 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar169::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var169(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 77 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar170::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var170(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 156 {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar171::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var171(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 157 {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar172::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var172(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 108 {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar173::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var173(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 109 {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar174::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var174(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 37 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar175::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var175(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 36 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar176::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var176(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 53 {
            if let Some((inst_len, parsed)) =
                ADDC_instructionVar177::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var177(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 52 {
            if let Some((inst_len, parsed)) =
                ADDC_instructionVar178::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var178(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 85 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar179::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var179(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 82 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar180::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var180(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 83 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar181::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var181(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 130 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar182::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var182(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 176 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar183::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var183(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 181 {
            if let Some((inst_len, parsed)) =
                CJNE_instructionVar184::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var184(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 180 {
            if let Some((inst_len, parsed)) =
                CJNE_instructionVar185::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var185(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 228 {
            if let Some((inst_len, parsed)) =
                CLR_instructionVar186::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var186(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 195 {
            if let Some((inst_len, parsed)) =
                CLR_instructionVar187::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var187(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 194 {
            if let Some((inst_len, parsed)) =
                CLR_instructionVar188::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var188(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 178 {
            if let Some((inst_len, parsed)) =
                CPL_instructionVar189::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var189(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 212 {
            if let Some((inst_len, parsed)) =
                DA_instructionVar190::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var190(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 20 {
            if let Some((inst_len, parsed)) =
                DEC_instructionVar191::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var191(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 21 {
            if let Some((inst_len, parsed)) =
                DEC_instructionVar192::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var192(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 132 {
            if let Some((inst_len, parsed)) =
                DIV_instructionVar193::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var193(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 213 {
            if let Some((inst_len, parsed)) =
                DJNZ_instructionVar194::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var194(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 4 {
            if let Some((inst_len, parsed)) =
                INC_instructionVar195::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var195(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 5 {
            if let Some((inst_len, parsed)) =
                INC_instructionVar196::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var196(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 163 {
            if let Some((inst_len, parsed)) =
                INC_instructionVar197::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var197(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 32 {
            if let Some((inst_len, parsed)) =
                JB_instructionVar198::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var198(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 16 {
            if let Some((inst_len, parsed)) =
                JBC_instructionVar199::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var199(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 64 {
            if let Some((inst_len, parsed)) =
                JC_instructionVar200::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var200(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 115 {
            if let Some((inst_len, parsed)) =
                JMP_instructionVar201::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var201(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 48 {
            if let Some((inst_len, parsed)) =
                JNB_instructionVar202::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var202(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 80 {
            if let Some((inst_len, parsed)) =
                JNC_instructionVar203::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var203(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 112 {
            if let Some((inst_len, parsed)) =
                JNZ_instructionVar204::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var204(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 96 {
            if let Some((inst_len, parsed)) =
                JZ_instructionVar205::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var205(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 18 {
            if let Some((inst_len, parsed)) =
                LCALL_instructionVar206::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var206(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 2 {
            if let Some((inst_len, parsed)) =
                LJMP_instructionVar207::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var207(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 229 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar208::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var208(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 116 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar209::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var209(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 245 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar210::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var210(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 133 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar211::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var211(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 117 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar212::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var212(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 144 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar213::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var213(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 162 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar214::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var214(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 146 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar215::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var215(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 147 {
            if let Some((inst_len, parsed)) =
                MOVC_instructionVar216::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var216(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 131 {
            if let Some((inst_len, parsed)) =
                MOVC_instructionVar217::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var217(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 224 {
            if let Some((inst_len, parsed)) =
                MOVX_instructionVar218::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var218(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 240 {
            if let Some((inst_len, parsed)) =
                MOVX_instructionVar219::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var219(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 164 {
            if let Some((inst_len, parsed)) =
                MUL_instructionVar220::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var220(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                NOP_instructionVar221::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var221(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 69 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar222::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var222(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 68 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar223::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var223(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 66 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar224::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var224(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 67 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar225::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var225(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 114 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar226::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var226(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 160 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar227::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var227(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 208 {
            if let Some((inst_len, parsed)) =
                POP_instructionVar228::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var228(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 192 {
            if let Some((inst_len, parsed)) =
                PUSH_instructionVar229::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var229(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 34 {
            if let Some((inst_len, parsed)) =
                RET_instructionVar230::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var230(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 50 {
            if let Some((inst_len, parsed)) =
                RETI_instructionVar231::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var231(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 35 {
            if let Some((inst_len, parsed)) =
                RL_instructionVar232::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var232(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 51 {
            if let Some((inst_len, parsed)) =
                RLC_instructionVar233::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var233(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 3 {
            if let Some((inst_len, parsed)) =
                RR_instructionVar234::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var234(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 19 {
            if let Some((inst_len, parsed)) =
                RRC_instructionVar235::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var235(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 211 {
            if let Some((inst_len, parsed)) =
                SETB_instructionVar236::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var236(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 210 {
            if let Some((inst_len, parsed)) =
                SETB_instructionVar237::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var237(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 128 {
            if let Some((inst_len, parsed)) =
                SJMP_instructionVar238::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var238(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 149 {
            if let Some((inst_len, parsed)) =
                SUBB_instructionVar239::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var239(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 148 {
            if let Some((inst_len, parsed)) =
                SUBB_instructionVar240::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var240(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 196 {
            if let Some((inst_len, parsed)) =
                SWAP_instructionVar241::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var241(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 197 {
            if let Some((inst_len, parsed)) =
                XCH_instructionVar242::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var242(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 101 {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar243::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var243(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 100 {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar244::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var244(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 98 {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar245::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var245(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 99 {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar246::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var246(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 31) == 17 {
            if let Some((inst_len, parsed)) =
                ACALL_instructionVar247::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var247(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 38 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar248::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var248(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 54 {
            if let Some((inst_len, parsed)) =
                ADDC_instructionVar249::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var249(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 86 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar250::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var250(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 254) == 182 {
            if let Some((inst_len, parsed)) =
                CJNE_instructionVar251::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var251(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 22 {
            if let Some((inst_len, parsed)) =
                DEC_instructionVar252::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var252(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 6 {
            if let Some((inst_len, parsed)) =
                INC_instructionVar253::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var253(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 230 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar254::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var254(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 254) == 134 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar255::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var255(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 246 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar256::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var256(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 254) == 166 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar257::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var257(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 254) == 118 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar258::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var258(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 226 {
            if let Some((inst_len, parsed)) =
                MOVX_instructionVar259::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var259(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 242 {
            if let Some((inst_len, parsed)) =
                MOVX_instructionVar260::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var260(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 70 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar261::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var261(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 150 {
            if let Some((inst_len, parsed)) =
                SUBB_instructionVar262::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var262(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 198 {
            if let Some((inst_len, parsed)) =
                XCH_instructionVar263::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var263(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 102 {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar264::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var264(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 40 {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar265::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var265(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 56 {
            if let Some((inst_len, parsed)) =
                ADDC_instructionVar266::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var266(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 31) == 1 {
            if let Some((inst_len, parsed)) =
                AJMP_instructionVar267::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var267(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 88 {
            if let Some((inst_len, parsed)) =
                ANL_instructionVar268::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var268(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 248) == 184 {
            if let Some((inst_len, parsed)) =
                CJNE_instructionVar269::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var269(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 24 {
            if let Some((inst_len, parsed)) =
                DEC_instructionVar270::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var270(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 248) == 216 {
            if let Some((inst_len, parsed)) =
                DJNZ_instructionVar271::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var271(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                INC_instructionVar272::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var272(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 232 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar273::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var273(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 248 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar274::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var274(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 248) == 168 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar275::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var275(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 248) == 120 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar276::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var276(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 248) == 136 {
            if let Some((inst_len, parsed)) =
                MOV_instructionVar277::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var277(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 72 {
            if let Some((inst_len, parsed)) =
                ORL_instructionVar278::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var278(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 152 {
            if let Some((inst_len, parsed)) =
                SUBB_instructionVar279::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var279(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 200 {
            if let Some((inst_len, parsed)) =
                XCH_instructionVar280::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var280(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 214 {
            if let Some((inst_len, parsed)) =
                XCHD_instructionVar281::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var281(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 104 {
            if let Some((inst_len, parsed)) =
                XRL_instructionVar282::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var282(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:507:1, end:507:3))"]
#[derive(Clone, Debug)]
struct CYVar0 {}
impl CYVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("CY")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCY {
    Var0(CYVar0),
}
impl TableCY {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                CYVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:509:1, end:509:5))"]
#[derive(Clone, Debug)]
struct AregVar0 {}
impl AregVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("A")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let ophi = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableAreg {
    Var0(AregVar0),
}
impl TableAreg {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                AregVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:510:1, end:510:6))"]
#[derive(Clone, Debug)]
struct ABregVar0 {}
impl ABregVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::AB)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let ophi = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableABreg {
    Var0(ABregVar0),
}
impl TableABreg {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                ABregVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:511:1, end:511:8))"]
#[derive(Clone, Debug)]
struct DPTRregVar0 {}
impl DPTRregVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::DPTR)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let ophi = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableDPTRreg {
    Var0(DPTRregVar0),
}
impl TableDPTRreg {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                DPTRregVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:514:1, end:514:6))"]
#[derive(Clone, Debug)]
struct ADPTRVar0 {}
impl ADPTRVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("@A+"),
            <DisplayElement>::Register(Register::DPTR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let ophi = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableADPTR {
    Var0(ADPTRVar0),
}
impl TableADPTR {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                ADPTRVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:523:1, end:523:4))"]
#[derive(Clone, Debug)]
struct APCVar0 {}
impl APCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("@A+PC")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableAPC {
    Var0(APCVar0),
}
impl TableAPC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                APCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:526:1, end:526:7))"]
#[derive(Clone, Debug)]
struct ATDPTRVar0 {}
impl ATDPTRVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("@"),
            <DisplayElement>::Register(Register::DPTR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let ophi = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableATDPTR {
    Var0(ATDPTRVar0),
}
impl TableATDPTR {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                ATDPTRVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:536:1, end:536:3))"]
#[derive(Clone, Debug)]
struct RiVar0 {
    ri: u8,
}
impl RiVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal("@"), meaning_1_display(self.ri)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let ri = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ri }))
    }
}
#[derive(Clone, Debug)]
enum TableRi {
    Var0(RiVar0),
}
impl TableRi {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                RiVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:544:1, end:544:4))"]
#[derive(Clone, Debug)]
struct RiXVar0 {
    ri: u8,
}
impl RiXVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal("@"), meaning_1_display(self.ri)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let ri = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ri }))
    }
}
#[derive(Clone, Debug)]
enum TableRiX {
    Var0(RiXVar0),
}
impl TableRiX {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                RiXVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:553:1, end:553:5))"]
#[derive(Clone, Debug)]
struct DataVar0 {
    data: u8,
}
impl DataVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.data as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let data = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { data }))
    }
}
#[derive(Clone, Debug)]
enum TableData {
    Var0(DataVar0),
}
impl TableData {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                DataVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:554:1, end:554:7))"]
#[derive(Clone, Debug)]
struct Data16Var0 {
    data16: u16,
}
impl Data16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.data16 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let data16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableData16 {
    Var0(Data16Var0),
}
impl TableData16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Data16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:567:1, end:567:7))"]
#[derive(Clone, Debug)]
struct DirectVar0 {}
impl DirectVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::PSW)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:568:1, end:568:7))"]
#[derive(Clone, Debug)]
struct DirectVar1 {}
impl DirectVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("A")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:569:1, end:569:7))"]
#[derive(Clone, Debug)]
struct DirectVar2 {}
impl DirectVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:570:1, end:570:7))"]
#[derive(Clone, Debug)]
struct DirectVar3 {}
impl DirectVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::DPL)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:571:1, end:571:7))"]
#[derive(Clone, Debug)]
struct DirectVar4 {}
impl DirectVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::DPH)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:576:1, end:576:7))"]
#[derive(Clone, Debug)]
struct DirectVar5 {}
impl DirectVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::DPXL)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:560:1, end:560:7))"]
#[derive(Clone, Debug)]
struct DirectVar6 {
    mainreg: u8,
}
impl DirectVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.mainreg as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mainreg = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mainreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:566:1, end:566:7))"]
#[derive(Clone, Debug)]
struct DirectVar7 {
    direct: u8,
}
impl DirectVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.direct as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let direct = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { direct }))
    }
}
#[derive(Clone, Debug)]
enum TableDirect {
    Var0(DirectVar0),
    Var1(DirectVar1),
    Var2(DirectVar2),
    Var3(DirectVar3),
    Var4(DirectVar4),
    Var5(DirectVar5),
    Var6(DirectVar6),
    Var7(DirectVar7),
}
impl TableDirect {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 208 {
            if let Some((inst_len, parsed)) =
                DirectVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 224 {
            if let Some((inst_len, parsed)) =
                DirectVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 240 {
            if let Some((inst_len, parsed)) =
                DirectVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 130 {
            if let Some((inst_len, parsed)) =
                DirectVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 131 {
            if let Some((inst_len, parsed)) =
                DirectVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 132 {
            if let Some((inst_len, parsed)) =
                DirectVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                DirectVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                DirectVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:587:1, end:587:8))"]
#[derive(Clone, Debug)]
struct Direct2Var0 {}
impl Direct2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::PSW)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:588:1, end:588:8))"]
#[derive(Clone, Debug)]
struct Direct2Var1 {}
impl Direct2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("A")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:589:1, end:589:8))"]
#[derive(Clone, Debug)]
struct Direct2Var2 {}
impl Direct2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:590:1, end:590:8))"]
#[derive(Clone, Debug)]
struct Direct2Var3 {}
impl Direct2Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::DPL)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:591:1, end:591:8))"]
#[derive(Clone, Debug)]
struct Direct2Var4 {}
impl Direct2Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::DPH)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:596:1, end:596:8))"]
#[derive(Clone, Debug)]
struct Direct2Var5 {}
impl Direct2Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::DPXL)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:580:1, end:580:8))"]
#[derive(Clone, Debug)]
struct Direct2Var6 {
    mainreg2: u8,
}
impl Direct2Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.mainreg2 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mainreg2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mainreg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:586:1, end:586:8))"]
#[derive(Clone, Debug)]
struct Direct2Var7 {
    direct2: u8,
}
impl Direct2Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.direct2 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let direct2 = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { direct2 }))
    }
}
#[derive(Clone, Debug)]
enum TableDirect2 {
    Var0(Direct2Var0),
    Var1(Direct2Var1),
    Var2(Direct2Var2),
    Var3(Direct2Var3),
    Var4(Direct2Var4),
    Var5(Direct2Var5),
    Var6(Direct2Var6),
    Var7(Direct2Var7),
}
impl TableDirect2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 208 {
            if let Some((inst_len, parsed)) =
                Direct2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 224 {
            if let Some((inst_len, parsed)) =
                Direct2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 240 {
            if let Some((inst_len, parsed)) =
                Direct2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 130 {
            if let Some((inst_len, parsed)) =
                Direct2Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 131 {
            if let Some((inst_len, parsed)) =
                Direct2Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 132 {
            if let Some((inst_len, parsed)) =
                Direct2Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                Direct2Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                Direct2Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:600:1, end:600:8))"]
#[derive(Clone, Debug)]
struct BitAddrVar0 {
    sfrbyte: u8,
    sfrbit: u8,
}
impl BitAddrVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_bitaddr: i128 = 0;
        calc_bitaddr = u32::try_from(6i128)
            .ok()
            .and_then(|shl| i128::try_from(self.sfrbyte).unwrap().checked_shl(shl))
            .unwrap_or(0)
            .wrapping_add(i128::try_from(self.sfrbit).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_bitaddr.is_negative(),
            calc_bitaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_bitaddr: i128 = 0;
        let mut block_0_len = 1;
        calc_bitaddr = u32::try_from(6i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_15(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            .wrapping_add(i128::try_from(token_4(tokens_current)).unwrap());
        let sfrbyte = token_15(tokens_current);
        let sfrbit = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sfrbyte, sfrbit }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:601:1, end:601:8))"]
#[derive(Clone, Debug)]
struct BitAddrVar1 {
    lowbyte: u8,
    sfrbit: u8,
}
impl BitAddrVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_bitaddr: i128 = 0;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .and_then(|shl| i128::try_from(self.lowbyte).unwrap().checked_shl(shl))
            .unwrap_or(0)
            .wrapping_add(i128::try_from(self.sfrbit).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_bitaddr.is_negative(),
            calc_bitaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_bitaddr: i128 = 0;
        let mut block_0_len = 1;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_20(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            .wrapping_add(i128::try_from(token_4(tokens_current)).unwrap());
        let sfrbit = token_4(tokens_current);
        let lowbyte = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lowbyte, sfrbit }))
    }
}
#[derive(Clone, Debug)]
enum TableBitAddr {
    Var0(BitAddrVar0),
    Var1(BitAddrVar1),
}
impl TableBitAddr {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                BitAddrVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                BitAddrVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:602:1, end:602:9))"]
#[derive(Clone, Debug)]
struct BitAddr2Var0 {
    sfrbyte: u8,
    sfrbit: u8,
}
impl BitAddr2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_bitaddr: i128 = 0;
        calc_bitaddr = u32::try_from(6i128)
            .ok()
            .and_then(|shl| i128::try_from(self.sfrbyte).unwrap().checked_shl(shl))
            .unwrap_or(0)
            .wrapping_add(i128::try_from(self.sfrbit).unwrap());
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("/"),
            <DisplayElement>::Number(true, calc_bitaddr.is_negative(), calc_bitaddr.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_bitaddr: i128 = 0;
        let mut block_0_len = 1;
        calc_bitaddr = u32::try_from(6i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_15(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            .wrapping_add(i128::try_from(token_4(tokens_current)).unwrap());
        let sfrbit = token_4(tokens_current);
        let sfrbyte = token_15(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sfrbyte, sfrbit }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:603:1, end:603:9))"]
#[derive(Clone, Debug)]
struct BitAddr2Var1 {
    lowbyte: u8,
    sfrbit: u8,
}
impl BitAddr2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_bitaddr: i128 = 0;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .and_then(|shl| i128::try_from(self.lowbyte).unwrap().checked_shl(shl))
            .unwrap_or(0)
            .wrapping_add(i128::try_from(self.sfrbit).unwrap());
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("/"),
            <DisplayElement>::Number(true, calc_bitaddr.is_negative(), calc_bitaddr.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_bitaddr: i128 = 0;
        let mut block_0_len = 1;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_20(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            .wrapping_add(i128::try_from(token_4(tokens_current)).unwrap());
        let lowbyte = token_20(tokens_current);
        let sfrbit = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lowbyte, sfrbit }))
    }
}
#[derive(Clone, Debug)]
enum TableBitAddr2 {
    Var0(BitAddr2Var0),
    Var1(BitAddr2Var1),
}
impl TableBitAddr2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                BitAddr2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                BitAddr2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:618:1, end:618:12))"]
#[derive(Clone, Debug)]
struct BitByteAddrVar0 {}
impl BitByteAddrVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("A")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let sfrbit = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:619:1, end:619:12))"]
#[derive(Clone, Debug)]
struct BitByteAddrVar1 {}
impl BitByteAddrVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let sfrbit = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:620:1, end:620:12))"]
#[derive(Clone, Debug)]
struct BitByteAddrVar2 {}
impl BitByteAddrVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::PSW)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let sfrbit = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:617:1, end:617:12))"]
#[derive(Clone, Debug)]
struct BitByteAddrVar3 {
    sfrbyte: u8,
}
impl BitByteAddrVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_byteaddr: i128 = 0;
        calc_byteaddr = u32::try_from(3i128)
            .ok()
            .and_then(|shl| i128::try_from(self.sfrbyte).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_byteaddr.is_negative(),
            calc_byteaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_byteaddr: i128 = 0;
        let mut block_0_len = 1;
        calc_byteaddr = u32::try_from(3i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_15(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let sfrbit = token_4(tokens_current);
        let sfrbyte = token_15(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sfrbyte }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:622:1, end:622:12))"]
#[derive(Clone, Debug)]
struct BitByteAddrVar4 {
    lowbyte: u8,
}
impl BitByteAddrVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_byteaddr: i128 = 0;
        calc_byteaddr = i128::try_from(self.lowbyte).unwrap().wrapping_add(32i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_byteaddr.is_negative(),
            calc_byteaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_byteaddr: i128 = 0;
        let mut block_0_len = 1;
        calc_byteaddr = i128::try_from(token_20(tokens_current))
            .unwrap()
            .wrapping_add(32i128);
        let lowbyte = token_20(tokens_current);
        let sfrbit = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lowbyte }))
    }
}
#[derive(Clone, Debug)]
enum TableBitByteAddr {
    Var0(BitByteAddrVar0),
    Var1(BitByteAddrVar1),
    Var2(BitByteAddrVar2),
    Var3(BitByteAddrVar3),
    Var4(BitByteAddrVar4),
}
impl TableBitByteAddr {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 224 {
            if let Some((inst_len, parsed)) =
                BitByteAddrVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 240 {
            if let Some((inst_len, parsed)) =
                BitByteAddrVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 248) == 208 {
            if let Some((inst_len, parsed)) =
                BitByteAddrVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                BitByteAddrVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                BitByteAddrVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:630:1, end:630:7))"]
#[derive(Clone, Debug)]
struct Addr11Var0 {
    aopaddr: u8,
    adata: u8,
}
impl Addr11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_relAddr: i128 = 0;
        calc_relAddr = (i128::try_from(inst_next).unwrap() & 16775168i128)
            .wrapping_add(i128::try_from(self.aopaddr).unwrap().wrapping_mul(256i128))
            .wrapping_add(i128::try_from(self.adata).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_relAddr.is_negative(),
            calc_relAddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_relAddr: i128 = 0;
        let mut block_0_len = 2;
        let aopaddr = token_23(tokens_current);
        let adata = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { aopaddr, adata }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr11 {
    Var0(Addr11Var0),
}
impl TableAddr11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Addr11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:631:1, end:631:7))"]
#[derive(Clone, Debug)]
struct Addr16Var0 {
    addr16: u16,
}
impl Addr16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_addr: i128 = 0;
        calc_addr = (i128::try_from(inst_next).unwrap() & 16711680i128)
            .wrapping_add(i128::try_from(self.addr16).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_addr.is_negative(),
            calc_addr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_addr: i128 = 0;
        let mut block_0_len = 2;
        let addr16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr16 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr16 {
    Var0(Addr16Var0),
}
impl TableAddr16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Addr16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:640:1, end:640:5))"]
#[derive(Clone, Debug)]
struct Rel8Var0 {
    rel8: u8,
}
impl Rel8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_relAddr: i128 = 0;
        calc_relAddr = i128::try_from(inst_next).unwrap().wrapping_add(
            i128::try_from((if self.rel8 & 128 != 0 { -1 & !127 } else { 0 } | self.rel8 as i8))
                .unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_relAddr.is_negative(),
            calc_relAddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_relAddr: i128 = 0;
        let mut block_0_len = 1;
        let rel8 = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[derive(Clone, Debug)]
enum TableRel8 {
    Var0(Rel8Var0),
}
impl TableRel8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                Rel8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/8051_main.sinc, start:641:1, end:641:6))"]
#[derive(Clone, Debug)]
struct Rel16Var0 {
    rel16: u16,
}
impl Rel16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_relAddr: i128 = 0;
        calc_relAddr = i128::try_from(inst_next).unwrap().wrapping_add(
            i128::try_from(
                (if self.rel16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.rel16 as i16),
            )
            .unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_relAddr.is_negative(),
            calc_relAddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_relAddr: i128 = 0;
        let mut block_0_len = 2;
        let rel16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[derive(Clone, Debug)]
enum TableRel16 {
    Var0(Rel16Var0),
}
impl TableRel16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Rel16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:95:1, end:95:7))"]
#[derive(Clone, Debug)]
struct AtWRjbVar0 {
    wrj47: u8,
}
impl AtWRjbVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("@"),
            meaning_5_display(self.wrj47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtWRjb {
    Var0(AtWRjbVar0),
}
impl TableAtWRjb {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                AtWRjbVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:96:1, end:96:7))"]
#[derive(Clone, Debug)]
struct AtWRjwVar0 {
    wrj47: u8,
}
impl AtWRjwVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("@"),
            meaning_5_display(self.wrj47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtWRjw {
    Var0(AtWRjwVar0),
}
impl TableAtWRjw {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                AtWRjwVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:99:1, end:99:7))"]
#[derive(Clone, Debug)]
struct AtDRkbVar0 {
    drk47: u8,
}
impl AtDRkbVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("@"),
            meaning_8_display(self.drk47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let drk47 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRkb {
    Var0(AtDRkbVar0),
}
impl TableAtDRkb {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                AtDRkbVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:100:1, end:100:7))"]
#[derive(Clone, Debug)]
struct AtDRkwVar0 {
    drk47: u8,
}
impl AtDRkwVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("@"),
            meaning_8_display(self.drk47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let drk47 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRkw {
    Var0(AtDRkwVar0),
}
impl TableAtDRkw {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                AtDRkwVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:101:1, end:101:7))"]
#[derive(Clone, Debug)]
struct AtDRktVar0 {
    drk47: u8,
}
impl AtDRktVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("@"),
            meaning_8_display(self.drk47),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let drk47 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRkt {
    Var0(AtDRktVar0),
}
impl TableAtDRkt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                AtDRktVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:105:1, end:105:14))"]
#[derive(Clone, Debug)]
struct AtWRj47Dis16bVar0 {
    wrj47: u8,
    data16: u16,
}
impl AtWRj47Dis16bVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal("@"),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal("+"),
            DisplayElement::Number(true, false, self.data16 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let data16 = token_21(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtWRj47Dis16b {
    Var0(AtWRj47Dis16bVar0),
}
impl TableAtWRj47Dis16b {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 3 {
            if let Some((inst_len, parsed)) =
                AtWRj47Dis16bVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:106:1, end:106:14))"]
#[derive(Clone, Debug)]
struct AtWRj47Dis16wVar0 {
    wrj47: u8,
    data16: u16,
}
impl AtWRj47Dis16wVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal("@"),
            meaning_5_display(self.wrj47),
            <DisplayElement>::Literal("+"),
            DisplayElement::Number(true, false, self.data16 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let wrj47 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let data16 = token_21(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj47, data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtWRj47Dis16w {
    Var0(AtWRj47Dis16wVar0),
}
impl TableAtWRj47Dis16w {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 3 {
            if let Some((inst_len, parsed)) =
                AtWRj47Dis16wVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:108:1, end:108:14))"]
#[derive(Clone, Debug)]
struct AtWRj03Dis16bVar0 {
    wrj03: u8,
    data16: u16,
}
impl AtWRj03Dis16bVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal("@"),
            meaning_5_display(self.wrj03),
            <DisplayElement>::Literal("+"),
            DisplayElement::Number(true, false, self.data16 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let wrj03 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let data16 = token_21(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj03, data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtWRj03Dis16b {
    Var0(AtWRj03Dis16bVar0),
}
impl TableAtWRj03Dis16b {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 3 {
            if let Some((inst_len, parsed)) =
                AtWRj03Dis16bVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:109:1, end:109:14))"]
#[derive(Clone, Debug)]
struct AtWRj03Dis16wVar0 {
    wrj03: u8,
    data16: u16,
}
impl AtWRj03Dis16wVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal("@"),
            meaning_5_display(self.wrj03),
            <DisplayElement>::Literal("+"),
            DisplayElement::Number(true, false, self.data16 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let wrj03 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let data16 = token_21(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { wrj03, data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtWRj03Dis16w {
    Var0(AtWRj03Dis16wVar0),
}
impl TableAtWRj03Dis16w {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 3 {
            if let Some((inst_len, parsed)) =
                AtWRj03Dis16wVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:111:1, end:111:14))"]
#[derive(Clone, Debug)]
struct AtDRk47Dis24bVar0 {
    drk47: u8,
    data24: u32,
}
impl AtDRk47Dis24bVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal("@"),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal("+"),
            DisplayElement::Number(true, false, self.data24 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let drk47 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3;
        let data24 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47, data24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRk47Dis24b {
    Var0(AtDRk47Dis24bVar0),
}
impl TableAtDRk47Dis24b {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                AtDRk47Dis24bVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:112:1, end:112:14))"]
#[derive(Clone, Debug)]
struct AtDRk47Dis24wVar0 {
    drk47: u8,
    data24: u32,
}
impl AtDRk47Dis24wVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal("@"),
            meaning_8_display(self.drk47),
            <DisplayElement>::Literal("+"),
            DisplayElement::Number(true, false, self.data24 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let drk47 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3;
        let data24 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk47, data24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRk47Dis24w {
    Var0(AtDRk47Dis24wVar0),
}
impl TableAtDRk47Dis24w {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                AtDRk47Dis24wVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:114:1, end:114:14))"]
#[derive(Clone, Debug)]
struct AtDRk03Dis24bVar0 {
    drk03: u8,
    data24: u32,
}
impl AtDRk03Dis24bVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal("@"),
            meaning_8_display(self.drk03),
            <DisplayElement>::Literal("+"),
            DisplayElement::Number(true, false, self.data24 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let drk03 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3;
        let data24 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk03, data24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRk03Dis24b {
    Var0(AtDRk03Dis24bVar0),
}
impl TableAtDRk03Dis24b {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                AtDRk03Dis24bVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:115:1, end:115:14))"]
#[derive(Clone, Debug)]
struct AtDRk03Dis24wVar0 {
    drk03: u8,
    data24: u32,
}
impl AtDRk03Dis24wVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal("@"),
            meaning_8_display(self.drk03),
            <DisplayElement>::Literal("+"),
            DisplayElement::Number(true, false, self.data24 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let drk03 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3;
        let data24 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { drk03, data24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAtDRk03Dis24w {
    Var0(AtDRk03Dis24wVar0),
}
impl TableAtDRk03Dis24w {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                AtDRk03Dis24wVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:118:1, end:118:9))"]
#[derive(Clone, Debug)]
struct Direct8wVar0 {
    mainreg: u8,
}
impl Direct8wVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.mainreg as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mainreg = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mainreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:119:1, end:119:9))"]
#[derive(Clone, Debug)]
struct Direct8wVar1 {
    Direct: TableDirect,
}
impl Direct8wVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.Direct
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let Direct = if let Some((len, table)) =
            TableDirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Direct }))
    }
}
#[derive(Clone, Debug)]
enum TableDirect8w {
    Var0(Direct8wVar0),
    Var1(Direct8wVar1),
}
impl TableDirect8w {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                Direct8wVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                Direct8wVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:122:1, end:122:10))"]
#[derive(Clone, Debug)]
struct Direct16bVar0 {
    addr16: u16,
}
impl Direct16bVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.addr16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let addr16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr16 }))
    }
}
#[derive(Clone, Debug)]
enum TableDirect16b {
    Var0(Direct16bVar0),
}
impl TableDirect16b {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Direct16bVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:123:1, end:123:10))"]
#[derive(Clone, Debug)]
struct Direct16wVar0 {
    addr16: u16,
}
impl Direct16wVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.addr16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let addr16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr16 }))
    }
}
#[derive(Clone, Debug)]
enum TableDirect16w {
    Var0(Direct16wVar0),
}
impl TableDirect16w {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Direct16wVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:124:1, end:124:10))"]
#[derive(Clone, Debug)]
struct Direct16dVar0 {
    addr16: u16,
}
impl Direct16dVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.addr16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let addr16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr16 }))
    }
}
#[derive(Clone, Debug)]
enum TableDirect16d {
    Var0(Direct16dVar0),
}
impl TableDirect16d {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Direct16dVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:126:1, end:126:9))"]
#[derive(Clone, Debug)]
struct Data16x0Var0 {
    data16: u16,
}
impl Data16x0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.data16 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let data16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableData16x0 {
    Var0(Data16x0Var0),
}
impl TableData16x0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Data16x0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:127:1, end:127:9))"]
#[derive(Clone, Debug)]
struct Data16x1Var0 {
    data16: u16,
}
impl Data16x1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = 4294901760i128.wrapping_add(i128::try_from(self.data16).unwrap());
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            <DisplayElement>::Number(true, calc_val.is_negative(), calc_val.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = 4294901760i128.wrapping_add(i128::try_from(token_21(tokens_current)).unwrap());
        let data16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { data16 }))
    }
}
#[derive(Clone, Debug)]
enum TableData16x1 {
    Var0(Data16x1Var0),
}
impl TableData16x1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Data16x1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:129:1, end:129:7))"]
#[derive(Clone, Debug)]
struct Addr24Var0 {
    addr24: u32,
}
impl Addr24Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.addr24 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 3;
        let addr24 = token_27(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr24 {
    Var0(Addr24Var0),
}
impl TableAddr24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 3 {
            if let Some((inst_len, parsed)) =
                Addr24Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:132:1, end:132:6))"]
#[derive(Clone, Debug)]
struct ShortVar0 {
    short01: u8,
}
impl ShortVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            meaning_9_display(true, self.short01),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let short01 = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { short01 }))
    }
}
#[derive(Clone, Debug)]
enum TableShort {
    Var0(ShortVar0),
}
impl TableShort {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                ShortVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:137:1, end:137:13))"]
#[derive(Clone, Debug)]
struct xBitByteAddrVar0 {}
impl xBitByteAddrVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let bitaddr8 = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablexBitByteAddr {
    Var0(xBitByteAddrVar0),
}
impl TablexBitByteAddr {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                xBitByteAddrVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:139:1, end:139:9))"]
#[derive(Clone, Debug)]
struct xBitAddrVar0 {
    bit02: u8,
    bitaddr8: u8,
}
impl xBitAddrVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_bitaddr: i128 = 0;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .and_then(|shl| i128::try_from(self.bitaddr8).unwrap().checked_shl(shl))
            .unwrap_or(0)
            .wrapping_add(i128::try_from(self.bit02).unwrap());
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Number(true, calc_bitaddr.is_negative(), calc_bitaddr.abs() as u64),
            <DisplayElement>::Literal("."),
            DisplayElement::Number(true, false, self.bit02 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_bitaddr: i128 = 0;
        let mut block_0_len = 1;
        let bit02 = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_1(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            .wrapping_add(i128::try_from(token_4(tokens_current)).unwrap());
        let bitaddr8 = token_1(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bit02, bitaddr8 }))
    }
}
#[derive(Clone, Debug)]
enum TablexBitAddr {
    Var0(xBitAddrVar0),
}
impl TablexBitAddr {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                xBitAddrVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/8051/data/languages/80251.sinc, start:140:1, end:140:10))"]
#[derive(Clone, Debug)]
struct xBitAddr2Var0 {
    bit02: u8,
    bitaddr8: u8,
}
impl xBitAddr2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_bitaddr: i128 = 0;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .and_then(|shl| i128::try_from(self.bitaddr8).unwrap().checked_shl(shl))
            .unwrap_or(0)
            .wrapping_add(i128::try_from(self.bit02).unwrap());
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal("/"),
            <DisplayElement>::Number(true, calc_bitaddr.is_negative(), calc_bitaddr.abs() as u64),
            <DisplayElement>::Literal("."),
            DisplayElement::Number(true, false, self.bit02 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_bitaddr: i128 = 0;
        let mut block_0_len = 1;
        let bit02 = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        calc_bitaddr = u32::try_from(3i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_1(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            .wrapping_add(i128::try_from(token_4(tokens_current)).unwrap());
        let bitaddr8 = token_1(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bit02, bitaddr8 }))
    }
}
#[derive(Clone, Debug)]
enum TablexBitAddr2 {
    Var0(xBitAddr2Var0),
}
impl TablexBitAddr2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                xBitAddr2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
pub fn parse_instruction(
    tokens: &[u8],
    context: &mut ContextMemory,
    inst_start: AddrType,
    global_set: &mut GlobalSet,
) -> Option<(u32, Vec<DisplayElement>)> {
    let (inst_len, instruction) = Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(&mut display, context, inst_start, inst_next, global_set);
    Some((inst_next, display))
}
