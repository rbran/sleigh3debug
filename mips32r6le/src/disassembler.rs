pub type AddrType = u32;
#[derive(Clone, Copy, Debug)]
pub enum Register {
    zero,
    at,
    v0,
    v1,
    a0,
    a1,
    a2,
    a3,
    t0,
    t1,
    t2,
    t3,
    t4,
    t5,
    t6,
    t7,
    s0,
    s1,
    s2,
    s3,
    s4,
    s5,
    s6,
    s7,
    t8,
    t9,
    k0,
    k1,
    gp,
    sp,
    s8,
    ra,
    pc,
    f0,
    f1,
    f2,
    f3,
    f4,
    f5,
    f6,
    f7,
    f8,
    f9,
    f10,
    f11,
    f12,
    f13,
    f14,
    f15,
    f16,
    f17,
    f18,
    f19,
    f20,
    f21,
    f22,
    f23,
    f24,
    f25,
    f26,
    f27,
    f28,
    f29,
    f30,
    f31,
    fir,
    fccr,
    fexr,
    fenr,
    fcsr,
    Index,
    Random,
    EntryLo0,
    EntryLo1,
    Context,
    PageMask,
    Wired,
    HWREna,
    BadVAddr,
    Count,
    EntryHi,
    Compare,
    Status,
    Cause,
    EPC,
    PRId,
    Config,
    LLAddr,
    WatchLo,
    WatchHi,
    XContext,
    cop0_reg21,
    cop0_reg22,
    Debug,
    DEPC,
    PerfCnt,
    ErrCtl,
    CacheErr,
    TagLo,
    TagHi,
    ErrorEPC,
    DESAVE,
    MVPControl,
    VPEControl,
    TCStatus,
    cop0_reg3_1,
    ContextConfig,
    PageGrain,
    SRSConf0,
    cop0_reg7_1,
    cop0_reg8_1,
    cop0_reg9_1,
    cop0_reg10_1,
    cop0_reg11_1,
    IntCtl,
    cop0_reg13_1,
    cop0_reg14_1,
    EBase,
    Config1,
    cop0_reg17_1,
    WatchLo_1,
    WatchHi_1,
    cop0_reg20_1,
    cop0_reg21_1,
    cop0_reg22_1,
    TraceControl,
    cop0_reg24_1,
    PerfCnt_1,
    cop0_reg26_1,
    CacheErr_1,
    DataLo_1,
    DataHi_1,
    cop0_reg30_1,
    cop0_reg31_1,
    MVPConf0,
    VPEConf0,
    TCBind,
    cop0_reg3_2,
    cop0_reg4_2,
    cop0_reg5_2,
    SRSConf1,
    cop0_reg7_2,
    cop0_reg8_2,
    cop0_reg9_2,
    cop0_reg10_2,
    cop0_reg11_2,
    SRSCtl,
    cop0_reg13_2,
    cop0_reg14_2,
    cop0_reg15_2,
    Config2,
    cop0_reg17_2,
    WatchLo_2,
    WatchHi_2,
    cop0_reg20_2,
    cop0_reg21_2,
    cop0_reg22_2,
    TraceControl2,
    cop0_reg24_2,
    PerfCnt_2,
    cop0_reg26_2,
    CacheErr_2,
    TagLo_2,
    TagHi_2,
    cop0_reg30_2,
    cop0_reg31_2,
    MVPConf1,
    VPEConf1,
    TCRestart,
    cop0_reg3_3,
    cop0_reg4_3,
    cop0_reg5_3,
    SRSConf2,
    cop0_reg7_3,
    cop0_reg8_3,
    cop0_reg9_3,
    cop0_reg10_3,
    cop0_reg11_3,
    SRSMap,
    cop0_reg13_3,
    cop0_reg14_3,
    cop0_reg15_3,
    Config3,
    cop0_reg17_3,
    WatchLo_3,
    WatchHi_3,
    cop0_reg20_3,
    cop0_reg21_3,
    cop0_reg22_3,
    UserTraceData,
    cop0_reg24_3,
    PerfCnt_3,
    cop0_reg26_3,
    CacheErr_3,
    DataLo_3,
    DataHi_3,
    cop0_reg30_3,
    cop0_reg31_3,
    cop0_reg0_4,
    YQMask,
    TCHalt,
    cop0_reg3_4,
    cop0_reg4_4,
    cop0_reg5_4,
    SRSConf3,
    cop0_reg7_4,
    cop0_reg8_4,
    cop0_reg9_4,
    cop0_reg10_4,
    cop0_reg11_4,
    cop0_reg12_4,
    cop0_reg13_4,
    cop0_reg14_4,
    cop0_reg15_4,
    cop0_reg16_4,
    cop0_reg17_4,
    WatchLo_4,
    WatchHi_4,
    cop0_reg20_4,
    cop0_reg21_4,
    cop0_reg22_4,
    TraceBPC,
    cop0_reg24_4,
    PerfCnt_4,
    cop0_reg26_4,
    CacheErr_4,
    TagLo_4,
    TagHi_4,
    cop0_reg30_4,
    cop0_reg31_4,
    cop0_reg0_5,
    VPESchedule,
    TCContext,
    cop0_reg3_5,
    cop0_reg4_5,
    cop0_reg5_5,
    SRSConf4,
    cop0_reg7_5,
    cop0_reg8_5,
    cop0_reg9_5,
    cop0_reg10_5,
    cop0_reg11_5,
    cop0_reg12_5,
    cop0_reg13_5,
    cop0_reg14_5,
    cop0_reg15_5,
    cop0_reg16_5,
    cop0_reg17_5,
    WatchLo_5,
    WatchHi_5,
    cop0_reg20_5,
    cop0_reg21_5,
    cop0_reg22_5,
    cop0_reg23_5,
    cop0_reg24_5,
    PerfCnt_5,
    cop0_reg26_5,
    CacheErr_5,
    DataLo_5,
    DataHi_5,
    cop0_reg30_5,
    cop0_reg31_5,
    cop0_reg0_6,
    VPEScheFBack,
    TCSchedule,
    cop0_reg3_6,
    cop0_reg4_6,
    cop0_reg5_6,
    cop0_reg6_6,
    cop0_reg7_6,
    cop0_reg8_6,
    cop0_reg9_6,
    cop0_reg10_6,
    cop0_reg11_6,
    cop0_reg12_6,
    cop0_reg13_6,
    cop0_reg14_6,
    cop0_reg15_6,
    cop0_reg16_6,
    cop0_reg17_6,
    WatchLo_6,
    WatchHi_6,
    cop0_reg20_6,
    cop0_reg21_6,
    cop0_reg22_6,
    cop0_reg23_6,
    cop0_reg24_6,
    PerfCnt_6,
    cop0_reg26_6,
    CacheErr_6,
    TagLo_6,
    TagHi_6,
    cop0_reg30_6,
    cop0_reg31_6,
    cop0_reg0_7,
    VPEOpt,
    TCScheFBack,
    cop0_reg3_7,
    cop0_reg4_7,
    cop0_reg5_7,
    cop0_reg6_7,
    cop0_reg7_7,
    cop0_reg8_7,
    cop0_reg9_7,
    cop0_reg10_7,
    cop0_reg11_7,
    cop0_reg12_7,
    cop0_reg13_7,
    cop0_reg14_7,
    cop0_reg15_7,
    cop0_reg16_7,
    cop0_reg17_7,
    WatchLo_7,
    WatchHi_7,
    cop0_reg20_7,
    cop0_reg21_7,
    cop0_reg22_7,
    cop0_reg23_7,
    cop0_reg24_7,
    PerfCnt_7,
    cop0_reg26_7,
    CacheErr_7,
    DataLo_7,
    DataHi_7,
    cop0_reg30_7,
    cop0_reg31_7,
    lo,
    hi,
    lo1,
    hi1,
    lo2,
    hi2,
    lo3,
    hi3,
    tsp,
    ac0,
    ac1,
    ac2,
    ac3,
    DSPControl,
    HW_CPUNUM,
    HW_SYNCI_STEP,
    HW_CC,
    HW_CCRe,
    HW_PerfCtr,
    HW_XNP,
    HW_RES6,
    HW_RES7,
    HW_RES8,
    HW_RES9,
    HW_RES10,
    HW_RES11,
    HW_RES12,
    HW_RES13,
    HW_RES14,
    HW_RES15,
    HW_RES16,
    HW_RES17,
    HW_RES18,
    HW_RES19,
    HW_RES20,
    HW_RES21,
    HW_RES22,
    HW_RES23,
    HW_RES24,
    HW_RES25,
    HW_RES26,
    HW_RES27,
    HW_RES28,
    HW_ULR,
    HW_RESIM30,
    HW_RESIM31,
    ISAModeSwitch,
    thread_zero,
    thread_at,
    thread_v0,
    thread_v1,
    thread_a0,
    thread_a1,
    thread_a2,
    thread_a3,
    thread_t0,
    thread_t1,
    thread_t2,
    thread_t3,
    thread_t4,
    thread_t5,
    thread_t6,
    thread_t7,
    thread_s0,
    thread_s1,
    thread_s2,
    thread_s3,
    thread_s4,
    thread_s5,
    thread_s6,
    thread_s7,
    thread_t8,
    thread_t9,
    thread_k0,
    thread_k1,
    thread_gp,
    thread_sp,
    thread_s8,
    thread_ra,
    thread_f0,
    thread_f1,
    thread_f2,
    thread_f3,
    thread_f4,
    thread_f5,
    thread_f6,
    thread_f7,
    thread_f8,
    thread_f9,
    thread_f10,
    thread_f11,
    thread_f12,
    thread_f13,
    thread_f14,
    thread_f15,
    thread_f16,
    thread_f17,
    thread_f18,
    thread_f19,
    thread_f20,
    thread_f21,
    thread_f22,
    thread_f23,
    thread_f24,
    thread_f25,
    thread_f26,
    thread_f27,
    thread_f28,
    thread_f29,
    thread_f30,
    thread_f31,
    thread_lo0,
    thread_hi0,
    thread_acx0,
    thread_lo1,
    thread_hi1,
    thread_acx1,
    thread_lo2,
    thread_hi2,
    thread_acx2,
    thread_lo3,
    thread_hi3,
    thread_acx3,
    thread_fir,
    thread_fccr,
    thread_fexr,
    thread_fenr,
    thread_fcsr,
    contextreg,
}
impl Register {
    fn as_str(&self) -> &'static str {
        match self {
            Self::zero => "zero",
            Self::at => "at",
            Self::v0 => "v0",
            Self::v1 => "v1",
            Self::a0 => "a0",
            Self::a1 => "a1",
            Self::a2 => "a2",
            Self::a3 => "a3",
            Self::t0 => "t0",
            Self::t1 => "t1",
            Self::t2 => "t2",
            Self::t3 => "t3",
            Self::t4 => "t4",
            Self::t5 => "t5",
            Self::t6 => "t6",
            Self::t7 => "t7",
            Self::s0 => "s0",
            Self::s1 => "s1",
            Self::s2 => "s2",
            Self::s3 => "s3",
            Self::s4 => "s4",
            Self::s5 => "s5",
            Self::s6 => "s6",
            Self::s7 => "s7",
            Self::t8 => "t8",
            Self::t9 => "t9",
            Self::k0 => "k0",
            Self::k1 => "k1",
            Self::gp => "gp",
            Self::sp => "sp",
            Self::s8 => "s8",
            Self::ra => "ra",
            Self::pc => "pc",
            Self::f0 => "f0",
            Self::f1 => "f1",
            Self::f2 => "f2",
            Self::f3 => "f3",
            Self::f4 => "f4",
            Self::f5 => "f5",
            Self::f6 => "f6",
            Self::f7 => "f7",
            Self::f8 => "f8",
            Self::f9 => "f9",
            Self::f10 => "f10",
            Self::f11 => "f11",
            Self::f12 => "f12",
            Self::f13 => "f13",
            Self::f14 => "f14",
            Self::f15 => "f15",
            Self::f16 => "f16",
            Self::f17 => "f17",
            Self::f18 => "f18",
            Self::f19 => "f19",
            Self::f20 => "f20",
            Self::f21 => "f21",
            Self::f22 => "f22",
            Self::f23 => "f23",
            Self::f24 => "f24",
            Self::f25 => "f25",
            Self::f26 => "f26",
            Self::f27 => "f27",
            Self::f28 => "f28",
            Self::f29 => "f29",
            Self::f30 => "f30",
            Self::f31 => "f31",
            Self::fir => "fir",
            Self::fccr => "fccr",
            Self::fexr => "fexr",
            Self::fenr => "fenr",
            Self::fcsr => "fcsr",
            Self::Index => "Index",
            Self::Random => "Random",
            Self::EntryLo0 => "EntryLo0",
            Self::EntryLo1 => "EntryLo1",
            Self::Context => "Context",
            Self::PageMask => "PageMask",
            Self::Wired => "Wired",
            Self::HWREna => "HWREna",
            Self::BadVAddr => "BadVAddr",
            Self::Count => "Count",
            Self::EntryHi => "EntryHi",
            Self::Compare => "Compare",
            Self::Status => "Status",
            Self::Cause => "Cause",
            Self::EPC => "EPC",
            Self::PRId => "PRId",
            Self::Config => "Config",
            Self::LLAddr => "LLAddr",
            Self::WatchLo => "WatchLo",
            Self::WatchHi => "WatchHi",
            Self::XContext => "XContext",
            Self::cop0_reg21 => "cop0_reg21",
            Self::cop0_reg22 => "cop0_reg22",
            Self::Debug => "Debug",
            Self::DEPC => "DEPC",
            Self::PerfCnt => "PerfCnt",
            Self::ErrCtl => "ErrCtl",
            Self::CacheErr => "CacheErr",
            Self::TagLo => "TagLo",
            Self::TagHi => "TagHi",
            Self::ErrorEPC => "ErrorEPC",
            Self::DESAVE => "DESAVE",
            Self::MVPControl => "MVPControl",
            Self::VPEControl => "VPEControl",
            Self::TCStatus => "TCStatus",
            Self::cop0_reg3_1 => "cop0_reg3.1",
            Self::ContextConfig => "ContextConfig",
            Self::PageGrain => "PageGrain",
            Self::SRSConf0 => "SRSConf0",
            Self::cop0_reg7_1 => "cop0_reg7.1",
            Self::cop0_reg8_1 => "cop0_reg8.1",
            Self::cop0_reg9_1 => "cop0_reg9.1",
            Self::cop0_reg10_1 => "cop0_reg10.1",
            Self::cop0_reg11_1 => "cop0_reg11.1",
            Self::IntCtl => "IntCtl",
            Self::cop0_reg13_1 => "cop0_reg13.1",
            Self::cop0_reg14_1 => "cop0_reg14.1",
            Self::EBase => "EBase",
            Self::Config1 => "Config1",
            Self::cop0_reg17_1 => "cop0_reg17.1",
            Self::WatchLo_1 => "WatchLo.1",
            Self::WatchHi_1 => "WatchHi.1",
            Self::cop0_reg20_1 => "cop0_reg20.1",
            Self::cop0_reg21_1 => "cop0_reg21.1",
            Self::cop0_reg22_1 => "cop0_reg22.1",
            Self::TraceControl => "TraceControl",
            Self::cop0_reg24_1 => "cop0_reg24.1",
            Self::PerfCnt_1 => "PerfCnt.1",
            Self::cop0_reg26_1 => "cop0_reg26.1",
            Self::CacheErr_1 => "CacheErr.1",
            Self::DataLo_1 => "DataLo.1",
            Self::DataHi_1 => "DataHi.1",
            Self::cop0_reg30_1 => "cop0_reg30.1",
            Self::cop0_reg31_1 => "cop0_reg31.1",
            Self::MVPConf0 => "MVPConf0",
            Self::VPEConf0 => "VPEConf0",
            Self::TCBind => "TCBind",
            Self::cop0_reg3_2 => "cop0_reg3.2",
            Self::cop0_reg4_2 => "cop0_reg4.2",
            Self::cop0_reg5_2 => "cop0_reg5.2",
            Self::SRSConf1 => "SRSConf1",
            Self::cop0_reg7_2 => "cop0_reg7.2",
            Self::cop0_reg8_2 => "cop0_reg8.2",
            Self::cop0_reg9_2 => "cop0_reg9.2",
            Self::cop0_reg10_2 => "cop0_reg10.2",
            Self::cop0_reg11_2 => "cop0_reg11.2",
            Self::SRSCtl => "SRSCtl",
            Self::cop0_reg13_2 => "cop0_reg13.2",
            Self::cop0_reg14_2 => "cop0_reg14.2",
            Self::cop0_reg15_2 => "cop0_reg15.2",
            Self::Config2 => "Config2",
            Self::cop0_reg17_2 => "cop0_reg17.2",
            Self::WatchLo_2 => "WatchLo.2",
            Self::WatchHi_2 => "WatchHi.2",
            Self::cop0_reg20_2 => "cop0_reg20.2",
            Self::cop0_reg21_2 => "cop0_reg21.2",
            Self::cop0_reg22_2 => "cop0_reg22.2",
            Self::TraceControl2 => "TraceControl2",
            Self::cop0_reg24_2 => "cop0_reg24.2",
            Self::PerfCnt_2 => "PerfCnt.2",
            Self::cop0_reg26_2 => "cop0_reg26.2",
            Self::CacheErr_2 => "CacheErr.2",
            Self::TagLo_2 => "TagLo.2",
            Self::TagHi_2 => "TagHi.2",
            Self::cop0_reg30_2 => "cop0_reg30.2",
            Self::cop0_reg31_2 => "cop0_reg31.2",
            Self::MVPConf1 => "MVPConf1",
            Self::VPEConf1 => "VPEConf1",
            Self::TCRestart => "TCRestart",
            Self::cop0_reg3_3 => "cop0_reg3.3",
            Self::cop0_reg4_3 => "cop0_reg4.3",
            Self::cop0_reg5_3 => "cop0_reg5.3",
            Self::SRSConf2 => "SRSConf2",
            Self::cop0_reg7_3 => "cop0_reg7.3",
            Self::cop0_reg8_3 => "cop0_reg8.3",
            Self::cop0_reg9_3 => "cop0_reg9.3",
            Self::cop0_reg10_3 => "cop0_reg10.3",
            Self::cop0_reg11_3 => "cop0_reg11.3",
            Self::SRSMap => "SRSMap",
            Self::cop0_reg13_3 => "cop0_reg13.3",
            Self::cop0_reg14_3 => "cop0_reg14.3",
            Self::cop0_reg15_3 => "cop0_reg15.3",
            Self::Config3 => "Config3",
            Self::cop0_reg17_3 => "cop0_reg17.3",
            Self::WatchLo_3 => "WatchLo.3",
            Self::WatchHi_3 => "WatchHi.3",
            Self::cop0_reg20_3 => "cop0_reg20.3",
            Self::cop0_reg21_3 => "cop0_reg21.3",
            Self::cop0_reg22_3 => "cop0_reg22.3",
            Self::UserTraceData => "UserTraceData",
            Self::cop0_reg24_3 => "cop0_reg24.3",
            Self::PerfCnt_3 => "PerfCnt.3",
            Self::cop0_reg26_3 => "cop0_reg26.3",
            Self::CacheErr_3 => "CacheErr.3",
            Self::DataLo_3 => "DataLo.3",
            Self::DataHi_3 => "DataHi.3",
            Self::cop0_reg30_3 => "cop0_reg30.3",
            Self::cop0_reg31_3 => "cop0_reg31.3",
            Self::cop0_reg0_4 => "cop0_reg0.4",
            Self::YQMask => "YQMask",
            Self::TCHalt => "TCHalt",
            Self::cop0_reg3_4 => "cop0_reg3.4",
            Self::cop0_reg4_4 => "cop0_reg4.4",
            Self::cop0_reg5_4 => "cop0_reg5.4",
            Self::SRSConf3 => "SRSConf3",
            Self::cop0_reg7_4 => "cop0_reg7.4",
            Self::cop0_reg8_4 => "cop0_reg8.4",
            Self::cop0_reg9_4 => "cop0_reg9.4",
            Self::cop0_reg10_4 => "cop0_reg10.4",
            Self::cop0_reg11_4 => "cop0_reg11.4",
            Self::cop0_reg12_4 => "cop0_reg12.4",
            Self::cop0_reg13_4 => "cop0_reg13.4",
            Self::cop0_reg14_4 => "cop0_reg14.4",
            Self::cop0_reg15_4 => "cop0_reg15.4",
            Self::cop0_reg16_4 => "cop0_reg16.4",
            Self::cop0_reg17_4 => "cop0_reg17.4",
            Self::WatchLo_4 => "WatchLo.4",
            Self::WatchHi_4 => "WatchHi.4",
            Self::cop0_reg20_4 => "cop0_reg20.4",
            Self::cop0_reg21_4 => "cop0_reg21.4",
            Self::cop0_reg22_4 => "cop0_reg22.4",
            Self::TraceBPC => "TraceBPC",
            Self::cop0_reg24_4 => "cop0_reg24.4",
            Self::PerfCnt_4 => "PerfCnt.4",
            Self::cop0_reg26_4 => "cop0_reg26.4",
            Self::CacheErr_4 => "CacheErr.4",
            Self::TagLo_4 => "TagLo.4",
            Self::TagHi_4 => "TagHi.4",
            Self::cop0_reg30_4 => "cop0_reg30.4",
            Self::cop0_reg31_4 => "cop0_reg31.4",
            Self::cop0_reg0_5 => "cop0_reg0.5",
            Self::VPESchedule => "VPESchedule",
            Self::TCContext => "TCContext",
            Self::cop0_reg3_5 => "cop0_reg3.5",
            Self::cop0_reg4_5 => "cop0_reg4.5",
            Self::cop0_reg5_5 => "cop0_reg5.5",
            Self::SRSConf4 => "SRSConf4",
            Self::cop0_reg7_5 => "cop0_reg7.5",
            Self::cop0_reg8_5 => "cop0_reg8.5",
            Self::cop0_reg9_5 => "cop0_reg9.5",
            Self::cop0_reg10_5 => "cop0_reg10.5",
            Self::cop0_reg11_5 => "cop0_reg11.5",
            Self::cop0_reg12_5 => "cop0_reg12.5",
            Self::cop0_reg13_5 => "cop0_reg13.5",
            Self::cop0_reg14_5 => "cop0_reg14.5",
            Self::cop0_reg15_5 => "cop0_reg15.5",
            Self::cop0_reg16_5 => "cop0_reg16.5",
            Self::cop0_reg17_5 => "cop0_reg17.5",
            Self::WatchLo_5 => "WatchLo.5",
            Self::WatchHi_5 => "WatchHi.5",
            Self::cop0_reg20_5 => "cop0_reg20.5",
            Self::cop0_reg21_5 => "cop0_reg21.5",
            Self::cop0_reg22_5 => "cop0_reg22.5",
            Self::cop0_reg23_5 => "cop0_reg23.5",
            Self::cop0_reg24_5 => "cop0_reg24.5",
            Self::PerfCnt_5 => "PerfCnt.5",
            Self::cop0_reg26_5 => "cop0_reg26.5",
            Self::CacheErr_5 => "CacheErr.5",
            Self::DataLo_5 => "DataLo.5",
            Self::DataHi_5 => "DataHi.5",
            Self::cop0_reg30_5 => "cop0_reg30.5",
            Self::cop0_reg31_5 => "cop0_reg31.5",
            Self::cop0_reg0_6 => "cop0_reg0.6",
            Self::VPEScheFBack => "VPEScheFBack",
            Self::TCSchedule => "TCSchedule",
            Self::cop0_reg3_6 => "cop0_reg3.6",
            Self::cop0_reg4_6 => "cop0_reg4.6",
            Self::cop0_reg5_6 => "cop0_reg5.6",
            Self::cop0_reg6_6 => "cop0_reg6.6",
            Self::cop0_reg7_6 => "cop0_reg7.6",
            Self::cop0_reg8_6 => "cop0_reg8.6",
            Self::cop0_reg9_6 => "cop0_reg9.6",
            Self::cop0_reg10_6 => "cop0_reg10.6",
            Self::cop0_reg11_6 => "cop0_reg11.6",
            Self::cop0_reg12_6 => "cop0_reg12.6",
            Self::cop0_reg13_6 => "cop0_reg13.6",
            Self::cop0_reg14_6 => "cop0_reg14.6",
            Self::cop0_reg15_6 => "cop0_reg15.6",
            Self::cop0_reg16_6 => "cop0_reg16.6",
            Self::cop0_reg17_6 => "cop0_reg17.6",
            Self::WatchLo_6 => "WatchLo.6",
            Self::WatchHi_6 => "WatchHi.6",
            Self::cop0_reg20_6 => "cop0_reg20.6",
            Self::cop0_reg21_6 => "cop0_reg21.6",
            Self::cop0_reg22_6 => "cop0_reg22.6",
            Self::cop0_reg23_6 => "cop0_reg23.6",
            Self::cop0_reg24_6 => "cop0_reg24.6",
            Self::PerfCnt_6 => "PerfCnt.6",
            Self::cop0_reg26_6 => "cop0_reg26.6",
            Self::CacheErr_6 => "CacheErr.6",
            Self::TagLo_6 => "TagLo.6",
            Self::TagHi_6 => "TagHi.6",
            Self::cop0_reg30_6 => "cop0_reg30.6",
            Self::cop0_reg31_6 => "cop0_reg31.6",
            Self::cop0_reg0_7 => "cop0_reg0.7",
            Self::VPEOpt => "VPEOpt",
            Self::TCScheFBack => "TCScheFBack",
            Self::cop0_reg3_7 => "cop0_reg3.7",
            Self::cop0_reg4_7 => "cop0_reg4.7",
            Self::cop0_reg5_7 => "cop0_reg5.7",
            Self::cop0_reg6_7 => "cop0_reg6.7",
            Self::cop0_reg7_7 => "cop0_reg7.7",
            Self::cop0_reg8_7 => "cop0_reg8.7",
            Self::cop0_reg9_7 => "cop0_reg9.7",
            Self::cop0_reg10_7 => "cop0_reg10.7",
            Self::cop0_reg11_7 => "cop0_reg11.7",
            Self::cop0_reg12_7 => "cop0_reg12.7",
            Self::cop0_reg13_7 => "cop0_reg13.7",
            Self::cop0_reg14_7 => "cop0_reg14.7",
            Self::cop0_reg15_7 => "cop0_reg15.7",
            Self::cop0_reg16_7 => "cop0_reg16.7",
            Self::cop0_reg17_7 => "cop0_reg17.7",
            Self::WatchLo_7 => "WatchLo.7",
            Self::WatchHi_7 => "WatchHi.7",
            Self::cop0_reg20_7 => "cop0_reg20.7",
            Self::cop0_reg21_7 => "cop0_reg21.7",
            Self::cop0_reg22_7 => "cop0_reg22.7",
            Self::cop0_reg23_7 => "cop0_reg23.7",
            Self::cop0_reg24_7 => "cop0_reg24.7",
            Self::PerfCnt_7 => "PerfCnt.7",
            Self::cop0_reg26_7 => "cop0_reg26.7",
            Self::CacheErr_7 => "CacheErr.7",
            Self::DataLo_7 => "DataLo.7",
            Self::DataHi_7 => "DataHi.7",
            Self::cop0_reg30_7 => "cop0_reg30.7",
            Self::cop0_reg31_7 => "cop0_reg31.7",
            Self::lo => "lo",
            Self::hi => "hi",
            Self::lo1 => "lo1",
            Self::hi1 => "hi1",
            Self::lo2 => "lo2",
            Self::hi2 => "hi2",
            Self::lo3 => "lo3",
            Self::hi3 => "hi3",
            Self::tsp => "tsp",
            Self::ac0 => "ac0",
            Self::ac1 => "ac1",
            Self::ac2 => "ac2",
            Self::ac3 => "ac3",
            Self::DSPControl => "DSPControl",
            Self::HW_CPUNUM => "HW_CPUNUM",
            Self::HW_SYNCI_STEP => "HW_SYNCI_STEP",
            Self::HW_CC => "HW_CC",
            Self::HW_CCRe => "HW_CCRe",
            Self::HW_PerfCtr => "HW_PerfCtr",
            Self::HW_XNP => "HW_XNP",
            Self::HW_RES6 => "HW_RES6",
            Self::HW_RES7 => "HW_RES7",
            Self::HW_RES8 => "HW_RES8",
            Self::HW_RES9 => "HW_RES9",
            Self::HW_RES10 => "HW_RES10",
            Self::HW_RES11 => "HW_RES11",
            Self::HW_RES12 => "HW_RES12",
            Self::HW_RES13 => "HW_RES13",
            Self::HW_RES14 => "HW_RES14",
            Self::HW_RES15 => "HW_RES15",
            Self::HW_RES16 => "HW_RES16",
            Self::HW_RES17 => "HW_RES17",
            Self::HW_RES18 => "HW_RES18",
            Self::HW_RES19 => "HW_RES19",
            Self::HW_RES20 => "HW_RES20",
            Self::HW_RES21 => "HW_RES21",
            Self::HW_RES22 => "HW_RES22",
            Self::HW_RES23 => "HW_RES23",
            Self::HW_RES24 => "HW_RES24",
            Self::HW_RES25 => "HW_RES25",
            Self::HW_RES26 => "HW_RES26",
            Self::HW_RES27 => "HW_RES27",
            Self::HW_RES28 => "HW_RES28",
            Self::HW_ULR => "HW_ULR",
            Self::HW_RESIM30 => "HW_RESIM30",
            Self::HW_RESIM31 => "HW_RESIM31",
            Self::ISAModeSwitch => "ISAModeSwitch",
            Self::thread_zero => "thread_zero",
            Self::thread_at => "thread_at",
            Self::thread_v0 => "thread_v0",
            Self::thread_v1 => "thread_v1",
            Self::thread_a0 => "thread_a0",
            Self::thread_a1 => "thread_a1",
            Self::thread_a2 => "thread_a2",
            Self::thread_a3 => "thread_a3",
            Self::thread_t0 => "thread_t0",
            Self::thread_t1 => "thread_t1",
            Self::thread_t2 => "thread_t2",
            Self::thread_t3 => "thread_t3",
            Self::thread_t4 => "thread_t4",
            Self::thread_t5 => "thread_t5",
            Self::thread_t6 => "thread_t6",
            Self::thread_t7 => "thread_t7",
            Self::thread_s0 => "thread_s0",
            Self::thread_s1 => "thread_s1",
            Self::thread_s2 => "thread_s2",
            Self::thread_s3 => "thread_s3",
            Self::thread_s4 => "thread_s4",
            Self::thread_s5 => "thread_s5",
            Self::thread_s6 => "thread_s6",
            Self::thread_s7 => "thread_s7",
            Self::thread_t8 => "thread_t8",
            Self::thread_t9 => "thread_t9",
            Self::thread_k0 => "thread_k0",
            Self::thread_k1 => "thread_k1",
            Self::thread_gp => "thread_gp",
            Self::thread_sp => "thread_sp",
            Self::thread_s8 => "thread_s8",
            Self::thread_ra => "thread_ra",
            Self::thread_f0 => "thread_f0",
            Self::thread_f1 => "thread_f1",
            Self::thread_f2 => "thread_f2",
            Self::thread_f3 => "thread_f3",
            Self::thread_f4 => "thread_f4",
            Self::thread_f5 => "thread_f5",
            Self::thread_f6 => "thread_f6",
            Self::thread_f7 => "thread_f7",
            Self::thread_f8 => "thread_f8",
            Self::thread_f9 => "thread_f9",
            Self::thread_f10 => "thread_f10",
            Self::thread_f11 => "thread_f11",
            Self::thread_f12 => "thread_f12",
            Self::thread_f13 => "thread_f13",
            Self::thread_f14 => "thread_f14",
            Self::thread_f15 => "thread_f15",
            Self::thread_f16 => "thread_f16",
            Self::thread_f17 => "thread_f17",
            Self::thread_f18 => "thread_f18",
            Self::thread_f19 => "thread_f19",
            Self::thread_f20 => "thread_f20",
            Self::thread_f21 => "thread_f21",
            Self::thread_f22 => "thread_f22",
            Self::thread_f23 => "thread_f23",
            Self::thread_f24 => "thread_f24",
            Self::thread_f25 => "thread_f25",
            Self::thread_f26 => "thread_f26",
            Self::thread_f27 => "thread_f27",
            Self::thread_f28 => "thread_f28",
            Self::thread_f29 => "thread_f29",
            Self::thread_f30 => "thread_f30",
            Self::thread_f31 => "thread_f31",
            Self::thread_lo0 => "thread_lo0",
            Self::thread_hi0 => "thread_hi0",
            Self::thread_acx0 => "thread_acx0",
            Self::thread_lo1 => "thread_lo1",
            Self::thread_hi1 => "thread_hi1",
            Self::thread_acx1 => "thread_acx1",
            Self::thread_lo2 => "thread_lo2",
            Self::thread_hi2 => "thread_hi2",
            Self::thread_acx2 => "thread_acx2",
            Self::thread_lo3 => "thread_lo3",
            Self::thread_hi3 => "thread_hi3",
            Self::thread_acx3 => "thread_acx3",
            Self::thread_fir => "thread_fir",
            Self::thread_fccr => "thread_fccr",
            Self::thread_fexr => "thread_fexr",
            Self::thread_fenr => "thread_fenr",
            Self::thread_fcsr => "thread_fcsr",
            Self::contextreg => "contextreg",
        }
    }
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::zero,
        1 => Register::at,
        2 => Register::v0,
        3 => Register::v1,
        4 => Register::a0,
        5 => Register::a1,
        6 => Register::a2,
        7 => Register::a3,
        8 => Register::t0,
        9 => Register::t1,
        10 => Register::t2,
        11 => Register::t3,
        12 => Register::t4,
        13 => Register::t5,
        14 => Register::t6,
        15 => Register::t7,
        16 => Register::s0,
        17 => Register::s1,
        18 => Register::s2,
        19 => Register::s3,
        20 => Register::s4,
        21 => Register::s5,
        22 => Register::s6,
        23 => Register::s7,
        24 => Register::t8,
        25 => Register::t9,
        26 => Register::k0,
        27 => Register::k1,
        28 => Register::gp,
        29 => Register::sp,
        30 => Register::s8,
        31 => Register::ra,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::HW_CPUNUM,
        1 => Register::HW_SYNCI_STEP,
        2 => Register::HW_CC,
        3 => Register::HW_CCRe,
        4 => Register::HW_PerfCtr,
        5 => Register::HW_XNP,
        6 => Register::HW_RES6,
        7 => Register::HW_RES7,
        8 => Register::HW_RES8,
        9 => Register::HW_RES9,
        10 => Register::HW_RES10,
        11 => Register::HW_RES11,
        12 => Register::HW_RES12,
        13 => Register::HW_RES13,
        14 => Register::HW_RES14,
        15 => Register::HW_RES15,
        16 => Register::HW_RES26,
        17 => Register::HW_RES17,
        18 => Register::HW_RES18,
        19 => Register::HW_RES19,
        20 => Register::HW_RES20,
        21 => Register::HW_RES21,
        22 => Register::HW_RES22,
        23 => Register::HW_RES23,
        24 => Register::HW_RES24,
        25 => Register::HW_RES25,
        26 => Register::HW_RES26,
        27 => Register::HW_RES27,
        28 => Register::HW_RES28,
        29 => Register::HW_ULR,
        30 => Register::HW_RESIM30,
        31 => Register::HW_RESIM31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::zero,
        1 => Register::at,
        2 => Register::v0,
        3 => Register::v1,
        4 => Register::a0,
        5 => Register::a1,
        6 => Register::a2,
        7 => Register::a3,
        8 => Register::t0,
        9 => Register::t1,
        10 => Register::t2,
        11 => Register::t3,
        12 => Register::t4,
        13 => Register::t5,
        14 => Register::t6,
        15 => Register::t7,
        16 => Register::s0,
        17 => Register::s1,
        18 => Register::s2,
        19 => Register::s3,
        20 => Register::s4,
        21 => Register::s5,
        22 => Register::s6,
        23 => Register::s7,
        24 => Register::t8,
        25 => Register::t9,
        26 => Register::k0,
        27 => Register::k1,
        28 => Register::gp,
        29 => Register::sp,
        30 => Register::s8,
        31 => Register::ra,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::f0,
        1 => Register::f1,
        2 => Register::f2,
        3 => Register::f3,
        4 => Register::f4,
        5 => Register::f5,
        6 => Register::f6,
        7 => Register::f7,
        8 => Register::f8,
        9 => Register::f9,
        10 => Register::f10,
        11 => Register::f11,
        12 => Register::f12,
        13 => Register::f13,
        14 => Register::f14,
        15 => Register::f15,
        16 => Register::f16,
        17 => Register::f17,
        18 => Register::f18,
        19 => Register::f19,
        20 => Register::f20,
        21 => Register::f21,
        22 => Register::f22,
        23 => Register::f23,
        24 => Register::f24,
        25 => Register::f25,
        26 => Register::f26,
        27 => Register::f27,
        28 => Register::f28,
        29 => Register::f29,
        30 => Register::f30,
        31 => Register::f31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::f0,
        1 => Register::f1,
        2 => Register::f2,
        3 => Register::f3,
        4 => Register::f4,
        5 => Register::f5,
        6 => Register::f6,
        7 => Register::f7,
        8 => Register::f8,
        9 => Register::f9,
        10 => Register::f10,
        11 => Register::f11,
        12 => Register::f12,
        13 => Register::f13,
        14 => Register::f14,
        15 => Register::f15,
        16 => Register::f16,
        17 => Register::f17,
        18 => Register::f18,
        19 => Register::f19,
        20 => Register::f20,
        21 => Register::f21,
        22 => Register::f22,
        23 => Register::f23,
        24 => Register::f24,
        25 => Register::f25,
        26 => Register::f26,
        27 => Register::f27,
        28 => Register::f28,
        29 => Register::f29,
        30 => Register::f30,
        31 => Register::f31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fir,
        25 => Register::fccr,
        26 => Register::fexr,
        28 => Register::fenr,
        31 => Register::fcsr,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::Index,
        1 => Register::Random,
        2 => Register::EntryLo0,
        3 => Register::EntryLo1,
        4 => Register::Context,
        5 => Register::PageMask,
        6 => Register::Wired,
        7 => Register::HWREna,
        8 => Register::BadVAddr,
        9 => Register::Count,
        10 => Register::EntryHi,
        11 => Register::Compare,
        12 => Register::Status,
        13 => Register::Cause,
        14 => Register::EPC,
        15 => Register::PRId,
        16 => Register::Config,
        17 => Register::LLAddr,
        18 => Register::WatchLo,
        19 => Register::WatchHi,
        20 => Register::XContext,
        21 => Register::cop0_reg21,
        22 => Register::cop0_reg22,
        23 => Register::Debug,
        24 => Register::DEPC,
        25 => Register::PerfCnt,
        26 => Register::ErrCtl,
        27 => Register::CacheErr,
        28 => Register::TagLo,
        29 => Register::TagHi,
        30 => Register::ErrorEPC,
        31 => Register::DESAVE,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_7_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::MVPControl,
        1 => Register::VPEControl,
        2 => Register::TCStatus,
        3 => Register::cop0_reg3_1,
        4 => Register::ContextConfig,
        5 => Register::PageGrain,
        6 => Register::SRSConf0,
        7 => Register::cop0_reg7_1,
        8 => Register::cop0_reg8_1,
        9 => Register::cop0_reg9_1,
        10 => Register::cop0_reg10_1,
        11 => Register::cop0_reg11_1,
        12 => Register::IntCtl,
        13 => Register::cop0_reg13_1,
        14 => Register::cop0_reg14_1,
        15 => Register::EBase,
        16 => Register::Config1,
        17 => Register::cop0_reg17_1,
        18 => Register::WatchLo_1,
        19 => Register::WatchHi_1,
        20 => Register::cop0_reg20_1,
        21 => Register::cop0_reg21_1,
        22 => Register::cop0_reg22_1,
        23 => Register::TraceControl,
        24 => Register::cop0_reg24_1,
        25 => Register::PerfCnt_1,
        26 => Register::cop0_reg26_1,
        27 => Register::CacheErr_1,
        28 => Register::DataLo_1,
        29 => Register::DataHi_1,
        30 => Register::cop0_reg30_1,
        31 => Register::cop0_reg31_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_7_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_8_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::MVPConf0,
        1 => Register::VPEConf0,
        2 => Register::TCBind,
        3 => Register::cop0_reg3_2,
        4 => Register::cop0_reg4_2,
        5 => Register::cop0_reg5_2,
        6 => Register::SRSConf1,
        7 => Register::cop0_reg7_2,
        8 => Register::cop0_reg8_2,
        9 => Register::cop0_reg9_2,
        10 => Register::cop0_reg10_2,
        11 => Register::cop0_reg11_2,
        12 => Register::SRSCtl,
        13 => Register::cop0_reg13_2,
        14 => Register::cop0_reg14_2,
        15 => Register::cop0_reg15_2,
        16 => Register::Config2,
        17 => Register::cop0_reg17_2,
        18 => Register::WatchLo_2,
        19 => Register::WatchHi_2,
        20 => Register::cop0_reg20_2,
        21 => Register::cop0_reg21_2,
        22 => Register::cop0_reg22_2,
        23 => Register::TraceControl2,
        24 => Register::cop0_reg24_2,
        25 => Register::PerfCnt_2,
        26 => Register::cop0_reg26_2,
        27 => Register::CacheErr_2,
        28 => Register::TagLo_2,
        29 => Register::TagHi_2,
        30 => Register::cop0_reg30_2,
        31 => Register::cop0_reg31_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_8_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_9_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::MVPConf1,
        1 => Register::VPEConf1,
        2 => Register::TCRestart,
        3 => Register::cop0_reg3_3,
        4 => Register::cop0_reg4_3,
        5 => Register::cop0_reg5_3,
        6 => Register::SRSConf2,
        7 => Register::cop0_reg7_3,
        8 => Register::cop0_reg8_3,
        9 => Register::cop0_reg9_3,
        10 => Register::cop0_reg10_3,
        11 => Register::cop0_reg11_3,
        12 => Register::SRSMap,
        13 => Register::cop0_reg13_3,
        14 => Register::cop0_reg14_3,
        15 => Register::cop0_reg15_3,
        16 => Register::Config3,
        17 => Register::cop0_reg17_3,
        18 => Register::WatchLo_3,
        19 => Register::WatchHi_3,
        20 => Register::cop0_reg20_3,
        21 => Register::cop0_reg21_3,
        22 => Register::cop0_reg22_3,
        23 => Register::UserTraceData,
        24 => Register::cop0_reg24_3,
        25 => Register::PerfCnt_3,
        26 => Register::cop0_reg26_3,
        27 => Register::CacheErr_3,
        28 => Register::DataLo_3,
        29 => Register::DataHi_3,
        30 => Register::cop0_reg30_3,
        31 => Register::cop0_reg31_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_9_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_10_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cop0_reg0_4,
        1 => Register::YQMask,
        2 => Register::TCHalt,
        3 => Register::cop0_reg3_4,
        4 => Register::cop0_reg4_4,
        5 => Register::cop0_reg5_4,
        6 => Register::SRSConf3,
        7 => Register::cop0_reg7_4,
        8 => Register::cop0_reg8_4,
        9 => Register::cop0_reg9_4,
        10 => Register::cop0_reg10_4,
        11 => Register::cop0_reg11_4,
        12 => Register::cop0_reg12_4,
        13 => Register::cop0_reg13_4,
        14 => Register::cop0_reg14_4,
        15 => Register::cop0_reg15_4,
        16 => Register::cop0_reg16_4,
        17 => Register::cop0_reg17_4,
        18 => Register::WatchLo_4,
        19 => Register::WatchHi_4,
        20 => Register::cop0_reg20_4,
        21 => Register::cop0_reg21_4,
        22 => Register::cop0_reg22_4,
        23 => Register::TraceBPC,
        24 => Register::cop0_reg24_4,
        25 => Register::PerfCnt_4,
        26 => Register::cop0_reg26_4,
        27 => Register::CacheErr_4,
        28 => Register::TagLo_4,
        29 => Register::TagHi_4,
        30 => Register::cop0_reg30_4,
        31 => Register::cop0_reg31_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_10_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_10_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_11_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cop0_reg0_5,
        1 => Register::VPESchedule,
        2 => Register::TCContext,
        3 => Register::cop0_reg3_5,
        4 => Register::cop0_reg4_5,
        5 => Register::cop0_reg5_5,
        6 => Register::SRSConf4,
        7 => Register::cop0_reg7_5,
        8 => Register::cop0_reg8_5,
        9 => Register::cop0_reg9_5,
        10 => Register::cop0_reg10_5,
        11 => Register::cop0_reg11_5,
        12 => Register::cop0_reg12_5,
        13 => Register::cop0_reg13_5,
        14 => Register::cop0_reg14_5,
        15 => Register::cop0_reg15_5,
        16 => Register::cop0_reg16_5,
        17 => Register::cop0_reg17_5,
        18 => Register::WatchLo_5,
        19 => Register::WatchHi_5,
        20 => Register::cop0_reg20_5,
        21 => Register::cop0_reg21_5,
        22 => Register::cop0_reg22_5,
        23 => Register::cop0_reg23_5,
        24 => Register::cop0_reg24_5,
        25 => Register::PerfCnt_5,
        26 => Register::cop0_reg26_5,
        27 => Register::CacheErr_5,
        28 => Register::DataLo_5,
        29 => Register::DataHi_5,
        30 => Register::cop0_reg30_5,
        31 => Register::cop0_reg31_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_11_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_11_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_12_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cop0_reg0_6,
        1 => Register::VPEScheFBack,
        2 => Register::TCSchedule,
        3 => Register::cop0_reg3_6,
        4 => Register::cop0_reg4_6,
        5 => Register::cop0_reg5_6,
        6 => Register::cop0_reg6_6,
        7 => Register::cop0_reg7_6,
        8 => Register::cop0_reg8_6,
        9 => Register::cop0_reg9_6,
        10 => Register::cop0_reg10_6,
        11 => Register::cop0_reg11_6,
        12 => Register::cop0_reg12_6,
        13 => Register::cop0_reg13_6,
        14 => Register::cop0_reg14_6,
        15 => Register::cop0_reg15_6,
        16 => Register::cop0_reg16_6,
        17 => Register::cop0_reg17_6,
        18 => Register::WatchLo_6,
        19 => Register::WatchHi_6,
        20 => Register::cop0_reg20_6,
        21 => Register::cop0_reg21_6,
        22 => Register::cop0_reg22_6,
        23 => Register::cop0_reg23_6,
        24 => Register::cop0_reg24_6,
        25 => Register::PerfCnt_6,
        26 => Register::cop0_reg26_6,
        27 => Register::CacheErr_6,
        28 => Register::TagLo_6,
        29 => Register::TagHi_6,
        30 => Register::cop0_reg30_6,
        31 => Register::cop0_reg31_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_12_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_12_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_13_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cop0_reg0_7,
        1 => Register::VPEOpt,
        2 => Register::TCScheFBack,
        3 => Register::cop0_reg3_7,
        4 => Register::cop0_reg4_7,
        5 => Register::cop0_reg5_7,
        6 => Register::cop0_reg6_7,
        7 => Register::cop0_reg7_7,
        8 => Register::cop0_reg8_7,
        9 => Register::cop0_reg9_7,
        10 => Register::cop0_reg10_7,
        11 => Register::cop0_reg11_7,
        12 => Register::cop0_reg12_7,
        13 => Register::cop0_reg13_7,
        14 => Register::cop0_reg14_7,
        15 => Register::cop0_reg15_7,
        16 => Register::cop0_reg16_7,
        17 => Register::cop0_reg17_7,
        18 => Register::WatchLo_7,
        19 => Register::WatchHi_7,
        20 => Register::cop0_reg20_7,
        21 => Register::cop0_reg21_7,
        22 => Register::cop0_reg22_7,
        23 => Register::cop0_reg23_7,
        24 => Register::cop0_reg24_7,
        25 => Register::PerfCnt_7,
        26 => Register::cop0_reg26_7,
        27 => Register::CacheErr_7,
        28 => Register::DataLo_7,
        29 => Register::DataHi_7,
        30 => Register::cop0_reg30_7,
        31 => Register::cop0_reg31_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_13_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_13_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_14_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::lo,
        1 => Register::lo1,
        2 => Register::lo2,
        3 => Register::lo3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_14_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_14_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_15_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::hi,
        1 => Register::hi1,
        2 => Register::hi2,
        3 => Register::hi3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_15_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_15_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_16_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::ac0,
        1 => Register::ac1,
        2 => Register::ac2,
        3 => Register::ac3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_16_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_16_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_17_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::thread_zero,
        1 => Register::thread_at,
        2 => Register::thread_v0,
        3 => Register::thread_v1,
        4 => Register::thread_a0,
        5 => Register::thread_a1,
        6 => Register::thread_a2,
        7 => Register::thread_a3,
        8 => Register::thread_t0,
        9 => Register::thread_t1,
        10 => Register::thread_t2,
        11 => Register::thread_t3,
        12 => Register::thread_t4,
        13 => Register::thread_t5,
        14 => Register::thread_t6,
        15 => Register::thread_t7,
        16 => Register::thread_s0,
        17 => Register::thread_s1,
        18 => Register::thread_s2,
        19 => Register::thread_s3,
        20 => Register::thread_s4,
        21 => Register::thread_s5,
        22 => Register::thread_s6,
        23 => Register::thread_s7,
        24 => Register::thread_t8,
        25 => Register::thread_t9,
        26 => Register::thread_k0,
        27 => Register::thread_k1,
        28 => Register::thread_gp,
        29 => Register::thread_sp,
        30 => Register::thread_s8,
        31 => Register::thread_ra,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_17_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_17_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_18_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::thread_f0,
        1 => Register::thread_f1,
        2 => Register::thread_f2,
        3 => Register::thread_f3,
        4 => Register::thread_f4,
        5 => Register::thread_f5,
        6 => Register::thread_f6,
        7 => Register::thread_f7,
        8 => Register::thread_f8,
        9 => Register::thread_f9,
        10 => Register::thread_f10,
        11 => Register::thread_f11,
        12 => Register::thread_f12,
        13 => Register::thread_f13,
        14 => Register::thread_f14,
        15 => Register::thread_f15,
        16 => Register::thread_f16,
        17 => Register::thread_f17,
        18 => Register::thread_f18,
        19 => Register::thread_f19,
        20 => Register::thread_f20,
        21 => Register::thread_f21,
        22 => Register::thread_f22,
        23 => Register::thread_f23,
        24 => Register::thread_f24,
        25 => Register::thread_f25,
        26 => Register::thread_f26,
        27 => Register::thread_f27,
        28 => Register::thread_f28,
        29 => Register::thread_f29,
        30 => Register::thread_f30,
        31 => Register::thread_f31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_18_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_18_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_19_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::thread_lo0,
        1 => Register::thread_hi0,
        2 => Register::thread_acx0,
        4 => Register::thread_lo1,
        5 => Register::thread_hi1,
        6 => Register::thread_acx1,
        8 => Register::thread_lo2,
        9 => Register::thread_hi2,
        10 => Register::thread_acx2,
        12 => Register::thread_lo3,
        13 => Register::thread_hi3,
        14 => Register::thread_acx3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_19_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_19_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_20_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::thread_fir,
        25 => Register::thread_fccr,
        26 => Register::thread_fexr,
        28 => Register::thread_fenr,
        31 => Register::thread_fcsr,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_20_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_20_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_21_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::s0,
        1 => Register::s1,
        2 => Register::v0,
        3 => Register::v1,
        4 => Register::a0,
        5 => Register::a1,
        6 => Register::a2,
        7 => Register::a3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_21_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_21_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_22_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::zero,
        1 => Register::at,
        2 => Register::v0,
        3 => Register::v1,
        4 => Register::a0,
        5 => Register::a1,
        6 => Register::a2,
        7 => Register::a3,
        8 => Register::t0,
        9 => Register::t1,
        10 => Register::t2,
        11 => Register::t3,
        12 => Register::t4,
        13 => Register::t5,
        14 => Register::t6,
        15 => Register::t7,
        16 => Register::s0,
        17 => Register::s1,
        18 => Register::s2,
        19 => Register::s3,
        20 => Register::s4,
        21 => Register::s5,
        22 => Register::s6,
        23 => Register::s7,
        24 => Register::t8,
        25 => Register::t9,
        26 => Register::k0,
        27 => Register::k1,
        28 => Register::gp,
        29 => Register::sp,
        30 => Register::s8,
        31 => Register::ra,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_22_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_22_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_23_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::s0,
        1 => Register::s1,
        2 => Register::v0,
        3 => Register::v1,
        4 => Register::a0,
        5 => Register::a1,
        6 => Register::a2,
        7 => Register::a3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_23_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_23_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_24_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::zero,
        1 => Register::at,
        2 => Register::v0,
        3 => Register::v1,
        4 => Register::a0,
        5 => Register::a1,
        6 => Register::a2,
        7 => Register::a3,
        8 => Register::t0,
        9 => Register::t1,
        10 => Register::t2,
        11 => Register::t3,
        12 => Register::t4,
        13 => Register::t5,
        14 => Register::t6,
        15 => Register::t7,
        16 => Register::s0,
        17 => Register::s1,
        18 => Register::s2,
        19 => Register::s3,
        20 => Register::s4,
        21 => Register::s5,
        22 => Register::s6,
        23 => Register::s7,
        24 => Register::t8,
        25 => Register::t9,
        26 => Register::k0,
        27 => Register::k1,
        28 => Register::gp,
        29 => Register::sp,
        30 => Register::s8,
        31 => Register::ra,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_24_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_24_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_25_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::s0,
        1 => Register::s1,
        2 => Register::v0,
        3 => Register::v1,
        4 => Register::a0,
        5 => Register::a1,
        6 => Register::a2,
        7 => Register::a3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_25_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_25_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_26_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::HW_CPUNUM,
        1 => Register::HW_SYNCI_STEP,
        2 => Register::HW_CC,
        3 => Register::HW_CCRe,
        4 => Register::HW_PerfCtr,
        5 => Register::HW_XNP,
        6 => Register::HW_RES6,
        7 => Register::HW_RES7,
        8 => Register::HW_RES8,
        9 => Register::HW_RES9,
        10 => Register::HW_RES10,
        11 => Register::HW_RES11,
        12 => Register::HW_RES12,
        13 => Register::HW_RES13,
        14 => Register::HW_RES14,
        15 => Register::HW_RES15,
        16 => Register::HW_RES16,
        17 => Register::HW_RES17,
        18 => Register::HW_RES18,
        19 => Register::HW_RES19,
        20 => Register::HW_RES20,
        21 => Register::HW_RES21,
        22 => Register::HW_RES22,
        23 => Register::HW_RES23,
        24 => Register::HW_RES24,
        25 => Register::HW_RES25,
        26 => Register::HW_RES26,
        27 => Register::HW_RES27,
        28 => Register::HW_RES28,
        29 => Register::HW_ULR,
        30 => Register::HW_RESIM30,
        31 => Register::HW_RESIM31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_26_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_26_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_27_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::s0,
        1 => Register::s1,
        2 => Register::v0,
        3 => Register::v1,
        4 => Register::a0,
        5 => Register::a1,
        6 => Register::a2,
        7 => Register::a3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_27_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_27_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_28_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::zero,
        1 => Register::at,
        2 => Register::v0,
        3 => Register::v1,
        4 => Register::a0,
        5 => Register::a1,
        6 => Register::a2,
        7 => Register::a3,
        8 => Register::t0,
        9 => Register::t1,
        10 => Register::t2,
        11 => Register::t3,
        12 => Register::t4,
        13 => Register::t5,
        14 => Register::t6,
        15 => Register::t7,
        16 => Register::s0,
        17 => Register::s1,
        18 => Register::s2,
        19 => Register::s3,
        20 => Register::s4,
        21 => Register::s5,
        22 => Register::s6,
        23 => Register::s7,
        24 => Register::t8,
        25 => Register::t9,
        26 => Register::k0,
        27 => Register::k1,
        28 => Register::gp,
        29 => Register::sp,
        30 => Register::s8,
        31 => Register::ra,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_28_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_28_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_29_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::zero,
        1 => Register::s1,
        2 => Register::v0,
        3 => Register::v1,
        4 => Register::s0,
        5 => Register::s2,
        6 => Register::s3,
        7 => Register::s4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_29_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_29_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_30_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::zero,
        1 => Register::s1,
        2 => Register::v0,
        3 => Register::v1,
        4 => Register::a0,
        5 => Register::a1,
        6 => Register::a2,
        7 => Register::a3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_30_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_30_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_31_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::a1,
        1 => Register::a1,
        2 => Register::a2,
        3 => Register::a0,
        4 => Register::a0,
        5 => Register::a0,
        6 => Register::a0,
        7 => Register::a0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_31_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_31_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_32_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::a2,
        1 => Register::a3,
        2 => Register::a3,
        3 => Register::s5,
        4 => Register::s6,
        5 => Register::a1,
        6 => Register::a2,
        7 => Register::a3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_32_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_32_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_33_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::zero,
        1 => Register::at,
        2 => Register::v0,
        3 => Register::v1,
        4 => Register::a0,
        5 => Register::a1,
        6 => Register::a2,
        7 => Register::a3,
        8 => Register::t0,
        9 => Register::t1,
        10 => Register::t2,
        11 => Register::t3,
        12 => Register::t4,
        13 => Register::t5,
        14 => Register::t6,
        15 => Register::t7,
        16 => Register::s0,
        17 => Register::s1,
        18 => Register::s2,
        19 => Register::s3,
        20 => Register::s4,
        21 => Register::s5,
        22 => Register::s6,
        23 => Register::s7,
        24 => Register::t8,
        25 => Register::t9,
        26 => Register::k0,
        27 => Register::k1,
        28 => Register::gp,
        29 => Register::sp,
        30 => Register::s8,
        31 => Register::ra,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_33_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_33_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_34_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::f0,
        1 => Register::f1,
        2 => Register::f2,
        3 => Register::f3,
        4 => Register::f4,
        5 => Register::f5,
        6 => Register::f6,
        7 => Register::f7,
        8 => Register::f8,
        9 => Register::f9,
        10 => Register::f10,
        11 => Register::f11,
        12 => Register::f12,
        13 => Register::f13,
        14 => Register::f14,
        15 => Register::f15,
        16 => Register::f16,
        17 => Register::f17,
        18 => Register::f18,
        19 => Register::f19,
        20 => Register::f20,
        21 => Register::f21,
        22 => Register::f22,
        23 => Register::f23,
        24 => Register::f24,
        25 => Register::f25,
        26 => Register::f26,
        27 => Register::f27,
        28 => Register::f28,
        29 => Register::f29,
        30 => Register::f30,
        31 => Register::f31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_34_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_34_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_35_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::f0,
        1 => Register::f1,
        2 => Register::f2,
        3 => Register::f3,
        4 => Register::f4,
        5 => Register::f5,
        6 => Register::f6,
        7 => Register::f7,
        8 => Register::f8,
        9 => Register::f9,
        10 => Register::f10,
        11 => Register::f11,
        12 => Register::f12,
        13 => Register::f13,
        14 => Register::f14,
        15 => Register::f15,
        16 => Register::f16,
        17 => Register::f17,
        18 => Register::f18,
        19 => Register::f19,
        20 => Register::f20,
        21 => Register::f21,
        22 => Register::f22,
        23 => Register::f23,
        24 => Register::f24,
        25 => Register::f25,
        26 => Register::f26,
        27 => Register::f27,
        28 => Register::f28,
        29 => Register::f29,
        30 => Register::f30,
        31 => Register::f31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_35_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_35_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_36_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("load"),
        1 => <DisplayElement>::Literal("store"),
        2 => <DisplayElement>::Literal("hint2"),
        3 => <DisplayElement>::Literal("hint3"),
        4 => <DisplayElement>::Literal("load_streamed"),
        5 => <DisplayElement>::Literal("store_streamed"),
        6 => <DisplayElement>::Literal("load_retained"),
        7 => <DisplayElement>::Literal("store_retained"),
        8 => <DisplayElement>::Literal("hint8"),
        9 => <DisplayElement>::Literal("hint9"),
        10 => <DisplayElement>::Literal("hint10"),
        11 => <DisplayElement>::Literal("hint11"),
        12 => <DisplayElement>::Literal("hint12"),
        13 => <DisplayElement>::Literal("hint13"),
        14 => <DisplayElement>::Literal("hint14"),
        15 => <DisplayElement>::Literal("hint15"),
        16 => <DisplayElement>::Literal("hint16"),
        17 => <DisplayElement>::Literal("hint17"),
        18 => <DisplayElement>::Literal("hint18"),
        19 => <DisplayElement>::Literal("hint19"),
        20 => <DisplayElement>::Literal("hint20"),
        21 => <DisplayElement>::Literal("hint21"),
        22 => <DisplayElement>::Literal("hint22"),
        23 => <DisplayElement>::Literal("hint23"),
        24 => <DisplayElement>::Literal("hint24"),
        25 => <DisplayElement>::Literal("writeback_invalidate"),
        26 => <DisplayElement>::Literal("hint26"),
        27 => <DisplayElement>::Literal("hint27"),
        28 => <DisplayElement>::Literal("hint28"),
        29 => <DisplayElement>::Literal("hint29"),
        30 => <DisplayElement>::Literal("PrepareForStore"),
        31 => <DisplayElement>::Literal("hint31"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_37_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        1 => <DisplayElement>::Literal("s0"),
        2 => <DisplayElement>::Literal("s1"),
        3 => <DisplayElement>::Literal("s0-s1"),
        4 => <DisplayElement>::Literal("s2"),
        5 => <DisplayElement>::Literal("s0,s2"),
        6 => <DisplayElement>::Literal("s1-s2"),
        7 => <DisplayElement>::Literal("s0-s2"),
        8 => <DisplayElement>::Literal("s2-s3"),
        9 => <DisplayElement>::Literal("s0,s2-s3"),
        10 => <DisplayElement>::Literal("s1-s3"),
        11 => <DisplayElement>::Literal("s0-s3"),
        12 => <DisplayElement>::Literal("s2-s4"),
        13 => <DisplayElement>::Literal("s0,s2-s4"),
        14 => <DisplayElement>::Literal("s1-s4"),
        15 => <DisplayElement>::Literal("s0-s4"),
        16 => <DisplayElement>::Literal("s2-s5"),
        17 => <DisplayElement>::Literal("s0,s2-s5"),
        18 => <DisplayElement>::Literal("s1-s5"),
        19 => <DisplayElement>::Literal("s0-s5"),
        20 => <DisplayElement>::Literal("s2-s6"),
        21 => <DisplayElement>::Literal("s0,s2-s6"),
        22 => <DisplayElement>::Literal("s1-s6"),
        23 => <DisplayElement>::Literal("s0-s6"),
        24 => <DisplayElement>::Literal("s2-s7"),
        25 => <DisplayElement>::Literal("s0,s2-s7"),
        26 => <DisplayElement>::Literal("s1-s7"),
        27 => <DisplayElement>::Literal("s0-s7"),
        28 => <DisplayElement>::Literal("s2-s8"),
        29 => <DisplayElement>::Literal("s0,s2-s8"),
        30 => <DisplayElement>::Literal("s1-s8"),
        31 => <DisplayElement>::Literal("s0-s8"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_38_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        1 => <DisplayElement>::Literal("s0"),
        2 => <DisplayElement>::Literal("s0-s1"),
        3 => <DisplayElement>::Literal("s0-s2"),
        4 => <DisplayElement>::Literal("s0-s3"),
        5 => <DisplayElement>::Literal("s0-s4"),
        6 => <DisplayElement>::Literal("s0-s5"),
        7 => <DisplayElement>::Literal("s0-s6"),
        8 => <DisplayElement>::Literal("s0-s7"),
        9 => <DisplayElement>::Literal("s0-s8"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, bool, u64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(true, false, value) => {
                write!(f, "0x{:x}", value)
            }
            Self::Number(true, true, value) => {
                write!(f, "-0x{:x}", value)
            }
            Self::Number(false, false, value) => value.fmt(f),
            Self::Number(false, true, value) => {
                write!(f, "-{:x}", value)
            }
        }
    }
}
#[doc = "Create token_fields: sa2 bp2"]
fn token_39(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 3) as u8)
}
#[doc = "Create token_fields: bigfunct simmed11"]
fn token_41(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 2047) as u16)
}
#[doc = "Create token_fields: zero2"]
fn token_35(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 15) as u8)
}
#[doc = "Create token_fields: h"]
fn token_46(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 1) as u8)
}
#[doc = "Create token_fields: mic_imm7 mic_off7 mic_soff7"]
fn token_81(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 127) as u8)
}
#[doc = "Create token_fields: mic_base4 mic_rs4 mic_rs4lo mic_rt4 mic_rt4lo mic_encrt"]
fn token_75(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 7) as u8)
}
#[doc = "Create token_fields: mic_imm6r6 mic_breakr6 micb_poolax micb_poolfx micb_spec"]
fn token_83(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 63) as u8)
}
#[doc = "Create token_fields: micb_bit12"]
fn token_102(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 12) & 1) as u8)
}
#[doc = "Create token_fields: off21"]
fn token_13(tokens: &[u8]) -> u32 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 2097151) as u32)
}
#[doc = "Create token_fields: bit5"]
fn token_45(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 1) as u8)
}
#[doc = "Create token_fields: m16_i_imm m16_ri_imm m16_rr_f m16_rri_imm m16_i8_imm m16_i8_r32 m16_i8_r32a m16_b_imm m16_tgt_2521 mic_base0 mic_rd32_0 mic_rs32_0 mic_rs32_0a mic_rs32_0b mic_rs32_0lo mic_rs32_hw mic_rt32_0 mic_fd mic_fdD mic_fs mic_fsD mic_ft_0 mic_ct mic_stype mic_impl mic_pcf mic_imm5 mic_imm5s mic_jalrr6"]
fn token_53(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 31) as u8)
}
#[doc = "Create token_fields: m16_rr_nd m16_svrs_s"]
fn token_56(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 7) & 1) as u8)
}
#[doc = "Create token_fields: copfill"]
fn token_11(tokens: &[u8]) -> u32 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 524287) as u32)
}
#[doc = "Create token_fields: zero1320"]
fn token_24(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 255) as u8)
}
#[doc = "Create token_fields: zero6"]
fn token_40(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 255) as u8)
}
#[doc = "Create token_fields: mic_rt3 mic_rt3lo"]
fn token_78(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 7) as u8)
}
#[doc = "Create token_fields: bp3 sel_0608"]
fn token_38(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 7) as u8)
}
#[doc = "Create token_fields: mic_rd7 mic_rd7lo mic_rd1lo mic_rs7 mic_rs7lo mic_rt7 mic_rt7lo mic_encrd mic_encre mic_encrt2"]
fn token_76(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 7) & 7) as u8)
}
#[doc = "Create token_fields: mic_imm4 mic_imm4s"]
fn token_84(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 1) & 15) as u8)
}
#[doc = "Create token_fields: breakcode"]
fn token_9(tokens: &[u8]) -> u32 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 1048575) as u32)
}
#[doc = "Create token_fields: mic_bit3"]
fn token_86(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 1) as u8)
}
#[doc = "Create token_fields: m16_rria_f m16_svrs_s1"]
fn token_61(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 1) as u8)
}
#[doc = "Create token_fields: micb_bit15"]
fn token_103(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 15) & 1) as u8)
}
#[doc = "Create token_fields: micb_z11"]
fn token_109(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 11) & 3) as u8)
}
#[doc = "Create token_fields: micb_sel"]
fn token_111(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 11) & 7) as u8)
}
#[doc = "Create token_fields: m16_rria_imm m16_rria_simm m16_svrs_frame mic_code4 mic_code4s mic_imm03 mic_csubr6 mic_off4"]
fn token_62(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 15) as u8)
}
#[doc = "Create token_fields: m16_rrr_f m16_shft_f mic_cp2z mic_imm01 mic_bit01"]
fn token_60(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 3) as u8)
}
#[doc = "Create token_fields: bit6"]
fn token_43(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 1) as u8)
}
#[doc = "Create token_fields: mic_off12 micb_offset12 micb_offset12s"]
fn token_87(tokens: &[u8]) -> u16 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 4095) as u16)
}
#[doc = "Create token_fields: mic_listr6 micb_fmt8"]
fn token_91(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 3) as u8)
}
#[doc = "Create token_fields: mic_imm6"]
fn token_82(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 1) & 63) as u8)
}
#[doc = "Create token_fields: micb_fmt"]
fn token_96(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 13) & 3) as u8)
}
#[doc = "Create token_fields: rs32 frD rs fr base format copop mfmc0 zero21 jsub sa_dsp2 shift21 sz"]
fn token_6(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 31) as u8)
}
#[doc = "Create token_fields: micb_sub9"]
fn token_107(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 9) & 7) as u8)
}
#[doc = "Create token_fields: micb_z67"]
fn token_110(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 3) as u8)
}
#[doc = "Create token_fields: m16_op mic_rd32_11 micb_rd32 micb_rd32lo micb_fd micb_fdD micb_size micb_sa micb_hint"]
fn token_52(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 11) & 31) as u8)
}
#[doc = "Create token_fields: mic_imm9e micb_fxf5 micb_offset9 micb_offset9s"]
fn token_80(tokens: &[u8]) -> u16 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 511) as u16)
}
#[doc = "Create token_fields: prime"]
fn token_1(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 26) & 63) as u8)
}
#[doc = "Create token_fields: off26 ind26"]
fn token_10(tokens: &[u8]) -> u32 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 67108863) as u32)
}
#[doc = "Create token_fields: mic_op"]
fn token_71(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 10) & 63) as u8)
}
#[doc = "Create token_fields: mic_off4r6"]
fn token_74(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 15) as u8)
}
#[doc = "Create token_fields: mic_rd1 mic_rs1 mic_rs1lo mic_imm3 mic_encrs mic_sa"]
fn token_77(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 1) & 7) as u8)
}
#[doc = "Create token_fields: m16_rr_ra m16_svrs_s0"]
fn token_58(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 5) & 1) as u8)
}
#[doc = "Create token_fields: szero"]
fn token_26(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 32767) as u16)
}
#[doc = "Create token_fields: aclo achi ac bp"]
fn token_30(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 3) as u8)
}
#[doc = "Create token_fields: baser6 rd32 rd rdmtdsp rd0_0 rd0_1 rd0_2 rd0_3 rd0_4 rd0_5 rd0_6 rd0_7 rd_hw cp2cprSel0 cp2cprSel1 cp2cprSel2 cp2cprSel3 cp2cprSel4 cp2cprSel5 cp2cprSel6 cp2cprSel7 fsD fs RD0thread RDthread FDthread sa_dsp fs_unk fs_fcr zero4 msbd"]
fn token_28(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 31) as u8)
}
#[doc = "Create token_fields: zero3"]
fn token_44(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 31) as u8)
}
#[doc = "Create token_fields: m16_tgt_2016 mic_index mic_rd32_5 mic_rd32_5lo mic_rs32_5 mic_rt32_5 mic_rt32_5a mic_rt32_5lo mic_fs_5 mic_fsD_5 mic_ft_5 mic_ftD_5 mic_funci mic_cop5 mic_rlist mic_imm5r6 mic_sub2 mic_jalr"]
fn token_69(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 5) & 31) as u8)
}
#[doc = "Create token_fields: m16_rx m16_rxa m16_i8_f m16_i8_svrs m16_i8_sw micb_bp8"]
fn token_54(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 7) as u8)
}
#[doc = "Create token_fields: code simmseq"]
fn token_36(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 1023) as u16)
}
#[doc = "Create token_fields: mic_code4r6 mic_csub micb_cond"]
fn token_73(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 15) as u8)
}
#[doc = "Create token_fields: op4"]
fn token_47(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 7) as u8)
}
#[doc = "Create token_fields: shift20"]
fn token_8(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 63) as u8)
}
#[doc = "Create token_fields: zero2425"]
fn token_3(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 24) & 3) as u8)
}
#[doc = "Create token_fields: cofun"]
fn token_12(tokens: &[u8]) -> u32 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 33554431) as u32)
}
#[doc = "Create token_fields: mic_ja32 micb_axf micb_code10 micb_fxf"]
fn token_89(tokens: &[u8]) -> u16 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 1023) as u16)
}
#[doc = "Create token_fields: zero1619 lohiacx"]
fn token_21(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 15) as u8)
}
#[doc = "Create token_fields: micb_flt6"]
fn token_94(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 127) as u8)
}
#[doc = "Create token_fields: m16_jal mic_bit10 micb_bit10"]
fn token_70(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 10) & 1) as u8)
}
#[doc = "Create token_fields: spec2"]
fn token_32(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 3) as u8)
}
#[doc = "Create token_fields: micb_axf3 micb_trap"]
fn token_98(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 63) as u8)
}
#[doc = "Create token_fields: mic_code mic_imm10 mic_off10 mic_soff10 micb_axf2"]
fn token_72(tokens: &[u8]) -> u16 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 1023) as u16)
}
#[doc = "Create token_fields: m16_rz m16_rza m16_shft_sa mic_cc mic_pcf2"]
fn token_59(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 2) & 7) as u8)
}
#[doc = "Create token_fields: zero1315"]
fn token_25(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 7) as u8)
}
#[doc = "Create token_fields: rt32 rt rtmtdsp RT0thread RTthread FTthread FCTthread ftD ft index hint cop1code synci cond op zero1620 FCRthread"]
fn token_20(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 31) as u8)
}
#[doc = "Create token_fields: simmed18"]
fn token_51(tokens: &[u8]) -> u32 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 262143) as u32)
}
#[doc = "Create token_fields: m16_b_z m16_code"]
fn token_66(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 5) & 63) as u8)
}
#[doc = "Create token_fields: spec3"]
fn token_33(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 7) as u8)
}
#[doc = "Create token_fields: pcrel2 cc"]
fn token_17(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 18) & 7) as u8)
}
#[doc = "Create token_fields: immed1625"]
fn token_18(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 1023) as u16)
}
#[doc = "Create token_fields: immed1623"]
fn token_19(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 255) as u8)
}
#[doc = "Create token_fields: lohiacx2"]
fn token_29(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 15) as u8)
}
#[doc = "Create token_fields: simmed9"]
fn token_34(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 511) as u16)
}
#[doc = "Create token_fields: simmed19"]
fn token_50(tokens: &[u8]) -> u32 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 524287) as u32)
}
#[doc = "Create token_fields: m16_rr_l m16_svrs_ra"]
fn token_57(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 1) as u8)
}
#[doc = "Create token_fields: m16_i8_r32_43 mic_pcz"]
fn token_65(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 3) as u8)
}
#[doc = "Create token_fields: bit25"]
fn token_2(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 1) as u8)
}
#[doc = "Create token_fields: mask"]
fn token_27(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 1023) as u16)
}
#[doc = "Create token_fields: m16_tgt_1500 micb_imm16 micb_simm16"]
fn token_68(tokens: &[u8]) -> u16 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 65535) as u16)
}
#[doc = "Create token_fields: mic_imm9 mic_imm9s"]
fn token_79(tokens: &[u8]) -> u16 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 1) & 511) as u16)
}
#[doc = "Create token_fields: mic_bit0"]
fn token_85(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 1) as u8)
}
#[doc = "Create token_fields: tf"]
fn token_23(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 1) as u8)
}
#[doc = "Create token_fields: zero2325"]
fn token_4(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 23) & 7) as u8)
}
#[doc = "Create token_fields: mic_list"]
fn token_90(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 3) as u8)
}
#[doc = "Create token_fields: micb_bp micb_fmt9 micb_sa9 micb_z9"]
fn token_93(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 9) & 3) as u8)
}
#[doc = "Create token_fields: micb_fmt14"]
fn token_95(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 14) & 1) as u8)
}
#[doc = "Create token_fields: bit21"]
fn token_15(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 1) as u8)
}
#[doc = "Create token_fields: mic_cofun micb_cofun"]
fn token_92(tokens: &[u8]) -> u16 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 8191) as u16)
}
#[doc = "Create token_fields: m16_mv_rz m16_mv_rza mic_rs0 mic_rs0lo mic_imm02 micb_cop"]
fn token_64(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 7) as u8)
}
#[doc = "Create token_fields: zero1"]
fn token_5(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 22) & 15) as u8)
}
#[doc = "Create token_fields: micb_fmt10"]
fn token_97(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 10) & 3) as u8)
}
#[doc = "Create token_fields: micb_asel micb_z68"]
fn token_99(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 7) as u8)
}
#[doc = "Create token_fields: fdD fd stype sa lsb fct2 zero5 wsbh"]
fn token_37(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 31) as u8)
}
#[doc = "Create token_fields: fct bshfl"]
fn token_42(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 63) as u8)
}
#[doc = "Create token_fields: micb_cc"]
fn token_104(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 13) & 7) as u8)
}
#[doc = "Create token_fields: micb_func12 micb_z12"]
fn token_106(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 12) & 15) as u8)
}
#[doc = "Create token_fields: nd"]
fn token_22(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 1) as u8)
}
#[doc = "Create token_fields: bit10"]
fn token_31(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 1) as u8)
}
#[doc = "Create token_fields: sel format1X"]
fn token_49(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 7) as u8)
}
#[doc = "Create token_fields: micb_bit11"]
fn token_101(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 11) & 1) as u8)
}
#[doc = "Create token_fields: off16 immed simmed"]
fn token_14(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 65535) as u16)
}
#[doc = "Create token_fields: bit3"]
fn token_48(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 1) as u8)
}
#[doc = "Create token_fields: m16_ri_z m16_ry m16_rya m16_rr_z m16_i8_rz m16_i8_r32_20 m16_cb_z"]
fn token_55(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 5) & 7) as u8)
}
#[doc = "Create token_fields: mic_break"]
fn token_88(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 63) as u8)
}
#[doc = "Create token_fields: acf acflo acfhi"]
fn token_7(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 3) as u8)
}
#[doc = "Create token_fields: micb_rs32 micb_fr micb_frD micb_rx micb_pos micb_cond2 micb_cpf"]
fn token_105(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 31) as u8)
}
#[doc = "Create token_fields: micb_z14"]
fn token_108(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 14) & 3) as u8)
}
#[doc = "Create token_fields: micb_fxf4"]
fn token_100(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 255) as u8)
}
#[doc = "Create token_fields: bitz19 pcrel"]
fn token_16(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 19) & 3) as u8)
}
#[doc = "Create token_fields: m16_is8_imm m16_iu8_imm m16_cb_off micb_fxf3"]
fn token_63(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 255) as u8)
}
#[doc = "Create token_fields: m16_b_off m16_ext_val micb_fxf2 micb_offset11 micb_offset11s"]
fn token_67(tokens: &[u8]) -> u16 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 2047) as u16)
}
#[derive(Clone, Copy, Default)]
pub struct ContextMemory(pub u32);
impl ContextMemory {
    pub fn read_PAIR_INSTRUCTION_FLAG(&self) -> u8 {
        (((self.0.reverse_bits() >> 31) & 1) as u8)
    }
    pub fn write_PAIR_INSTRUCTION_FLAG(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 31)) | ((value as u32 & 1) << 31)).reverse_bits();
    }
    pub fn read_REL6(&self) -> u8 {
        (((self.0.reverse_bits() >> 2) & 1) as u8)
    }
    pub fn write_REL6(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 2)) | ((value as u32 & 1) << 2)).reverse_bits();
    }
    pub fn read_RELP(&self) -> u8 {
        (((self.0.reverse_bits() >> 3) & 1) as u8)
    }
    pub fn write_RELP(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 3)) | ((value as u32 & 1) << 3)).reverse_bits();
    }
    pub fn read_ISA_MODE(&self) -> u8 {
        (((self.0.reverse_bits() >> 30) & 1) as u8)
    }
    pub fn write_ISA_MODE(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 30)) | ((value as u32 & 1) << 30)).reverse_bits();
    }
    pub fn read_LowBitCodeMode(&self) -> u8 {
        (((self.0.reverse_bits() >> 30) & 1) as u8)
    }
    pub fn write_LowBitCodeMode(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 30)) | ((value as u32 & 1) << 30)).reverse_bits();
    }
    pub fn read_ext_isjal(&self) -> u8 {
        (((self.0.reverse_bits() >> 29) & 1) as u8)
    }
    pub fn write_ext_isjal(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 29)) | ((value as u32 & 1) << 29)).reverse_bits();
    }
    pub fn read_ext_value(&self) -> u16 {
        (((self.0.reverse_bits() >> 18) & 2047) as u16)
    }
    pub fn write_ext_value(&mut self, value: u16) {
        self.0 = ((self.0.reverse_bits() & !(2047 << 18)) | ((value as u32 & 2047) << 18))
            .reverse_bits();
    }
    pub fn read_ext_value_select(&self) -> u8 {
        (((self.0.reverse_bits() >> 26) & 7) as u8)
    }
    pub fn write_ext_value_select(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 26)) | ((value as u32 & 7) << 26)).reverse_bits();
    }
    pub fn read_ext_value_1005(&self) -> u8 {
        (((self.0.reverse_bits() >> 23) & 63) as u8)
    }
    pub fn write_ext_value_1005(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(63 << 23)) | ((value as u32 & 63) << 23)).reverse_bits();
    }
    pub fn read_ext_value_1004(&self) -> u8 {
        (((self.0.reverse_bits() >> 22) & 127) as u8)
    }
    pub fn write_ext_value_1004(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(127 << 22)) | ((value as u32 & 127) << 22)).reverse_bits();
    }
    pub fn read_ext_value_sa40(&self) -> u8 {
        (((self.0.reverse_bits() >> 24) & 31) as u8)
    }
    pub fn write_ext_value_sa40(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 24)) | ((value as u32 & 31) << 24)).reverse_bits();
    }
    pub fn read_ext_value_xreg(&self) -> u8 {
        (((self.0.reverse_bits() >> 26) & 7) as u8)
    }
    pub fn write_ext_value_xreg(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 26)) | ((value as u32 & 7) << 26)).reverse_bits();
    }
    pub fn read_ext_value_frame(&self) -> u8 {
        (((self.0.reverse_bits() >> 22) & 15) as u8)
    }
    pub fn write_ext_value_frame(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(15 << 22)) | ((value as u32 & 15) << 22)).reverse_bits();
    }
    pub fn read_ext_value_areg(&self) -> u8 {
        (((self.0.reverse_bits() >> 18) & 15) as u8)
    }
    pub fn write_ext_value_areg(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(15 << 18)) | ((value as u32 & 15) << 18)).reverse_bits();
    }
    pub fn read_ext_value_b0(&self) -> u8 {
        (((self.0.reverse_bits() >> 18) & 1) as u8)
    }
    pub fn write_ext_value_b0(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 18)) | ((value as u32 & 1) << 18)).reverse_bits();
    }
    pub fn read_ext_value_b1(&self) -> u8 {
        (((self.0.reverse_bits() >> 19) & 1) as u8)
    }
    pub fn write_ext_value_b1(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 19)) | ((value as u32 & 1) << 19)).reverse_bits();
    }
    pub fn read_ext_value_b2(&self) -> u8 {
        (((self.0.reverse_bits() >> 20) & 1) as u8)
    }
    pub fn write_ext_value_b2(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 20)) | ((value as u32 & 1) << 20)).reverse_bits();
    }
    pub fn read_ext_value_b3(&self) -> u8 {
        (((self.0.reverse_bits() >> 21) & 1) as u8)
    }
    pub fn write_ext_value_b3(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 21)) | ((value as u32 & 1) << 21)).reverse_bits();
    }
    pub fn read_ext_value_saz(&self) -> u8 {
        (((self.0.reverse_bits() >> 18) & 63) as u8)
    }
    pub fn write_ext_value_saz(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(63 << 18)) | ((value as u32 & 63) << 18)).reverse_bits();
    }
    pub fn read_ext_value_1511(&self) -> u8 {
        (((self.0.reverse_bits() >> 18) & 31) as u8)
    }
    pub fn write_ext_value_1511(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 18)) | ((value as u32 & 31) << 18)).reverse_bits();
    }
    pub fn read_ext_value_1511s(&self) -> i8 {
        (((self.0.reverse_bits() >> 18) & 31) as i8)
    }
    pub fn write_ext_value_1511s(&mut self, value: i8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 18)) | ((value as u32 & 31) << 18)).reverse_bits();
    }
    pub fn read_ext_value_1411(&self) -> u8 {
        (((self.0.reverse_bits() >> 18) & 15) as u8)
    }
    pub fn write_ext_value_1411(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(15 << 18)) | ((value as u32 & 15) << 18)).reverse_bits();
    }
    pub fn read_ext_value_1411s(&self) -> i8 {
        (((self.0.reverse_bits() >> 18) & 15) as i8)
    }
    pub fn write_ext_value_1411s(&mut self, value: i8) {
        self.0 =
            ((self.0.reverse_bits() & !(15 << 18)) | ((value as u32 & 15) << 18)).reverse_bits();
    }
    pub fn read_ext_tgt_2521(&self) -> u8 {
        (((self.0.reverse_bits() >> 24) & 31) as u8)
    }
    pub fn write_ext_tgt_2521(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 24)) | ((value as u32 & 31) << 24)).reverse_bits();
    }
    pub fn read_ext_tgt_2016(&self) -> u8 {
        (((self.0.reverse_bits() >> 19) & 31) as u8)
    }
    pub fn write_ext_tgt_2016(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 19)) | ((value as u32 & 31) << 19)).reverse_bits();
    }
    pub fn read_ext_tgt_x(&self) -> u8 {
        (((self.0.reverse_bits() >> 18) & 1) as u8)
    }
    pub fn write_ext_tgt_x(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 18)) | ((value as u32 & 1) << 18)).reverse_bits();
    }
    pub fn read_ext_is_ext(&self) -> u8 {
        (((self.0.reverse_bits() >> 17) & 1) as u8)
    }
    pub fn write_ext_is_ext(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 17)) | ((value as u32 & 1) << 17)).reverse_bits();
    }
    pub fn read_ext_m16r32(&self) -> u8 {
        (((self.0.reverse_bits() >> 12) & 31) as u8)
    }
    pub fn write_ext_m16r32(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 12)) | ((value as u32 & 31) << 12)).reverse_bits();
    }
    pub fn read_ext_m16r32a(&self) -> u8 {
        (((self.0.reverse_bits() >> 12) & 31) as u8)
    }
    pub fn write_ext_m16r32a(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 12)) | ((value as u32 & 31) << 12)).reverse_bits();
    }
    pub fn read_ext_reg_high(&self) -> u8 {
        (((self.0.reverse_bits() >> 15) & 3) as u8)
    }
    pub fn write_ext_reg_high(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(3 << 15)) | ((value as u32 & 3) << 15)).reverse_bits();
    }
    pub fn read_ext_reg_low(&self) -> u8 {
        (((self.0.reverse_bits() >> 12) & 7) as u8)
    }
    pub fn write_ext_reg_low(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 12)) | ((value as u32 & 7) << 12)).reverse_bits();
    }
    pub fn read_ext_svrs_sreg(&self) -> u8 {
        (((self.0.reverse_bits() >> 7) & 31) as u8)
    }
    pub fn write_ext_svrs_sreg(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(31 << 7)) | ((value as u32 & 31) << 7)).reverse_bits();
    }
    pub fn read_ext_svrs_xs(&self) -> u8 {
        (((self.0.reverse_bits() >> 9) & 7) as u8)
    }
    pub fn write_ext_svrs_xs(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 9)) | ((value as u32 & 7) << 9)).reverse_bits();
    }
    pub fn read_ext_svrs_s1(&self) -> u8 {
        (((self.0.reverse_bits() >> 8) & 1) as u8)
    }
    pub fn write_ext_svrs_s1(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 8)) | ((value as u32 & 1) << 8)).reverse_bits();
    }
    pub fn read_ext_svrs_s0(&self) -> u8 {
        (((self.0.reverse_bits() >> 7) & 1) as u8)
    }
    pub fn write_ext_svrs_s0(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 7)) | ((value as u32 & 1) << 7)).reverse_bits();
    }
    pub fn read_ext_done(&self) -> u8 {
        (((self.0.reverse_bits() >> 6) & 1) as u8)
    }
    pub fn write_ext_done(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 6)) | ((value as u32 & 1) << 6)).reverse_bits();
    }
    pub fn read_ext_delay(&self) -> u8 {
        (((self.0.reverse_bits() >> 4) & 3) as u8)
    }
    pub fn write_ext_delay(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(3 << 4)) | ((value as u32 & 3) << 4)).reverse_bits();
    }
    pub fn read_ext_t4_name(&self) -> u8 {
        (((self.0.reverse_bits() >> 26) & 15) as u8)
    }
    pub fn write_ext_t4_name(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(15 << 26)) | ((value as u32 & 15) << 26)).reverse_bits();
    }
    pub fn read_ext_t4(&self) -> u8 {
        (((self.0.reverse_bits() >> 26) & 15) as u8)
    }
    pub fn write_ext_t4(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(15 << 26)) | ((value as u32 & 15) << 26)).reverse_bits();
    }
    pub fn read_ext_tra(&self) -> u8 {
        (((self.0.reverse_bits() >> 25) & 1) as u8)
    }
    pub fn write_ext_tra(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 25)) | ((value as u32 & 1) << 25)).reverse_bits();
    }
    pub fn read_ext_32_code(&self) -> u16 {
        (((self.0.reverse_bits() >> 15) & 1023) as u16)
    }
    pub fn write_ext_32_code(&mut self, value: u16) {
        self.0 = ((self.0.reverse_bits() & !(1023 << 15)) | ((value as u32 & 1023) << 15))
            .reverse_bits();
    }
    pub fn read_ext_32_codes(&self) -> i16 {
        (((self.0.reverse_bits() >> 15) & 1023) as i16)
    }
    pub fn write_ext_32_codes(&mut self, value: i16) {
        self.0 = ((self.0.reverse_bits() & !(1023 << 15)) | ((value as u32 & 1023) << 15))
            .reverse_bits();
    }
    pub fn read_ext_32_addim(&self) -> u8 {
        (((self.0.reverse_bits() >> 15) & 127) as u8)
    }
    pub fn write_ext_32_addim(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(127 << 15)) | ((value as u32 & 127) << 15)).reverse_bits();
    }
    pub fn read_ext_32_addims(&self) -> i8 {
        (((self.0.reverse_bits() >> 15) & 127) as i8)
    }
    pub fn write_ext_32_addims(&mut self, value: i8) {
        self.0 =
            ((self.0.reverse_bits() & !(127 << 15)) | ((value as u32 & 127) << 15)).reverse_bits();
    }
    pub fn read_ext_32_imm2(&self) -> u8 {
        (((self.0.reverse_bits() >> 15) & 3) as u8)
    }
    pub fn write_ext_32_imm2(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(3 << 15)) | ((value as u32 & 3) << 15)).reverse_bits();
    }
    pub fn read_ext_32_imm2s(&self) -> i8 {
        (((self.0.reverse_bits() >> 15) & 3) as i8)
    }
    pub fn write_ext_32_imm2s(&mut self, value: i8) {
        self.0 = ((self.0.reverse_bits() & !(3 << 15)) | ((value as u32 & 3) << 15)).reverse_bits();
    }
    pub fn read_ext_32_imm3(&self) -> u8 {
        (((self.0.reverse_bits() >> 15) & 7) as u8)
    }
    pub fn write_ext_32_imm3(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 15)) | ((value as u32 & 7) << 15)).reverse_bits();
    }
    pub fn read_ext_32_imm3s(&self) -> i8 {
        (((self.0.reverse_bits() >> 15) & 7) as i8)
    }
    pub fn write_ext_32_imm3s(&mut self, value: i8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 15)) | ((value as u32 & 7) << 15)).reverse_bits();
    }
    pub fn read_ext_32_imm5(&self) -> u8 {
        (((self.0.reverse_bits() >> 15) & 31) as u8)
    }
    pub fn write_ext_32_imm5(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 15)) | ((value as u32 & 31) << 15)).reverse_bits();
    }
    pub fn read_ext_32_imm5s(&self) -> i8 {
        (((self.0.reverse_bits() >> 15) & 31) as i8)
    }
    pub fn write_ext_32_imm5s(&mut self, value: i8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 15)) | ((value as u32 & 31) << 15)).reverse_bits();
    }
    pub fn read_ext_32_imm6(&self) -> u8 {
        (((self.0.reverse_bits() >> 15) & 63) as u8)
    }
    pub fn write_ext_32_imm6(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(63 << 15)) | ((value as u32 & 63) << 15)).reverse_bits();
    }
    pub fn read_ext_32_rlist(&self) -> u8 {
        (((self.0.reverse_bits() >> 20) & 31) as u8)
    }
    pub fn write_ext_32_rlist(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 20)) | ((value as u32 & 31) << 20)).reverse_bits();
    }
    pub fn read_ext_32_base(&self) -> u8 {
        (((self.0.reverse_bits() >> 15) & 31) as u8)
    }
    pub fn write_ext_32_base(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 15)) | ((value as u32 & 31) << 15)).reverse_bits();
    }
    pub fn read_ext_32_basea(&self) -> u8 {
        (((self.0.reverse_bits() >> 15) & 31) as u8)
    }
    pub fn write_ext_32_basea(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 15)) | ((value as u32 & 31) << 15)).reverse_bits();
    }
    pub fn read_ext_32_rd(&self) -> u8 {
        (((self.0.reverse_bits() >> 20) & 31) as u8)
    }
    pub fn write_ext_32_rd(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 20)) | ((value as u32 & 31) << 20)).reverse_bits();
    }
    pub fn read_ext_32_rdset(&self) -> u8 {
        (((self.0.reverse_bits() >> 20) & 31) as u8)
    }
    pub fn write_ext_32_rdset(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 20)) | ((value as u32 & 31) << 20)).reverse_bits();
    }
    pub fn read_ext_32_rs1(&self) -> u8 {
        (((self.0.reverse_bits() >> 20) & 31) as u8)
    }
    pub fn write_ext_32_rs1(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 20)) | ((value as u32 & 31) << 20)).reverse_bits();
    }
    pub fn read_ext_32_rs1lo(&self) -> u8 {
        (((self.0.reverse_bits() >> 20) & 31) as u8)
    }
    pub fn write_ext_32_rs1lo(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 20)) | ((value as u32 & 31) << 20)).reverse_bits();
    }
    pub fn read_ext_32_rs1set(&self) -> u8 {
        (((self.0.reverse_bits() >> 20) & 31) as u8)
    }
    pub fn write_ext_32_rs1set(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 20)) | ((value as u32 & 31) << 20)).reverse_bits();
    }
    pub fn read_ext_16_rs(&self) -> u8 {
        (((self.0.reverse_bits() >> 22) & 7) as u8)
    }
    pub fn write_ext_16_rs(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 22)) | ((value as u32 & 7) << 22)).reverse_bits();
    }
    pub fn read_ext_16_rslo(&self) -> u8 {
        (((self.0.reverse_bits() >> 23) & 3) as u8)
    }
    pub fn write_ext_16_rslo(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(3 << 23)) | ((value as u32 & 3) << 23)).reverse_bits();
    }
    pub fn read_ext_16_rshi(&self) -> u8 {
        (((self.0.reverse_bits() >> 22) & 1) as u8)
    }
    pub fn write_ext_16_rshi(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 22)) | ((value as u32 & 1) << 22)).reverse_bits();
    }
    pub fn read_ext_off16_s(&self) -> i16 {
        (((self.0.reverse_bits() >> 9) & 65535) as i16)
    }
    pub fn write_ext_off16_s(&mut self, value: i16) {
        self.0 = ((self.0.reverse_bits() & !(65535 << 9)) | ((value as u32 & 65535) << 9))
            .reverse_bits();
    }
    pub fn read_ext_off16_u(&self) -> u16 {
        (((self.0.reverse_bits() >> 9) & 65535) as u16)
    }
    pub fn write_ext_off16_u(&mut self, value: u16) {
        self.0 = ((self.0.reverse_bits() & !(65535 << 9)) | ((value as u32 & 65535) << 9))
            .reverse_bits();
    }
}
#[derive(Clone)]
pub struct GlobalSet {
    default: ContextMemory,
    branches: std::collections::HashMap<AddrType, ContextMemory>,
}
impl GlobalSet {
    pub fn new(default: ContextMemory) -> Self {
        Self {
            default,
            branches: std::collections::HashMap::new(),
        }
    }
    pub fn set(&mut self, address: Option<AddrType>, set: impl FnOnce(&mut ContextMemory)) {
        let Some (address) = address else { return } ;
        let entry = self
            .branches
            .entry(address)
            .or_insert_with(|| self.default.clone());
        set(entry);
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:342:1, end:342:2))"]
#[derive(Clone, Debug)]
struct jr_instructionVar0 {}
impl jr_instructionVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jr"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::ra),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c59 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    if token_42(tokens) != 8 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c59(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c59 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    if token_42(tokens) != 9 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c59(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c58(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:853:1, end:853:2))"]
#[derive(Clone, Debug)]
struct bal_instructionVar1 {
    Rel16: TableRel16,
}
impl bal_instructionVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bal"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1431:1, end:1431:2))"]
#[derive(Clone, Debug)]
struct bal_instructionVar2 {
    Rel16: TableRel16,
}
impl bal_instructionVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bal"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1628:1, end:1628:2))"]
#[derive(Clone, Debug)]
struct jic_instructionVar3 {
    simmed: u16,
    RTsrc: TableRTsrc,
}
impl jic_instructionVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jic"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:802:1, end:802:2))"]
#[derive(Clone, Debug)]
struct deret_instructionVar4 {}
impl deret_instructionVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("deret"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:819:1, end:819:2))"]
#[derive(Clone, Debug)]
struct ehb_instructionVar5 {}
impl ehb_instructionVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ehb"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:827:1, end:827:2))"]
#[derive(Clone, Debug)]
struct eret_instructionVar6 {}
impl eret_instructionVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eret"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:829:1, end:829:2))"]
#[derive(Clone, Debug)]
struct eretnc_instructionVar7 {}
impl eretnc_instructionVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eretnc"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1171:1, end:1171:2))"]
#[derive(Clone, Debug)]
struct nop_instructionVar8 {}
impl nop_instructionVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nop"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1195:1, end:1195:2))"]
#[derive(Clone, Debug)]
struct pause_instructionVar9 {}
impl pause_instructionVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pause"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1434:1, end:1434:2))"]
#[derive(Clone, Debug)]
struct ssnop_instructionVar10 {}
impl ssnop_instructionVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ssnop"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1562:1, end:1562:2))"]
#[derive(Clone, Debug)]
struct tlbinv_instructionVar11 {}
impl tlbinv_instructionVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbinv"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1566:1, end:1566:2))"]
#[derive(Clone, Debug)]
struct tlbinvf_instructionVar12 {}
impl tlbinvf_instructionVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbinvf"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1570:1, end:1570:2))"]
#[derive(Clone, Debug)]
struct tlbp_instructionVar13 {}
impl tlbp_instructionVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbp"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1574:1, end:1574:2))"]
#[derive(Clone, Debug)]
struct tlbr_instructionVar14 {}
impl tlbr_instructionVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbr"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1578:1, end:1578:2))"]
#[derive(Clone, Debug)]
struct tlbwi_instructionVar15 {}
impl tlbwi_instructionVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbwi"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1582:1, end:1582:2))"]
#[derive(Clone, Debug)]
struct tlbwr_instructionVar16 {}
impl tlbwr_instructionVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbwr"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:159:1, end:159:2))"]
#[derive(Clone, Debug)]
struct deret_instructionVar17 {}
impl deret_instructionVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("deret"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:164:1, end:164:2))"]
#[derive(Clone, Debug)]
struct di_instructionVar18 {}
impl di_instructionVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("di"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:174:1, end:174:2))"]
#[derive(Clone, Debug)]
struct ehb_instructionVar19 {}
impl ehb_instructionVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ehb"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:178:1, end:178:2))"]
#[derive(Clone, Debug)]
struct ei_instructionVar20 {}
impl ei_instructionVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ei"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:189:1, end:189:2))"]
#[derive(Clone, Debug)]
struct rfe_instructionVar21 {}
impl rfe_instructionVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rfe"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:195:1, end:195:2))"]
#[derive(Clone, Debug)]
struct eret_instructionVar22 {}
impl eret_instructionVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eret"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:199:1, end:199:2))"]
#[derive(Clone, Debug)]
struct eretnc_instructionVar23 {}
impl eretnc_instructionVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eretnc"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:482:1, end:482:2))"]
#[derive(Clone, Debug)]
struct nop_instructionVar24 {}
impl nop_instructionVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nop"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:498:1, end:498:2))"]
#[derive(Clone, Debug)]
struct pause_instructionVar25 {}
impl pause_instructionVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pause"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:652:1, end:652:2))"]
#[derive(Clone, Debug)]
struct ssnop_instructionVar26 {}
impl ssnop_instructionVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ssnop"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:726:1, end:726:2))"]
#[derive(Clone, Debug)]
struct tlbinv_instructionVar27 {}
impl tlbinv_instructionVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbinv"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:730:1, end:730:2))"]
#[derive(Clone, Debug)]
struct tlbinvf_instructionVar28 {}
impl tlbinvf_instructionVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbinvf"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:734:1, end:734:2))"]
#[derive(Clone, Debug)]
struct tlbp_instructionVar29 {}
impl tlbp_instructionVar29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbp"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:738:1, end:738:2))"]
#[derive(Clone, Debug)]
struct tlbr_instructionVar30 {}
impl tlbr_instructionVar30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbr"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:745:1, end:745:2))"]
#[derive(Clone, Debug)]
struct tlbwi_instructionVar31 {}
impl tlbwi_instructionVar31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbwi"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:749:1, end:749:2))"]
#[derive(Clone, Debug)]
struct tlbwr_instructionVar32 {}
impl tlbwr_instructionVar32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbwr"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1146:1, end:1146:2))"]
#[derive(Clone, Debug)]
struct mfhi_instructionVar33 {
    RD: TableRD,
}
impl mfhi_instructionVar33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfhi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let acfhi = token_7(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1151:1, end:1151:2))"]
#[derive(Clone, Debug)]
struct mflo_instructionVar34 {
    RD: TableRD,
}
impl mflo_instructionVar34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mflo"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let acflo = token_7(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:122:1, end:122:2))"]
#[derive(Clone, Debug)]
struct clear_instructionVar35 {
    RD: TableRD,
}
impl clear_instructionVar35 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clear"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1603:1, end:1603:2))"]
#[derive(Clone, Debug)]
struct dvp_instructionVar36 {
    RT: TableRT,
    RD0: TableRD0,
}
impl dvp_instructionVar36 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dvp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD0 = if let Some((len, table)) =
            TableRD0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, RD0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1607:1, end:1607:2))"]
#[derive(Clone, Debug)]
struct evp_instructionVar37 {
    RD0: TableRD0,
    RT: TableRT,
}
impl evp_instructionVar37 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("evp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD0 = if let Some((len, table)) =
            TableRD0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD0, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:168:1, end:168:2))"]
#[derive(Clone, Debug)]
struct di_instructionVar38 {
    RT: TableRT,
}
impl di_instructionVar38 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("di"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:182:1, end:182:2))"]
#[derive(Clone, Debug)]
struct ei_instructionVar39 {
    RT: TableRT,
}
impl ei_instructionVar39 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ei"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:511:1, end:511:2))"]
#[derive(Clone, Debug)]
struct rdhwr_instructionVar40 {
    rd_hw: u8,
    RT: TableRT,
}
impl rdhwr_instructionVar40 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdhwr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_1_display(self.rd_hw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_28(tokens_current) == 4 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd_hw = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, rd_hw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:815:1, end:815:2))"]
#[derive(Clone, Debug)]
struct clear_instructionVar41 {
    RD: TableRD,
}
impl clear_instructionVar41 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clear"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1570:1, end:1570:2))"]
#[derive(Clone, Debug)]
struct bitswap_instructionVar42 {
    RT32src: TableRT32src,
    RD: TableRD,
}
impl bitswap_instructionVar42 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bitswap"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT32src, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:67:1, end:67:2))"]
#[derive(Clone, Debug)]
struct cfc1_instructionVar43 {
    fs_fcr: u8,
    RT: TableRT,
}
impl cfc1_instructionVar43 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cfc1"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fs_fcr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c82 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_28(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                if token_28(tokens_param) == 25 {
                    return Some(((), (), 4));
                }
                if token_28(tokens_param) == 26 {
                    return Some(((), (), 4));
                }
                if token_28(tokens_param) == 28 {
                    return Some(((), (), 4));
                }
                if token_28(tokens_param) == 31 {
                    return Some(((), (), 4));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c82(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let fs_fcr = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, fs_fcr }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:93:1, end:93:2))"]
#[derive(Clone, Debug)]
struct ctc1_instructionVar44 {
    fs_fcr: u8,
    RTsrc: TableRTsrc,
}
impl ctc1_instructionVar44 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ctc1"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fs_fcr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c85 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_28(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                if token_28(tokens_param) == 25 {
                    return Some(((), (), 4));
                }
                if token_28(tokens_param) == 26 {
                    return Some(((), (), 4));
                }
                if token_28(tokens_param) == 28 {
                    return Some(((), (), 4));
                }
                if token_28(tokens_param) == 31 {
                    return Some(((), (), 4));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c85(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let fs_fcr = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, fs_fcr }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:992:1, end:992:2))"]
#[derive(Clone, Debug)]
struct rddsp_instructionVar45 {
    RD: TableRD,
}
impl rddsp_instructionVar45 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rddsp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:110:1, end:110:2))"]
#[derive(Clone, Debug)]
struct cfc0_instructionVar46 {
    RT: TableRT,
    RD0: TableRD0,
}
impl cfc0_instructionVar46 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cfc0"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RD0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD0 = if let Some((len, table)) =
            TableRD0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, RD0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:150:1, end:150:2))"]
#[derive(Clone, Debug)]
struct ctc0_instructionVar47 {
    RTsrc: TableRTsrc,
    RD0: TableRD0,
}
impl ctc0_instructionVar47 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ctc0"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RD0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD0 = if let Some((len, table)) =
            TableRD0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:445:1, end:445:2))"]
#[derive(Clone, Debug)]
struct move_instructionVar48 {
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl move_instructionVar48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1195:1, end:1195:2))"]
#[derive(Clone, Debug)]
struct mthi_instructionVar49 {
    RSsrc: TableRSsrc,
}
impl mthi_instructionVar49 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mthi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let achi = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1200:1, end:1200:2))"]
#[derive(Clone, Debug)]
struct mtlo_instructionVar50 {
    RSsrc: TableRSsrc,
}
impl mtlo_instructionVar50 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtlo"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let aclo = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1575:1, end:1575:2))"]
#[derive(Clone, Debug)]
struct clo_instructionVar51 {
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl clo_instructionVar51 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clo"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1579:1, end:1579:2))"]
#[derive(Clone, Debug)]
struct clz_instructionVar52 {
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl clz_instructionVar52 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:675:1, end:675:2))"]
#[derive(Clone, Debug)]
struct mfhi_instructionVar53 {
    acfhi: u8,
    RD: TableRD,
}
impl mfhi_instructionVar53 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfhi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_15_display(self.acfhi),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let acfhi = token_7(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, acfhi }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:681:1, end:681:2))"]
#[derive(Clone, Debug)]
struct mflo_instructionVar54 {
    acflo: u8,
    RD: TableRD,
}
impl mflo_instructionVar54 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mflo"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_14_display(self.acflo),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let acflo = token_7(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, acflo }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1240:1, end:1240:2))"]
#[derive(Clone, Debug)]
struct wrdsp_instructionVar55 {
    RSsrc: TableRSsrc,
}
impl wrdsp_instructionVar55 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrdsp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:715:1, end:715:2))"]
#[derive(Clone, Debug)]
struct mthi_instructionVar56 {
    achi: u8,
    RS: TableRS,
}
impl mthi_instructionVar56 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mthi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_15_display(self.achi),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS = if let Some((len, table)) =
            TableRS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let achi = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS, achi }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:721:1, end:721:2))"]
#[derive(Clone, Debug)]
struct mthlip_instructionVar57 {
    ac: u8,
    RS: TableRS,
}
impl mthlip_instructionVar57 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mthlip"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS = if let Some((len, table)) =
            TableRS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        let aclo = token_30(tokens_current);
        let achi = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:729:1, end:729:2))"]
#[derive(Clone, Debug)]
struct mtlo_instructionVar58 {
    aclo: u8,
    RS: TableRS,
}
impl mtlo_instructionVar58 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtlo"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_14_display(self.aclo),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS = if let Some((len, table)) =
            TableRS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let aclo = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS, aclo }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1032:1, end:1032:2))"]
#[derive(Clone, Debug)]
struct shilov_instructionVar59 {
    ac: u8,
    RSsrc: TableRSsrc,
}
impl shilov_instructionVar59 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shilov"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:450:1, end:450:2))"]
#[derive(Clone, Debug)]
struct move_instructionVar60 {
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl move_instructionVar60 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:521:1, end:521:2))"]
#[derive(Clone, Debug)]
struct rdpgpr_instructionVar61 {
    RD: TableRD,
    RT: TableRT,
}
impl rdpgpr_instructionVar61 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdpgpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:572:1, end:572:2))"]
#[derive(Clone, Debug)]
struct seb_instructionVar62 {
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl seb_instructionVar62 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("seb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:576:1, end:576:2))"]
#[derive(Clone, Debug)]
struct seh_instructionVar63 {
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl seh_instructionVar63 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("seh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:782:1, end:782:2))"]
#[derive(Clone, Debug)]
struct wrpgpr_instructionVar64 {
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl wrpgpr_instructionVar64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrpgpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:787:1, end:787:2))"]
#[derive(Clone, Debug)]
struct wsbh_instructionVar65 {
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl wsbh_instructionVar65 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wsbh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:993:1, end:993:2))"]
#[derive(Clone, Debug)]
struct div_instructionVar66 {
    RT32src: TableRT32src,
    RS32src: TableRS32src,
}
impl div_instructionVar66 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("div"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT32src, RS32src }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:998:1, end:998:2))"]
#[derive(Clone, Debug)]
struct divu_instructionVar67 {
    RS32src: TableRS32src,
    RT32src: TableRT32src,
}
impl divu_instructionVar67 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS32src, RT32src }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1122:1, end:1122:2))"]
#[derive(Clone, Debug)]
struct madd_instructionVar68 {
    RS32src: TableRS32src,
    RT32src: TableRT32src,
}
impl madd_instructionVar68 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("madd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let aclo = token_30(tokens_current);
        let achi = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS32src, RT32src }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1134:1, end:1134:2))"]
#[derive(Clone, Debug)]
struct maddu_instructionVar69 {
    RS32src: TableRS32src,
    RT32src: TableRT32src,
}
impl maddu_instructionVar69 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maddu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let aclo = token_30(tokens_current);
        let achi = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS32src, RT32src }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1183:1, end:1183:2))"]
#[derive(Clone, Debug)]
struct msubu_instructionVar70 {
    RT32src: TableRT32src,
    RS32src: TableRS32src,
}
impl msubu_instructionVar70 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msubu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let aclo = token_30(tokens_current);
        let achi = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT32src, RS32src }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1171:1, end:1171:2))"]
#[derive(Clone, Debug)]
struct msub_instructionVar71 {
    RS32src: TableRS32src,
    RT32src: TableRT32src,
}
impl msub_instructionVar71 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let aclo = token_30(tokens_current);
        let achi = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS32src, RT32src }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1213:1, end:1213:2))"]
#[derive(Clone, Debug)]
struct mult_instructionVar72 {
    RS32src: TableRS32src,
    RT32src: TableRT32src,
}
impl mult_instructionVar72 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mult"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let achi = token_30(tokens_current);
        let aclo = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS32src, RT32src }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1223:1, end:1223:2))"]
#[derive(Clone, Debug)]
struct multu_instructionVar73 {
    RS32src: TableRS32src,
    RT32src: TableRT32src,
}
impl multu_instructionVar73 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("multu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let aclo = token_30(tokens_current);
        let achi = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS32src, RT32src }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:725:1, end:725:2))"]
#[derive(Clone, Debug)]
struct movf_instructionVar74 {
    cc: u8,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl movf_instructionVar74 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movf"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cc = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:768:1, end:768:2))"]
#[derive(Clone, Debug)]
struct movt_instructionVar75 {
    cc: u8,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl movt_instructionVar75 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movt"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cc = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:981:1, end:981:2))"]
#[derive(Clone, Debug)]
struct clo_instructionVar76 {
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl clo_instructionVar76 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clo"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:987:1, end:987:2))"]
#[derive(Clone, Debug)]
struct clz_instructionVar77 {
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl clz_instructionVar77 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1156:1, end:1156:2))"]
#[derive(Clone, Debug)]
struct movn_instructionVar78 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl movn_instructionVar78 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movn"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1163:1, end:1163:2))"]
#[derive(Clone, Debug)]
struct movz_instructionVar79 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl movz_instructionVar79 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1205:1, end:1205:2))"]
#[derive(Clone, Debug)]
struct mul_instructionVar80 {
    RS32src: TableRS32src,
    RT32src: TableRT32src,
    RD: TableRD,
}
impl mul_instructionVar80 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS32src,
                RT32src,
                RD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1583:1, end:1583:2))"]
#[derive(Clone, Debug)]
struct div_instructionVar81 {
    RS32src: TableRS32src,
    RD: TableRD,
    RT32src: TableRT32src,
}
impl div_instructionVar81 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("div"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS32src,
                RD,
                RT32src,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1588:1, end:1588:2))"]
#[derive(Clone, Debug)]
struct mod_instructionVar82 {
    RT32src: TableRT32src,
    RS32src: TableRS32src,
    RD: TableRD,
}
impl mod_instructionVar82 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mod"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32src,
                RS32src,
                RD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1593:1, end:1593:2))"]
#[derive(Clone, Debug)]
struct divu_instructionVar83 {
    RD: TableRD,
    RT32src: TableRT32src,
    RS32src: TableRS32src,
}
impl divu_instructionVar83 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD,
                RT32src,
                RS32src,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1598:1, end:1598:2))"]
#[derive(Clone, Debug)]
struct modu_instructionVar84 {
    RS32src: TableRS32src,
    RT32src: TableRT32src,
    RD: TableRD,
}
impl modu_instructionVar84 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("modu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS32src,
                RT32src,
                RD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1678:1, end:1678:2))"]
#[derive(Clone, Debug)]
struct mul_instructionVar85 {
    RT32src: TableRT32src,
    RS32src: TableRS32src,
    RD: TableRD,
}
impl mul_instructionVar85 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32src,
                RS32src,
                RD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1686:1, end:1686:2))"]
#[derive(Clone, Debug)]
struct muh_instructionVar86 {
    RT32src: TableRT32src,
    RD: TableRD,
    RS32src: TableRS32src,
}
impl muh_instructionVar86 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("muh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32src,
                RD,
                RS32src,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1694:1, end:1694:2))"]
#[derive(Clone, Debug)]
struct mulu_instructionVar87 {
    RS32src: TableRS32src,
    RD: TableRD,
    RT32src: TableRT32src,
}
impl mulu_instructionVar87 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS32src,
                RD,
                RT32src,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1702:1, end:1702:2))"]
#[derive(Clone, Debug)]
struct muhu_instructionVar88 {
    RS32src: TableRS32src,
    RT32src: TableRT32src,
    RD: TableRD,
}
impl muhu_instructionVar88 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("muhu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS32src,
                RT32src,
                RD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1719:1, end:1719:2))"]
#[derive(Clone, Debug)]
struct seleqz_instructionVar89 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl seleqz_instructionVar89 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("seleqz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1729:1, end:1729:2))"]
#[derive(Clone, Debug)]
struct selnez_instructionVar90 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl selnez_instructionVar90 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("selnez"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:63:1, end:63:2))"]
#[derive(Clone, Debug)]
struct cfc1_instructionVar91 {
    fs_unk: u8,
    RT: TableRT,
}
impl cfc1_instructionVar91 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cfc1"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.fs_unk as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs_unk = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, fs_unk }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:90:1, end:90:2))"]
#[derive(Clone, Debug)]
struct ctc1_instructionVar92 {
    fs_unk: u8,
    RTsrc: TableRTsrc,
}
impl ctc1_instructionVar92 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ctc1"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.fs_unk as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs_unk = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, fs_unk }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:237:1, end:237:2))"]
#[derive(Clone, Debug)]
struct mfc1_instructionVar93 {
    fs: u8,
    RT: TableRT,
}
impl mfc1_instructionVar93 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfc1"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:243:1, end:243:2))"]
#[derive(Clone, Debug)]
struct mfhc1_instructionVar94 {
    fs: u8,
    RT: TableRT,
}
impl mfhc1_instructionVar94 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfhc1"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:259:1, end:259:2))"]
#[derive(Clone, Debug)]
struct mtc1_instructionVar95 {
    fs: u8,
    RTsrc: TableRTsrc,
}
impl mtc1_instructionVar95 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtc1"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:265:1, end:265:2))"]
#[derive(Clone, Debug)]
struct mthc1_instructionVar96 {
    fs: u8,
    RTsrc: TableRTsrc,
}
impl mthc1_instructionVar96 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mthc1"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:446:1, end:446:2))"]
#[derive(Clone, Debug)]
struct prefx_instructionVar97 {
    hint: u8,
    INDEX_BASE: TableINDEX_BASE,
}
impl prefx_instructionVar97 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("prefx"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_36_display(self.hint),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.INDEX_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let INDEX_BASE = if let Some((len, table)) =
            TableINDEX_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let hint = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { INDEX_BASE, hint }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:450:1, end:450:2))"]
#[derive(Clone, Debug)]
struct sdxc1_instructionVar98 {
    fs: u8,
    INDEX_BASE: TableINDEX_BASE,
}
impl sdxc1_instructionVar98 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdxc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.INDEX_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let INDEX_BASE = if let Some((len, table)) =
            TableINDEX_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { INDEX_BASE, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:459:1, end:459:2))"]
#[derive(Clone, Debug)]
struct swxc1_instructionVar99 {
    fs: u8,
    INDEX_BASE: TableINDEX_BASE,
}
impl swxc1_instructionVar99 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swxc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.INDEX_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let INDEX_BASE = if let Some((len, table)) =
            TableINDEX_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { INDEX_BASE, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:98:1, end:98:2))"]
#[derive(Clone, Debug)]
struct absq_s_ph_instructionVar100 {
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl absq_s_ph_instructionVar100 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("absq_s.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:104:1, end:104:2))"]
#[derive(Clone, Debug)]
struct absq_s_qb_instructionVar101 {
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl absq_s_qb_instructionVar101 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("absq_s.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:110:1, end:110:2))"]
#[derive(Clone, Debug)]
struct absq_s_w_instructionVar102 {
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl absq_s_w_instructionVar102 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("absq_s.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:229:1, end:229:2))"]
#[derive(Clone, Debug)]
struct cmp_eq_ph_instructionVar103 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl cmp_eq_ph_instructionVar103 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.eq.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:240:1, end:240:2))"]
#[derive(Clone, Debug)]
struct cmp_lt_ph_instructionVar104 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl cmp_lt_ph_instructionVar104 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.lt.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:251:1, end:251:2))"]
#[derive(Clone, Debug)]
struct cmp_le_ph_instructionVar105 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl cmp_le_ph_instructionVar105 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.le.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:370:1, end:370:2))"]
#[derive(Clone, Debug)]
struct cmpu_eq_qb_instructionVar106 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl cmpu_eq_qb_instructionVar106 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpu.eq.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:387:1, end:387:2))"]
#[derive(Clone, Debug)]
struct cmpu_lt_qb_instructionVar107 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl cmpu_lt_qb_instructionVar107 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpu.lt.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:404:1, end:404:2))"]
#[derive(Clone, Debug)]
struct cmpu_le_qb_instructionVar108 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl cmpu_le_qb_instructionVar108 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpu.le.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:603:1, end:603:2))"]
#[derive(Clone, Debug)]
struct insv_instructionVar109 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl insv_instructionVar109 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("insv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1025:1, end:1025:2))"]
#[derive(Clone, Debug)]
struct shilo_instructionVar110 {
    ac: u8,
    shift20: u8,
}
impl shilo_instructionVar110 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shilo"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.shift20 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shift20 = token_8(tokens_current);
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ac, shift20 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:201:1, end:201:2))"]
#[derive(Clone, Debug)]
struct balign_instructionVar111 {
    bp: u8,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl balign_instructionVar111 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("balign"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.bp as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let bp = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, bp }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:207:1, end:207:2))"]
#[derive(Clone, Debug)]
struct bitrev_instructionVar112 {
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl bitrev_instructionVar112 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bitrev"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:423:1, end:423:2))"]
#[derive(Clone, Debug)]
struct dpa_w_ph_instructionVar113 {
    ac: u8,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl dpa_w_ph_instructionVar113 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpa.w.ph"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:429:1, end:429:2))"]
#[derive(Clone, Debug)]
struct dpaq_s_w_ph_instructionVar114 {
    ac: u8,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl dpaq_s_w_ph_instructionVar114 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpaq_s.w.ph"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:435:1, end:435:2))"]
#[derive(Clone, Debug)]
struct dpaq_sa_l_w_instructionVar115 {
    ac: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl dpaq_sa_l_w_instructionVar115 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpaq_sa.l.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:441:1, end:441:2))"]
#[derive(Clone, Debug)]
struct dpaqx_s_w_ph_instructionVar116 {
    ac: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl dpaqx_s_w_ph_instructionVar116 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpaqx_s.w.ph"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:447:1, end:447:2))"]
#[derive(Clone, Debug)]
struct dpaqx_sa_w_ph_instructionVar117 {
    ac: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl dpaqx_sa_w_ph_instructionVar117 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpaqx_sa.w.ph"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:453:1, end:453:2))"]
#[derive(Clone, Debug)]
struct dpau_h_qbl_instructionVar118 {
    ac: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl dpau_h_qbl_instructionVar118 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpau.h.qbl"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:459:1, end:459:2))"]
#[derive(Clone, Debug)]
struct dpau_h_qbr_instructionVar119 {
    ac: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl dpau_h_qbr_instructionVar119 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpau.h.qbr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:465:1, end:465:2))"]
#[derive(Clone, Debug)]
struct dpax_w_ph_instructionVar120 {
    ac: u8,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl dpax_w_ph_instructionVar120 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpax.w.ph"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:471:1, end:471:2))"]
#[derive(Clone, Debug)]
struct dps_w_ph_instructionVar121 {
    ac: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl dps_w_ph_instructionVar121 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dps.w.ph"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:477:1, end:477:2))"]
#[derive(Clone, Debug)]
struct dpsq_s_w_ph_instructionVar122 {
    ac: u8,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl dpsq_s_w_ph_instructionVar122 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpsq_s.w.ph"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:483:1, end:483:2))"]
#[derive(Clone, Debug)]
struct dpsq_sa_l_w_instructionVar123 {
    ac: u8,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl dpsq_sa_l_w_instructionVar123 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpsq_sa.l.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:489:1, end:489:2))"]
#[derive(Clone, Debug)]
struct dpsqx_s_w_ph_instructionVar124 {
    ac: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl dpsqx_s_w_ph_instructionVar124 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpsqx_s.w.ph"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:495:1, end:495:2))"]
#[derive(Clone, Debug)]
struct dpsqx_sa_w_ph_instructionVar125 {
    ac: u8,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl dpsqx_sa_w_ph_instructionVar125 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpsqx_sa.w.ph"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:501:1, end:501:2))"]
#[derive(Clone, Debug)]
struct dpsu_h_qbl_instructionVar126 {
    ac: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl dpsu_h_qbl_instructionVar126 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpsu.h.qbl"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:507:1, end:507:2))"]
#[derive(Clone, Debug)]
struct dpsu_h_qbr_instructionVar127 {
    ac: u8,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl dpsu_h_qbr_instructionVar127 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpsu.h.qbr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:513:1, end:513:2))"]
#[derive(Clone, Debug)]
struct dpsx_w_ph_instructionVar128 {
    ac: u8,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl dpsx_w_ph_instructionVar128 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dpsx.w.ph"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:519:1, end:519:2))"]
#[derive(Clone, Debug)]
struct extp_instructionVar129 {
    ac: u8,
    sz: u8,
    RT: TableRT,
}
impl extp_instructionVar129 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sz as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        let sz = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, ac, sz }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:525:1, end:525:2))"]
#[derive(Clone, Debug)]
struct extpdp_instructionVar130 {
    ac: u8,
    sz: u8,
    RT: TableRT,
}
impl extpdp_instructionVar130 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extpdp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sz as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sz = token_6(tokens_current);
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, ac, sz }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:531:1, end:531:2))"]
#[derive(Clone, Debug)]
struct extpdpv_instructionVar131 {
    ac: u8,
    RT: TableRT,
    RSsrc: TableRSsrc,
}
impl extpdpv_instructionVar131 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extpdpv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:537:1, end:537:2))"]
#[derive(Clone, Debug)]
struct extpv_instructionVar132 {
    ac: u8,
    RSsrc: TableRSsrc,
    RT: TableRT,
}
impl extpv_instructionVar132 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extpv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RT, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:543:1, end:543:2))"]
#[derive(Clone, Debug)]
struct extr_w_instructionVar133 {
    ac: u8,
    shift21: u8,
    RT: TableRT,
}
impl extr_w_instructionVar133 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extr.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.shift21 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift21 = token_6(tokens_current);
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, ac, shift21 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:549:1, end:549:2))"]
#[derive(Clone, Debug)]
struct extr_r_w_instructionVar134 {
    ac: u8,
    shift21: u8,
    RT: TableRT,
}
impl extr_r_w_instructionVar134 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extr_r.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.shift21 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        let shift21 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, ac, shift21 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:555:1, end:555:2))"]
#[derive(Clone, Debug)]
struct extr_rs_w_instructionVar135 {
    ac: u8,
    shift21: u8,
    RT: TableRT,
}
impl extr_rs_w_instructionVar135 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extr_rs.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.shift21 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift21 = token_6(tokens_current);
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, ac, shift21 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:563:1, end:563:2))"]
#[derive(Clone, Debug)]
struct extr_s_h_instructionVar136 {
    ac: u8,
    shift21: u8,
    RT: TableRT,
}
impl extr_s_h_instructionVar136 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extr_s.h"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.shift21 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift21 = token_6(tokens_current);
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, ac, shift21 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:571:1, end:571:2))"]
#[derive(Clone, Debug)]
struct extrv_w_instructionVar137 {
    ac: u8,
    RT: TableRT,
    RSsrc: TableRSsrc,
}
impl extrv_w_instructionVar137 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extrv.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:578:1, end:578:2))"]
#[derive(Clone, Debug)]
struct extrv_r_w_instructionVar138 {
    ac: u8,
    RT: TableRT,
    RSsrc: TableRSsrc,
}
impl extrv_r_w_instructionVar138 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extrv_r.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:585:1, end:585:2))"]
#[derive(Clone, Debug)]
struct extrv_rs_w_instructionVar139 {
    ac: u8,
    RT: TableRT,
    RSsrc: TableRSsrc,
}
impl extrv_rs_w_instructionVar139 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extrv_rs.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:594:1, end:594:2))"]
#[derive(Clone, Debug)]
struct extrv_s_h_instructionVar140 {
    ac: u8,
    RT: TableRT,
    RSsrc: TableRSsrc,
}
impl extrv_s_h_instructionVar140 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extrv_s.h"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:636:1, end:636:2))"]
#[derive(Clone, Debug)]
struct madd_instructionVar141 {
    ac: u8,
    RT32src: TableRT32src,
    RS32src: TableRS32src,
}
impl madd_instructionVar141 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("madd"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32src,
                RS32src,
                ac,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:645:1, end:645:2))"]
#[derive(Clone, Debug)]
struct maddu_instructionVar142 {
    ac: u8,
    RT32src: TableRT32src,
    RS32src: TableRS32src,
}
impl maddu_instructionVar142 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maddu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32src,
                RS32src,
                ac,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:655:1, end:655:2))"]
#[derive(Clone, Debug)]
struct maq_s_w_phl_instructionVar143 {
    ac: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl maq_s_w_phl_instructionVar143 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maq_s.w.phl"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:659:1, end:659:2))"]
#[derive(Clone, Debug)]
struct maq_sa_w_phl_instructionVar144 {
    ac: u8,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl maq_sa_w_phl_instructionVar144 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maq_sa.w.phl"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:665:1, end:665:2))"]
#[derive(Clone, Debug)]
struct maq_s_w_phr_instructionVar145 {
    ac: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl maq_s_w_phr_instructionVar145 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maq_s.w.phr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:669:1, end:669:2))"]
#[derive(Clone, Debug)]
struct maq_sa_w_phr_instructionVar146 {
    ac: u8,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl maq_sa_w_phr_instructionVar146 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maq_sa.w.phr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:696:1, end:696:2))"]
#[derive(Clone, Debug)]
struct msub_instructionVar147 {
    ac: u8,
    RT32src: TableRT32src,
    RS32src: TableRS32src,
}
impl msub_instructionVar147 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msub"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let aclo = token_30(tokens_current);
        let achi = token_30(tokens_current);
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32src,
                RS32src,
                ac,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:706:1, end:706:2))"]
#[derive(Clone, Debug)]
struct msubu_instructionVar148 {
    ac: u8,
    RT32src: TableRT32src,
    RS32src: TableRS32src,
}
impl msubu_instructionVar148 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msubu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32src,
                RS32src,
                ac,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:793:1, end:793:2))"]
#[derive(Clone, Debug)]
struct mulsa_w_ph_instructionVar149 {
    ac: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl mulsa_w_ph_instructionVar149 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulsa.w.ph"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:799:1, end:799:2))"]
#[derive(Clone, Debug)]
struct mulsaq_s_w_ph_instructionVar150 {
    ac: u8,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl mulsaq_s_w_ph_instructionVar150 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulsaq_s.w.ph"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, ac }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:805:1, end:805:2))"]
#[derive(Clone, Debug)]
struct mult_instructionVar151 {
    ac: u8,
    RT32src: TableRT32src,
    RS32src: TableRS32src,
}
impl mult_instructionVar151 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mult"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32src,
                RS32src,
                ac,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:813:1, end:813:2))"]
#[derive(Clone, Debug)]
struct multu_instructionVar152 {
    ac: u8,
    RS32src: TableRS32src,
    RT32src: TableRT32src,
}
impl multu_instructionVar152 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("multu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.ac),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ac = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS32src,
                RT32src,
                ac,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:873:1, end:873:2))"]
#[derive(Clone, Debug)]
struct preceq_w_phl_instructionVar153 {
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl preceq_w_phl_instructionVar153 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("preceq.w.phl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:879:1, end:879:2))"]
#[derive(Clone, Debug)]
struct preceq_w_phr_instructionVar154 {
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl preceq_w_phr_instructionVar154 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("preceq.w.phr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:885:1, end:885:2))"]
#[derive(Clone, Debug)]
struct precequ_ph_qbl_instructionVar155 {
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl precequ_ph_qbl_instructionVar155 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("precequ.ph.qbl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:891:1, end:891:2))"]
#[derive(Clone, Debug)]
struct precequ_ph_qbla_instructionVar156 {
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl precequ_ph_qbla_instructionVar156 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("precequ.ph.qbla"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:897:1, end:897:2))"]
#[derive(Clone, Debug)]
struct precequ_ph_qbr_instructionVar157 {
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl precequ_ph_qbr_instructionVar157 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("precequ.ph.qbr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:903:1, end:903:2))"]
#[derive(Clone, Debug)]
struct precequ_ph_qbra_instructionVar158 {
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl precequ_ph_qbra_instructionVar158 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("precequ.ph.qbra"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:909:1, end:909:2))"]
#[derive(Clone, Debug)]
struct preceu_ph_qbl_instructionVar159 {
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl preceu_ph_qbl_instructionVar159 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("preceu.ph.qbl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:915:1, end:915:2))"]
#[derive(Clone, Debug)]
struct preceu_ph_qbla_instructionVar160 {
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl preceu_ph_qbla_instructionVar160 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("preceu.ph.qbla"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:921:1, end:921:2))"]
#[derive(Clone, Debug)]
struct preceu_ph_qbr_instructionVar161 {
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl preceu_ph_qbr_instructionVar161 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("preceu.ph.qbr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:927:1, end:927:2))"]
#[derive(Clone, Debug)]
struct preceu_ph_qbra_instructionVar162 {
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl preceu_ph_qbra_instructionVar162 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("preceu.ph.qbra"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:982:1, end:982:2))"]
#[derive(Clone, Debug)]
struct raddu_w_qb_instructionVar163 {
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl raddu_w_qb_instructionVar163 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("raddu.w.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1013:1, end:1013:2))"]
#[derive(Clone, Debug)]
struct replv_ph_instructionVar164 {
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl replv_ph_instructionVar164 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("replv.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1019:1, end:1019:2))"]
#[derive(Clone, Debug)]
struct replv_qb_instructionVar165 {
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl replv_qb_instructionVar165 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("replv.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1006:1, end:1006:2))"]
#[derive(Clone, Debug)]
struct repl_qb_instructionVar166 {
    immed1623: u8,
    RD: TableRD,
}
impl repl_qb_instructionVar166 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("repl.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.immed1623 & 128 != 0 {
                    -1 & !127
                } else {
                    0
                } | self.immed1623 as i8)
                    .is_negative(),
                (if self.immed1623 & 128 != 0 {
                    -1 & !127
                } else {
                    0
                } | self.immed1623 as i8)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed1623 = token_19(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, immed1623 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1039:1, end:1039:2))"]
#[derive(Clone, Debug)]
struct shll_ph_instructionVar167 {
    sa_dsp2: u8,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl shll_ph_instructionVar167 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shll.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp2 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc, sa_dsp2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1044:1, end:1044:2))"]
#[derive(Clone, Debug)]
struct shll_s_ph_instructionVar168 {
    sa_dsp2: u8,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl shll_s_ph_instructionVar168 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shll_s.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp2 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, sa_dsp2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1099:1, end:1099:2))"]
#[derive(Clone, Debug)]
struct shra_ph_instructionVar169 {
    sa_dsp2: u8,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl shra_ph_instructionVar169 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shra.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp2 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc, sa_dsp2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1104:1, end:1104:2))"]
#[derive(Clone, Debug)]
struct shra_r_ph_instructionVar170 {
    sa_dsp2: u8,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl shra_r_ph_instructionVar170 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shra_r.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp2 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc, sa_dsp2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1144:1, end:1144:2))"]
#[derive(Clone, Debug)]
struct shrl_ph_instructionVar171 {
    sa_dsp2: u8,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl shrl_ph_instructionVar171 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shrl.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp2 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, sa_dsp2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:17:1, end:17:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar172 {
    RD: TableRD,
    RD32: TableRD32,
    RT32src: TableRT32src,
    RS32src: TableRS32src,
}
impl add_instructionVar172 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD32 = if let Some((len, table)) =
            TableRD32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD,
                RD32,
                RT32src,
                RS32src,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:33:1, end:33:2))"]
#[derive(Clone, Debug)]
struct addu_instructionVar173 {
    RT32src: TableRT32src,
    RS32src: TableRS32src,
    RD32: TableRD32,
    RD: TableRD,
}
impl addu_instructionVar173 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD32 = if let Some((len, table)) =
            TableRD32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32src,
                RS32src,
                RD32,
                RD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:41:1, end:41:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar174 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl and_instructionVar174 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:156:1, end:156:2))"]
#[derive(Clone, Debug)]
struct cvt_s_pl_instructionVar175 {
    fd: u8,
    fs: u8,
}
impl cvt_s_pl_instructionVar175 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.s.pl"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:160:1, end:160:2))"]
#[derive(Clone, Debug)]
struct cvt_s_pu_instructionVar176 {
    fd: u8,
    fs: u8,
}
impl cvt_s_pu_instructionVar176 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.s.pu"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:829:1, end:829:2))"]
#[derive(Clone, Debug)]
struct class_S_instructionVar177 {
    fd: u8,
    fs: u8,
}
impl class_S_instructionVar177 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("class.S"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:869:1, end:869:2))"]
#[derive(Clone, Debug)]
struct class_D_instructionVar178 {
    fd: u8,
    fs: u8,
}
impl class_D_instructionVar178 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("class.D"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1141:1, end:1141:2))"]
#[derive(Clone, Debug)]
struct rint_S_instructionVar179 {
    fd: u8,
    fs: u8,
}
impl rint_S_instructionVar179 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rint.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1153:1, end:1153:2))"]
#[derive(Clone, Debug)]
struct rint_D_instructionVar180 {
    fd: u8,
    fs: u8,
}
impl rint_D_instructionVar180 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rint.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1164:1, end:1164:2))"]
#[derive(Clone, Debug)]
struct min_S_instructionVar181 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl min_S_instructionVar181 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("min.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1169:1, end:1169:2))"]
#[derive(Clone, Debug)]
struct min_D_instructionVar182 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl min_D_instructionVar182 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("min.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdD = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1175:1, end:1175:2))"]
#[derive(Clone, Debug)]
struct max_S_instructionVar183 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl max_S_instructionVar183 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("max.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1180:1, end:1180:2))"]
#[derive(Clone, Debug)]
struct max_D_instructionVar184 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl max_D_instructionVar184 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("max.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1186:1, end:1186:2))"]
#[derive(Clone, Debug)]
struct mina_S_instructionVar185 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl mina_S_instructionVar185 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mina.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1191:1, end:1191:2))"]
#[derive(Clone, Debug)]
struct mina_D_instructionVar186 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl mina_D_instructionVar186 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mina.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1197:1, end:1197:2))"]
#[derive(Clone, Debug)]
struct maxa_S_instructionVar187 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl maxa_S_instructionVar187 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maxa.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1202:1, end:1202:2))"]
#[derive(Clone, Debug)]
struct maxa_D_instructionVar188 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl maxa_D_instructionVar188 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maxa.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1208:1, end:1208:2))"]
#[derive(Clone, Debug)]
struct maddf_S_instructionVar189 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl maddf_S_instructionVar189 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maddf.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1212:1, end:1212:2))"]
#[derive(Clone, Debug)]
struct maddf_D_instructionVar190 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl maddf_D_instructionVar190 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maddf.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1217:1, end:1217:2))"]
#[derive(Clone, Debug)]
struct msubf_S_instructionVar191 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl msubf_S_instructionVar191 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msubf.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1221:1, end:1221:2))"]
#[derive(Clone, Debug)]
struct msubf_D_instructionVar192 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl msubf_D_instructionVar192 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msubf.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fdD = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1226:1, end:1226:2))"]
#[derive(Clone, Debug)]
struct seleqz_S_instructionVar193 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl seleqz_S_instructionVar193 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("seleqz.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1231:1, end:1231:2))"]
#[derive(Clone, Debug)]
struct seleqz_D_instructionVar194 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl seleqz_D_instructionVar194 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("seleqz.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1236:1, end:1236:2))"]
#[derive(Clone, Debug)]
struct selnez_S_instructionVar195 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl selnez_S_instructionVar195 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("selnez.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1240:1, end:1240:2))"]
#[derive(Clone, Debug)]
struct selnez_D_instructionVar196 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl selnez_D_instructionVar196 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("selnez.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2376:1, end:2376:2))"]
#[derive(Clone, Debug)]
struct jr_instructionVar197 {
    mic_rs32_0: u8,
}
impl jr_instructionVar197 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jr"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2382:1, end:2382:2))"]
#[derive(Clone, Debug)]
struct jr_hb_instructionVar198 {
    mic_rs32_0: u8,
}
impl jr_hb_instructionVar198 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jr.hb"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2593:1, end:2593:2))"]
#[derive(Clone, Debug)]
struct mfhi_instructionVar199 {
    mic_rs32_0: u8,
}
impl mfhi_instructionVar199 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfhi"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2601:1, end:2601:2))"]
#[derive(Clone, Debug)]
struct mflo_instructionVar200 {
    mic_rs32_0: u8,
}
impl mflo_instructionVar200 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mflo"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2747:1, end:2747:2))"]
#[derive(Clone, Debug)]
struct mthi_instructionVar201 {
    mic_rs32_0: u8,
}
impl mthi_instructionVar201 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mthi"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2751:1, end:2751:2))"]
#[derive(Clone, Debug)]
struct mtlo_instructionVar202 {
    mic_rs32_0: u8,
}
impl mtlo_instructionVar202 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtlo"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3699:1, end:3699:2))"]
#[derive(Clone, Debug)]
struct rdhwr_instructionVar203 {
    mic_rt32_5: u8,
    mic_rs32_hw: u8,
}
impl rdhwr_instructionVar203 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdhwr"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_26_display(self.mic_rs32_hw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        if token_53(tokens_current) == 4 {
            return None;
        }
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_hw = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_rs32_hw,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1914:1, end:1914:2))"]
#[derive(Clone, Debug)]
struct abs_PS_instructionVar204 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl abs_PS_instructionVar204 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("abs.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2300:1, end:2300:2))"]
#[derive(Clone, Debug)]
struct div_instructionVar205 {
    RS0L: TableRS0L,
    RT5L: TableRT5L,
}
impl div_instructionVar205 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("div"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS0L, RT5L }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2305:1, end:2305:2))"]
#[derive(Clone, Debug)]
struct divu_instructionVar206 {
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl divu_instructionVar206 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT5L, RS0L }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2321:1, end:2321:2))"]
#[derive(Clone, Debug)]
struct jalr_instructionVar207 {
    mic_rs32_0: u8,
    RTIMP: TableRTIMP,
}
impl jalr_instructionVar207 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTIMP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RTIMP = if let Some((len, table)) =
            TableRTIMP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTIMP, mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2328:1, end:2328:2))"]
#[derive(Clone, Debug)]
struct jalr_hb_instructionVar208 {
    mic_rs32_0: u8,
    RTIMP: TableRTIMP,
}
impl jalr_hb_instructionVar208 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalr.hb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTIMP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RTIMP = if let Some((len, table)) =
            TableRTIMP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTIMP, mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2349:1, end:2349:2))"]
#[derive(Clone, Debug)]
struct jalrs_instructionVar209 {
    mic_rs32_0: u8,
    RTIMP: TableRTIMP,
}
impl jalrs_instructionVar209 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalrs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTIMP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RTIMP = if let Some((len, table)) =
            TableRTIMP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTIMP, mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2356:1, end:2356:2))"]
#[derive(Clone, Debug)]
struct jalrs_hb_instructionVar210 {
    mic_rs32_0: u8,
    RTIMP: TableRTIMP,
}
impl jalrs_hb_instructionVar210 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalrs.hb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTIMP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RTIMP = if let Some((len, table)) =
            TableRTIMP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTIMP, mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2558:1, end:2558:2))"]
#[derive(Clone, Debug)]
struct madd_instructionVar211 {
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl madd_instructionVar211 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("madd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT5L, RS0L }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2582:1, end:2582:2))"]
#[derive(Clone, Debug)]
struct maddu_instructionVar212 {
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl maddu_instructionVar212 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maddu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT5L, RS0L }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2609:1, end:2609:2))"]
#[derive(Clone, Debug)]
struct mov_PS_instructionVar213 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl mov_PS_instructionVar213 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2712:1, end:2712:2))"]
#[derive(Clone, Debug)]
struct msub_instructionVar214 {
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl msub_instructionVar214 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT5L, RS0L }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2736:1, end:2736:2))"]
#[derive(Clone, Debug)]
struct msubu_instructionVar215 {
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl msubu_instructionVar215 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msubu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT5L, RS0L }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2759:1, end:2759:2))"]
#[derive(Clone, Debug)]
struct mult_instructionVar216 {
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl mult_instructionVar216 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mult"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT5L, RS0L }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2767:1, end:2767:2))"]
#[derive(Clone, Debug)]
struct multu_instructionVar217 {
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl multu_instructionVar217 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("multu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT5L, RS0L }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2775:1, end:2775:2))"]
#[derive(Clone, Debug)]
struct neg_PS_instructionVar218 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl neg_PS_instructionVar218 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("neg.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2800:1, end:2800:2))"]
#[derive(Clone, Debug)]
struct rdhwr_instructionVar219 {
    mic_rt32_5: u8,
    mic_rs32_hw: u8,
}
impl rdhwr_instructionVar219 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdhwr"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_26_display(self.mic_rs32_hw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_hw = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_rs32_hw,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3208:1, end:3208:2))"]
#[derive(Clone, Debug)]
struct bitswap_instructionVar220 {
    mic_rd32_0: u8,
    RT5L: TableRT5L,
}
impl bitswap_instructionVar220 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bitswap"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rd32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rd32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT5L, mic_rd32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3217:1, end:3217:2))"]
#[derive(Clone, Debug)]
struct class_S_instructionVar221 {
    mic_fd: u8,
    mic_fs_5: u8,
}
impl class_S_instructionVar221 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("class.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs_5 = token_69(tokens_current);
        let mic_fd = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_fd, mic_fs_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3243:1, end:3243:2))"]
#[derive(Clone, Debug)]
struct class_D_instructionVar222 {
    mic_fd: u8,
    mic_fs_5: u8,
}
impl class_D_instructionVar222 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("class.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD_5 = token_69(tokens_current);
        let mic_fdD = token_53(tokens_current);
        let mic_fd = token_53(tokens_current);
        let mic_fs_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_fd, mic_fs_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3510:1, end:3510:2))"]
#[derive(Clone, Debug)]
struct jalrc_instructionVar223 {
    mic_rs32_0: u8,
    RTIMP: TableRTIMP,
}
impl jalrc_instructionVar223 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalrc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTIMP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RTIMP = if let Some((len, table)) =
            TableRTIMP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTIMP, mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3516:1, end:3516:2))"]
#[derive(Clone, Debug)]
struct jalrc_hb_instructionVar224 {
    mic_rs32_0: u8,
    RTIMP: TableRTIMP,
}
impl jalrc_hb_instructionVar224 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalrc.hb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTIMP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RTIMP = if let Some((len, table)) =
            TableRTIMP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTIMP, mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3703:1, end:3703:2))"]
#[derive(Clone, Debug)]
struct rint_S_instructionVar225 {
    mic_fd: u8,
    mic_fs_5: u8,
}
impl rint_S_instructionVar225 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rint.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fd = token_53(tokens_current);
        let mic_fs_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_fd, mic_fs_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3717:1, end:3717:2))"]
#[derive(Clone, Debug)]
struct rint_D_instructionVar226 {
    mic_fd: u8,
    mic_fs_5: u8,
}
impl rint_D_instructionVar226 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rint.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs_5 = token_69(tokens_current);
        let mic_fsD_5 = token_69(tokens_current);
        let mic_fd = token_53(tokens_current);
        let mic_fdD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_fd, mic_fs_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:476:1, end:476:2))"]
#[derive(Clone, Debug)]
struct nal_instructionVar227 {}
impl nal_instructionVar227 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nal"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:690:1, end:690:2))"]
#[derive(Clone, Debug)]
struct sync_instructionVar228 {
    stype: u8,
}
impl sync_instructionVar228 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_scalar: i128 = 0;
        calc_scalar = i128::try_from(self.stype).unwrap().wrapping_add(0i128);
        display.push(DisplayElement::Literal("sync"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Number(true, calc_scalar.is_negative(), calc_scalar.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_scalar: i128 = 0;
        let mut block_0_len = 4;
        calc_scalar = i128::try_from(token_37(tokens_current))
            .unwrap()
            .wrapping_add(0i128);
        let stype = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stype }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:846:1, end:846:2))"]
#[derive(Clone, Debug)]
struct bal_instructionVar229 {
    Rel16: TableRel16,
}
impl bal_instructionVar229 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bal"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:860:1, end:860:2))"]
#[derive(Clone, Debug)]
struct bc2f_instructionVar230 {
    Rel16: TableRel16,
}
impl bc2f_instructionVar230 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2f"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:873:1, end:873:2))"]
#[derive(Clone, Debug)]
struct bc2fl_instructionVar231 {
    Rel16: TableRel16,
}
impl bc2fl_instructionVar231 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2fl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:886:1, end:886:2))"]
#[derive(Clone, Debug)]
struct bc2t_instructionVar232 {
    Rel16: TableRel16,
}
impl bc2t_instructionVar232 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2t"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:899:1, end:899:2))"]
#[derive(Clone, Debug)]
struct bc2tl_instructionVar233 {
    Rel16: TableRel16,
}
impl bc2tl_instructionVar233 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2tl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1425:1, end:1425:2))"]
#[derive(Clone, Debug)]
struct bal_instructionVar234 {
    Rel16: TableRel16,
}
impl bal_instructionVar234 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bal"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1458:1, end:1458:2))"]
#[derive(Clone, Debug)]
struct bad1_instructionVar235 {}
impl bad1_instructionVar235 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bad1"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1465:1, end:1465:2))"]
#[derive(Clone, Debug)]
struct bgezalc_instructionVar236 {
    Rel16: TableRel16,
    RTsrc: TableRTsrc,
}
impl bgezalc_instructionVar236 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgezalc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if i128::try_from(token_6(tokens_current)).unwrap()
            != i128::try_from(token_20(tokens_current)).unwrap()
        {
            return None;
        }
        if token_20(tokens_current) == 0 {
            return None;
        }
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1471:1, end:1471:2))"]
#[derive(Clone, Debug)]
struct bgeuc_instructionVar237 {
    Rel16: TableRel16,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl bgeuc_instructionVar237 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgeuc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_20(tokens_current) == 0 {
            return None;
        }
        if i128::try_from(token_6(tokens_current)).unwrap()
            == i128::try_from(token_20(tokens_current)).unwrap()
        {
            return None;
        }
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16,
                RSsrc,
                RTsrc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1475:1, end:1475:2))"]
#[derive(Clone, Debug)]
struct bad2_instructionVar238 {}
impl bad2_instructionVar238 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bad2"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1482:1, end:1482:2))"]
#[derive(Clone, Debug)]
struct bltzalc_instructionVar239 {
    RTsrc: TableRTsrc,
    Rel16: TableRel16,
}
impl bltzalc_instructionVar239 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltzalc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if i128::try_from(token_6(tokens_current)).unwrap()
            != i128::try_from(token_20(tokens_current)).unwrap()
        {
            return None;
        }
        if token_20(tokens_current) == 0 {
            return None;
        }
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1488:1, end:1488:2))"]
#[derive(Clone, Debug)]
struct bltuc_instructionVar240 {
    RTsrc: TableRTsrc,
    Rel16: TableRel16,
    RSsrc: TableRSsrc,
}
impl bltuc_instructionVar240 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltuc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_20(tokens_current) == 0 {
            return None;
        }
        if i128::try_from(token_6(tokens_current)).unwrap()
            == i128::try_from(token_20(tokens_current)).unwrap()
        {
            return None;
        }
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                Rel16,
                RSsrc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1493:1, end:1493:2))"]
#[derive(Clone, Debug)]
struct beqzalc_instructionVar241 {
    RTsrc: TableRTsrc,
    Rel16: TableRel16,
}
impl beqzalc_instructionVar241 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beqzalc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_20(tokens_current) == 0 {
            return None;
        }
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1514:1, end:1514:2))"]
#[derive(Clone, Debug)]
struct bnezalc_instructionVar242 {
    Rel16: TableRel16,
    RTsrc: TableRTsrc,
}
impl bnezalc_instructionVar242 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnezalc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_20(tokens_current) == 0 {
            return None;
        }
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1535:1, end:1535:2))"]
#[derive(Clone, Debug)]
struct bad3_instructionVar243 {}
impl bad3_instructionVar243 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bad3"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1536:1, end:1536:2))"]
#[derive(Clone, Debug)]
struct blezc_instructionVar244 {
    RTsrc: TableRTsrc,
    Rel16: TableRel16,
}
impl blezc_instructionVar244 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blezc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_20(tokens_current) == 0 {
            return None;
        }
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1539:1, end:1539:2))"]
#[derive(Clone, Debug)]
struct bgezc_instructionVar245 {
    RTsrc: TableRTsrc,
    Rel16: TableRel16,
}
impl bgezc_instructionVar245 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgezc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if i128::try_from(token_6(tokens_current)).unwrap()
            != i128::try_from(token_20(tokens_current)).unwrap()
        {
            return None;
        }
        if token_20(tokens_current) == 0 {
            return None;
        }
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1547:1, end:1547:2))"]
#[derive(Clone, Debug)]
struct bad4_instructionVar246 {}
impl bad4_instructionVar246 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bad4"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1548:1, end:1548:2))"]
#[derive(Clone, Debug)]
struct bgtzc_instructionVar247 {
    RTsrc: TableRTsrc,
    Rel16: TableRel16,
}
impl bgtzc_instructionVar247 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgtzc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_20(tokens_current) == 0 {
            return None;
        }
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1552:1, end:1552:2))"]
#[derive(Clone, Debug)]
struct bltzc_instructionVar248 {
    RTsrc: TableRTsrc,
    Rel16: TableRel16,
}
impl bltzc_instructionVar248 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltzc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if i128::try_from(token_6(tokens_current)).unwrap()
            != i128::try_from(token_20(tokens_current)).unwrap()
        {
            return None;
        }
        if token_20(tokens_current) == 0 {
            return None;
        }
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1739:1, end:1739:2))"]
#[derive(Clone, Debug)]
struct sigrie_instructionVar249 {
    immed: u16,
}
impl sigrie_instructionVar249 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sigrie"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let immed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:41:1, end:41:2))"]
#[derive(Clone, Debug)]
struct ceil_l_S_instructionVar250 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl ceil_l_S_instructionVar250 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ceil.l.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:47:1, end:47:2))"]
#[derive(Clone, Debug)]
struct ceil_l_D_instructionVar251 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl ceil_l_D_instructionVar251 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ceil.l.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:53:1, end:53:2))"]
#[derive(Clone, Debug)]
struct ceil_w_S_instructionVar252 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl ceil_w_S_instructionVar252 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ceil.w.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:57:1, end:57:2))"]
#[derive(Clone, Debug)]
struct ceil_w_D_instructionVar253 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl ceil_w_D_instructionVar253 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ceil.w.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:98:1, end:98:2))"]
#[derive(Clone, Debug)]
struct cvt_d_S_instructionVar254 {
    fd: u8,
    fs: u8,
    fmt3: Tablefmt3,
}
impl cvt_d_S_instructionVar254 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.d.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt3 = if let Some((len, table)) =
            Tablefmt3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt3, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:102:1, end:102:2))"]
#[derive(Clone, Debug)]
struct cvt_d_W_instructionVar255 {
    fd: u8,
    fs: u8,
    fmt3: Tablefmt3,
}
impl cvt_d_W_instructionVar255 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.d.W"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt3 = if let Some((len, table)) =
            Tablefmt3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt3, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:107:1, end:107:2))"]
#[derive(Clone, Debug)]
struct cvt_d_L_instructionVar256 {
    fd: u8,
    fs: u8,
    fmt3: Tablefmt3,
}
impl cvt_d_L_instructionVar256 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.d.L"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt3 = if let Some((len, table)) =
            Tablefmt3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt3, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:113:1, end:113:2))"]
#[derive(Clone, Debug)]
struct cvt_l_S_instructionVar257 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl cvt_l_S_instructionVar257 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.l.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:127:1, end:127:2))"]
#[derive(Clone, Debug)]
struct cvt_l_D_instructionVar258 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl cvt_l_D_instructionVar258 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.l.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:145:1, end:145:2))"]
#[derive(Clone, Debug)]
struct cvt_s_D_instructionVar259 {
    fd: u8,
    fs: u8,
    fmt4: Tablefmt4,
}
impl cvt_s_D_instructionVar259 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.s.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt4 = if let Some((len, table)) =
            Tablefmt4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt4, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:148:1, end:148:2))"]
#[derive(Clone, Debug)]
struct cvt_s_W_instructionVar260 {
    fd: u8,
    fs: u8,
    fmt4: Tablefmt4,
}
impl cvt_s_W_instructionVar260 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.s.W"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt4 = if let Some((len, table)) =
            Tablefmt4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt4, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:151:1, end:151:2))"]
#[derive(Clone, Debug)]
struct cvt_s_L_instructionVar261 {
    fd: u8,
    fs: u8,
    fmt4: Tablefmt4,
}
impl cvt_s_L_instructionVar261 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.s.L"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt4 = if let Some((len, table)) =
            Tablefmt4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt4, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:165:1, end:165:2))"]
#[derive(Clone, Debug)]
struct cvt_w_S_instructionVar262 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl cvt_w_S_instructionVar262 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.w.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:178:1, end:178:2))"]
#[derive(Clone, Debug)]
struct cvt_w_D_instructionVar263 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl cvt_w_D_instructionVar263 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.w.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:199:1, end:199:2))"]
#[derive(Clone, Debug)]
struct floor_l_S_instructionVar264 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl floor_l_S_instructionVar264 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("floor.l.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:205:1, end:205:2))"]
#[derive(Clone, Debug)]
struct floor_l_D_instructionVar265 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl floor_l_D_instructionVar265 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("floor.l.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:211:1, end:211:2))"]
#[derive(Clone, Debug)]
struct floor_w_S_instructionVar266 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl floor_w_S_instructionVar266 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("floor.w.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:216:1, end:216:2))"]
#[derive(Clone, Debug)]
struct floor_w_D_instructionVar267 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl floor_w_D_instructionVar267 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("floor.w.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:293:1, end:293:2))"]
#[derive(Clone, Debug)]
struct recip_S_instructionVar268 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl recip_S_instructionVar268 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("recip.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:296:1, end:296:2))"]
#[derive(Clone, Debug)]
struct recip_D_instructionVar269 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl recip_D_instructionVar269 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("recip.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:301:1, end:301:2))"]
#[derive(Clone, Debug)]
struct round_l_S_instructionVar270 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl round_l_S_instructionVar270 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("round.l.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:306:1, end:306:2))"]
#[derive(Clone, Debug)]
struct round_l_D_instructionVar271 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl round_l_D_instructionVar271 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("round.l.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:312:1, end:312:2))"]
#[derive(Clone, Debug)]
struct round_w_S_instructionVar272 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl round_w_S_instructionVar272 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("round.w.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:316:1, end:316:2))"]
#[derive(Clone, Debug)]
struct round_w_D_instructionVar273 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl round_w_D_instructionVar273 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("round.w.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:322:1, end:322:2))"]
#[derive(Clone, Debug)]
struct rsqrt_S_instructionVar274 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl rsqrt_S_instructionVar274 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsqrt.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:325:1, end:325:2))"]
#[derive(Clone, Debug)]
struct rsqrt_D_instructionVar275 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl rsqrt_D_instructionVar275 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsqrt.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:330:1, end:330:2))"]
#[derive(Clone, Debug)]
struct sqrt_S_instructionVar276 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl sqrt_S_instructionVar276 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sqrt.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:333:1, end:333:2))"]
#[derive(Clone, Debug)]
struct sqrt_D_instructionVar277 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl sqrt_D_instructionVar277 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sqrt.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:354:1, end:354:2))"]
#[derive(Clone, Debug)]
struct trunc_l_S_instructionVar278 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl trunc_l_S_instructionVar278 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trunc.l.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:358:1, end:358:2))"]
#[derive(Clone, Debug)]
struct trunc_l_D_instructionVar279 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl trunc_l_D_instructionVar279 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trunc.l.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:363:1, end:363:2))"]
#[derive(Clone, Debug)]
struct trunc_w_S_instructionVar280 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl trunc_w_S_instructionVar280 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trunc.w.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:366:1, end:366:2))"]
#[derive(Clone, Debug)]
struct trunc_w_D_instructionVar281 {
    fd: u8,
    fs: u8,
    fmt2: Tablefmt2,
}
impl trunc_w_D_instructionVar281 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trunc.w.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:468:1, end:468:2))"]
#[derive(Clone, Debug)]
struct bc1f_instructionVar282 {
    Rel16: TableRel16,
}
impl bc1f_instructionVar282 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1f"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:482:1, end:482:2))"]
#[derive(Clone, Debug)]
struct bc1fl_instructionVar283 {
    Rel16: TableRel16,
}
impl bc1fl_instructionVar283 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1fl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:497:1, end:497:2))"]
#[derive(Clone, Debug)]
struct bc1t_instructionVar284 {
    Rel16: TableRel16,
}
impl bc1t_instructionVar284 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1t"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:511:1, end:511:2))"]
#[derive(Clone, Debug)]
struct bc1tl_instructionVar285 {
    Rel16: TableRel16,
}
impl bc1tl_instructionVar285 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1tl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:804:1, end:804:2))"]
#[derive(Clone, Debug)]
struct di_instructionVar286 {
    DIDISP: TableDIDISP,
}
impl di_instructionVar286 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("di"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.DIDISP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let DIDISP = if let Some((len, table)) =
            TableDIDISP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { DIDISP }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:823:1, end:823:2))"]
#[derive(Clone, Debug)]
struct ei_instructionVar287 {
    DIDISP: TableDIDISP,
}
impl ei_instructionVar287 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ei"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.DIDISP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let DIDISP = if let Some((len, table)) =
            TableDIDISP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { DIDISP }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1530:1, end:1530:2))"]
#[derive(Clone, Debug)]
struct sync_instructionVar288 {
    STYPE: TableSTYPE,
}
impl sync_instructionVar288 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sync"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.STYPE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let STYPE = if let Some((len, table)) =
            TableSTYPE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STYPE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3502:1, end:3502:2))"]
#[derive(Clone, Debug)]
struct dvp_instructionVar289 {
    STYPE: TableSTYPE,
}
impl dvp_instructionVar289 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dvp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.STYPE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let STYPE = if let Some((len, table)) =
            TableSTYPE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STYPE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3506:1, end:3506:2))"]
#[derive(Clone, Debug)]
struct evp_instructionVar290 {
    STYPE: TableSTYPE,
}
impl evp_instructionVar290 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("evp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.STYPE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let STYPE = if let Some((len, table)) =
            TableSTYPE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STYPE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:558:1, end:558:2))"]
#[derive(Clone, Debug)]
struct abs_S_instructionVar291 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl abs_S_instructionVar291 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("abs.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:564:1, end:564:2))"]
#[derive(Clone, Debug)]
struct abs_D_instructionVar292 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl abs_D_instructionVar292 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("abs.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:667:1, end:667:2))"]
#[derive(Clone, Debug)]
struct ceil_l_S_instructionVar293 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl ceil_l_S_instructionVar293 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ceil.l.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:672:1, end:672:2))"]
#[derive(Clone, Debug)]
struct ceil_l_D_instructionVar294 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl ceil_l_D_instructionVar294 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ceil.l.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:677:1, end:677:2))"]
#[derive(Clone, Debug)]
struct ceil_w_S_instructionVar295 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl ceil_w_S_instructionVar295 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ceil.w.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:683:1, end:683:2))"]
#[derive(Clone, Debug)]
struct ceil_w_D_instructionVar296 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl ceil_w_D_instructionVar296 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ceil.w.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:689:1, end:689:2))"]
#[derive(Clone, Debug)]
struct cfc1_instructionVar297 {
    mic_rt32_5: u8,
    mic_fs: u8,
}
impl cfc1_instructionVar297 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cfc1"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt32_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:693:1, end:693:2))"]
#[derive(Clone, Debug)]
struct cfc2_instructionVar298 {
    mic_rt32_5: u8,
    mic_impl: u8,
}
impl cfc2_instructionVar298 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cfc2"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_impl as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_impl = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_impl,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:699:1, end:699:2))"]
#[derive(Clone, Debug)]
struct clo_instructionVar299 {
    mic_rt32_5: u8,
    RS0L: TableRS0L,
}
impl clo_instructionVar299 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clo"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS0L, mic_rt32_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:703:1, end:703:2))"]
#[derive(Clone, Debug)]
struct clz_instructionVar300 {
    mic_rt32_5: u8,
    RS0L: TableRS0L,
}
impl clz_instructionVar300 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clz"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS0L, mic_rt32_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:712:1, end:712:2))"]
#[derive(Clone, Debug)]
struct ctc1_instructionVar301 {
    mic_fs: u8,
    RT5L: TableRT5L,
}
impl ctc1_instructionVar301 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ctc1"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT5L, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:716:1, end:716:2))"]
#[derive(Clone, Debug)]
struct ctc2_instructionVar302 {
    mic_rt32_5: u8,
    mic_impl: u8,
}
impl ctc2_instructionVar302 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ctc2"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_impl as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_impl = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_impl,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:722:1, end:722:2))"]
#[derive(Clone, Debug)]
struct cvt_d_S_instructionVar303 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl cvt_d_S_instructionVar303 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.d.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:727:1, end:727:2))"]
#[derive(Clone, Debug)]
struct cvt_d_W_instructionVar304 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl cvt_d_W_instructionVar304 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.d.W"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:732:1, end:732:2))"]
#[derive(Clone, Debug)]
struct cvt_d_L_instructionVar305 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl cvt_d_L_instructionVar305 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.d.L"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:736:1, end:736:2))"]
#[derive(Clone, Debug)]
struct cvt_l_S_instructionVar306 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl cvt_l_S_instructionVar306 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.l.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:749:1, end:749:2))"]
#[derive(Clone, Debug)]
struct cvt_l_D_instructionVar307 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl cvt_l_D_instructionVar307 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.l.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:760:1, end:760:2))"]
#[derive(Clone, Debug)]
struct cvt_s_D_instructionVar308 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl cvt_s_D_instructionVar308 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.s.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:765:1, end:765:2))"]
#[derive(Clone, Debug)]
struct cvt_s_W_instructionVar309 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl cvt_s_W_instructionVar309 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.s.W"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:771:1, end:771:2))"]
#[derive(Clone, Debug)]
struct cvt_s_L_instructionVar310 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl cvt_s_L_instructionVar310 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.s.L"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:776:1, end:776:2))"]
#[derive(Clone, Debug)]
struct cvt_w_S_instructionVar311 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl cvt_w_S_instructionVar311 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.w.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:790:1, end:790:2))"]
#[derive(Clone, Debug)]
struct cvt_w_D_instructionVar312 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl cvt_w_D_instructionVar312 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.w.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:839:1, end:839:2))"]
#[derive(Clone, Debug)]
struct floor_l_S_instructionVar313 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl floor_l_S_instructionVar313 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("floor.l.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:845:1, end:845:2))"]
#[derive(Clone, Debug)]
struct floor_l_D_instructionVar314 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl floor_l_D_instructionVar314 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("floor.l.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:850:1, end:850:2))"]
#[derive(Clone, Debug)]
struct floor_w_S_instructionVar315 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl floor_w_S_instructionVar315 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("floor.w.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:856:1, end:856:2))"]
#[derive(Clone, Debug)]
struct floor_w_D_instructionVar316 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl floor_w_D_instructionVar316 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("floor.w.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1083:1, end:1083:2))"]
#[derive(Clone, Debug)]
struct mfc1_instructionVar317 {
    mic_rt32_5: u8,
    mic_fs: u8,
}
impl mfc1_instructionVar317 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfc1"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt32_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1087:1, end:1087:2))"]
#[derive(Clone, Debug)]
struct mfc2_instructionVar318 {
    mic_rt32_5: u8,
    mic_impl: u8,
}
impl mfc2_instructionVar318 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfc2"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_impl as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_impl = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_impl,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1095:1, end:1095:2))"]
#[derive(Clone, Debug)]
struct mfhc1_instructionVar319 {
    mic_rt32_5: u8,
    mic_fs: u8,
}
impl mfhc1_instructionVar319 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfhc1"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt32_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1100:1, end:1100:2))"]
#[derive(Clone, Debug)]
struct mfhc2_instructionVar320 {
    mic_rt32_5: u8,
    mic_impl: u8,
}
impl mfhc2_instructionVar320 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfhc2"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_impl as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_impl = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_impl,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1104:1, end:1104:2))"]
#[derive(Clone, Debug)]
struct mov_S_instructionVar321 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl mov_S_instructionVar321 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1108:1, end:1108:2))"]
#[derive(Clone, Debug)]
struct mov_D_instructionVar322 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl mov_D_instructionVar322 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1126:1, end:1126:2))"]
#[derive(Clone, Debug)]
struct mtc1_instructionVar323 {
    mic_fs: u8,
    RT5L: TableRT5L,
}
impl mtc1_instructionVar323 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtc1"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT5L, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1130:1, end:1130:2))"]
#[derive(Clone, Debug)]
struct mtc2_instructionVar324 {
    mic_rt32_5: u8,
    mic_impl: u8,
}
impl mtc2_instructionVar324 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtc2"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_impl as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_impl = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_impl,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1138:1, end:1138:2))"]
#[derive(Clone, Debug)]
struct mthc1_instructionVar325 {
    mic_fs: u8,
    RT5L: TableRT5L,
}
impl mthc1_instructionVar325 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mthc1"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT5L, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1142:1, end:1142:2))"]
#[derive(Clone, Debug)]
struct mthc2_instructionVar326 {
    mic_rt32_5: u8,
    mic_impl: u8,
}
impl mthc2_instructionVar326 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mthc2"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_impl as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_impl = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_impl,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1160:1, end:1160:2))"]
#[derive(Clone, Debug)]
struct neg_S_instructionVar327 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl neg_S_instructionVar327 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("neg.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1166:1, end:1166:2))"]
#[derive(Clone, Debug)]
struct neg_D_instructionVar328 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl neg_D_instructionVar328 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("neg.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1211:1, end:1211:2))"]
#[derive(Clone, Debug)]
struct rdpgpr_instructionVar329 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
}
impl rdpgpr_instructionVar329 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdpgpr"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1215:1, end:1215:2))"]
#[derive(Clone, Debug)]
struct recip_S_instructionVar330 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl recip_S_instructionVar330 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("recip.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1220:1, end:1220:2))"]
#[derive(Clone, Debug)]
struct recip_D_instructionVar331 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl recip_D_instructionVar331 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("recip.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1239:1, end:1239:2))"]
#[derive(Clone, Debug)]
struct round_l_S_instructionVar332 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl round_l_S_instructionVar332 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("round.l.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1244:1, end:1244:2))"]
#[derive(Clone, Debug)]
struct round_l_D_instructionVar333 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl round_l_D_instructionVar333 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("round.l.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1249:1, end:1249:2))"]
#[derive(Clone, Debug)]
struct round_w_S_instructionVar334 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl round_w_S_instructionVar334 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("round.w.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1254:1, end:1254:2))"]
#[derive(Clone, Debug)]
struct round_w_D_instructionVar335 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl round_w_D_instructionVar335 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("round.w.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1260:1, end:1260:2))"]
#[derive(Clone, Debug)]
struct rsqrt_S_instructionVar336 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl rsqrt_S_instructionVar336 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsqrt.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1265:1, end:1265:2))"]
#[derive(Clone, Debug)]
struct rsqrt_D_instructionVar337 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl rsqrt_D_instructionVar337 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsqrt.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1312:1, end:1312:2))"]
#[derive(Clone, Debug)]
struct sdbbp_instructionVar338 {
    mic_code: u16,
}
impl sdbbp_instructionVar338 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdbbp"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_code as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_code = token_72(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_code }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1336:1, end:1336:2))"]
#[derive(Clone, Debug)]
struct seb_instructionVar339 {
    mic_rt32_5: u8,
    RS0L: TableRS0L,
}
impl seb_instructionVar339 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("seb"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS0L, mic_rt32_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1340:1, end:1340:2))"]
#[derive(Clone, Debug)]
struct seh_instructionVar340 {
    mic_rt32_5: u8,
    RS0L: TableRS0L,
}
impl seh_instructionVar340 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("seh"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS0L, mic_rt32_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1403:1, end:1403:2))"]
#[derive(Clone, Debug)]
struct sqrt_S_instructionVar341 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl sqrt_S_instructionVar341 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sqrt.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1408:1, end:1408:2))"]
#[derive(Clone, Debug)]
struct sqrt_D_instructionVar342 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl sqrt_D_instructionVar342 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sqrt.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1540:1, end:1540:2))"]
#[derive(Clone, Debug)]
struct syscall_instructionVar343 {}
impl syscall_instructionVar343 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("syscall"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1604:1, end:1604:2))"]
#[derive(Clone, Debug)]
struct trunk_l_S_instructionVar344 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl trunk_l_S_instructionVar344 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trunk.l.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1608:1, end:1608:2))"]
#[derive(Clone, Debug)]
struct trunk_l_D_instructionVar345 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl trunk_l_D_instructionVar345 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trunk.l.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1612:1, end:1612:2))"]
#[derive(Clone, Debug)]
struct trunk_w_S_instructionVar346 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl trunk_w_S_instructionVar346 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trunk.w.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1617:1, end:1617:2))"]
#[derive(Clone, Debug)]
struct trunk_w_D_instructionVar347 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl trunk_w_D_instructionVar347 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trunk.w.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1622:1, end:1622:2))"]
#[derive(Clone, Debug)]
struct wait_instructionVar348 {}
impl wait_instructionVar348 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wait"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1626:1, end:1626:2))"]
#[derive(Clone, Debug)]
struct wrpgpr_instructionVar349 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
}
impl wrpgpr_instructionVar349 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrpgpr"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1630:1, end:1630:2))"]
#[derive(Clone, Debug)]
struct wsbh_instructionVar350 {
    mic_rt32_5: u8,
    RS0L: TableRS0L,
}
impl wsbh_instructionVar350 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wsbh"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS0L, mic_rt32_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:51:1, end:51:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar351 {
    Rel16: TableRel16,
}
impl b_instructionVar351 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:323:1, end:323:2))"]
#[derive(Clone, Debug)]
struct jr_hb_instructionVar352 {
    RSsrc: TableRSsrc,
}
impl jr_hb_instructionVar352 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jr.hb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let mut sub_pattern_c57 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    if token_42(tokens) != 8 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c58(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    if token_42(tokens) != 9 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c58(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c57(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:279:1, end:279:2))"]
#[derive(Clone, Debug)]
struct jalr_hb_instructionVar353 {
    RSsrc: TableRSsrc,
}
impl jalr_hb_instructionVar353 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalr.hb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:306:1, end:306:2))"]
#[derive(Clone, Debug)]
struct jr_instructionVar354 {
    RSsrc: TableRSsrc,
}
impl jr_instructionVar354 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let mut sub_pattern_c57 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    if token_42(tokens) != 8 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c58(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    if token_42(tokens) != 9 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c58(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c57(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:245:1, end:245:2))"]
#[derive(Clone, Debug)]
struct jalr_instructionVar355 {
    RSsrc: TableRSsrc,
}
impl jalr_instructionVar355 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:271:1, end:271:2))"]
#[derive(Clone, Debug)]
struct jalr_hb_instructionVar356 {
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl jalr_hb_instructionVar356 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalr.hb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:237:1, end:237:2))"]
#[derive(Clone, Debug)]
struct jalr_instructionVar357 {
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl jalr_instructionVar357 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:919:1, end:919:2))"]
#[derive(Clone, Debug)]
struct bgezal_instructionVar358 {
    RSsrc: TableRSsrc,
    Rel16: TableRel16,
}
impl bgezal_instructionVar358 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgezal"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:928:1, end:928:2))"]
#[derive(Clone, Debug)]
struct bgezall_instructionVar359 {
    Rel16: TableRel16,
    RSsrc: TableRSsrc,
}
impl bgezall_instructionVar359 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgezall"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:935:1, end:935:2))"]
#[derive(Clone, Debug)]
struct bgezl_instructionVar360 {
    RSsrc: TableRSsrc,
    Rel16: TableRel16,
}
impl bgezl_instructionVar360 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgezl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:941:1, end:941:2))"]
#[derive(Clone, Debug)]
struct bgtzl_instructionVar361 {
    Rel16: TableRel16,
    RSsrc: TableRSsrc,
}
impl bgtzl_instructionVar361 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgtzl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:947:1, end:947:2))"]
#[derive(Clone, Debug)]
struct blezl_instructionVar362 {
    RSsrc: TableRSsrc,
    Rel16: TableRel16,
}
impl blezl_instructionVar362 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blezl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:953:1, end:953:2))"]
#[derive(Clone, Debug)]
struct bltzal_instructionVar363 {
    RSsrc: TableRSsrc,
    Rel16: TableRel16,
}
impl bltzal_instructionVar363 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltzal"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:961:1, end:961:2))"]
#[derive(Clone, Debug)]
struct bltzall_instructionVar364 {
    RSsrc: TableRSsrc,
    Rel16: TableRel16,
}
impl bltzall_instructionVar364 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltzall"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:968:1, end:968:2))"]
#[derive(Clone, Debug)]
struct bltzl_instructionVar365 {
    RSsrc: TableRSsrc,
    Rel16: TableRel16,
}
impl bltzl_instructionVar365 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltzl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1346:1, end:1346:2))"]
#[derive(Clone, Debug)]
struct teqi_instructionVar366 {
    simmed: u16,
    RSsrc: TableRSsrc,
}
impl teqi_instructionVar366 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teqi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1352:1, end:1352:2))"]
#[derive(Clone, Debug)]
struct tgei_instructionVar367 {
    simmed: u16,
    RSsrc: TableRSsrc,
}
impl tgei_instructionVar367 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tgei"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1358:1, end:1358:2))"]
#[derive(Clone, Debug)]
struct tgeiu_instructionVar368 {
    simmed: u16,
    RSsrc: TableRSsrc,
}
impl tgeiu_instructionVar368 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tgeiu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1364:1, end:1364:2))"]
#[derive(Clone, Debug)]
struct tlti_instructionVar369 {
    simmed: u16,
    RSsrc: TableRSsrc,
}
impl tlti_instructionVar369 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlti"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1370:1, end:1370:2))"]
#[derive(Clone, Debug)]
struct tltiu_instructionVar370 {
    simmed: u16,
    RSsrc: TableRSsrc,
}
impl tltiu_instructionVar370 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tltiu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1376:1, end:1376:2))"]
#[derive(Clone, Debug)]
struct tnei_instructionVar371 {
    simmed: u16,
    RSsrc: TableRSsrc,
}
impl tnei_instructionVar371 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tnei"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1411:1, end:1411:2))"]
#[derive(Clone, Debug)]
struct aluipc_instructionVar372 {
    S16L16: TableS16L16,
    RSsrc: TableRSsrc,
}
impl aluipc_instructionVar372 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("aluipc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.S16L16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S16L16 = if let Some((len, table)) =
            TableS16L16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S16L16, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1420:1, end:1420:2))"]
#[derive(Clone, Debug)]
struct auipc_instructionVar373 {
    S16L16: TableS16L16,
    RSsrc: TableRSsrc,
}
impl auipc_instructionVar373 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("auipc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.S16L16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S16L16 = if let Some((len, table)) =
            TableS16L16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S16L16, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:213:1, end:213:2))"]
#[derive(Clone, Debug)]
struct bposge32_instructionVar374 {
    Rel16: TableRel16,
}
impl bposge32_instructionVar374 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bposge32"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:222:1, end:222:2))"]
#[derive(Clone, Debug)]
struct bposge32c_instructionVar375 {
    Rel16: TableRel16,
}
impl bposge32c_instructionVar375 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bposge32c"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:64:1, end:64:2))"]
#[derive(Clone, Debug)]
struct bgez_instructionVar376 {
    Rel16: TableRel16,
    RSsrc: TableRSsrc,
}
impl bgez_instructionVar376 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgez"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:70:1, end:70:2))"]
#[derive(Clone, Debug)]
struct bgtz_instructionVar377 {
    Rel16: TableRel16,
    RSsrc: TableRSsrc,
}
impl bgtz_instructionVar377 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgtz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:76:1, end:76:2))"]
#[derive(Clone, Debug)]
struct blez_instructionVar378 {
    RSsrc: TableRSsrc,
    Rel16: TableRel16,
}
impl blez_instructionVar378 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blez"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:83:1, end:83:2))"]
#[derive(Clone, Debug)]
struct bltz_instructionVar379 {
    Rel16: TableRel16,
    RSsrc: TableRSsrc,
}
impl bltz_instructionVar379 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:406:1, end:406:2))"]
#[derive(Clone, Debug)]
struct lbx_instructionVar380 {
    RD: TableRD,
    INDEX_BASE: TableINDEX_BASE,
}
impl lbx_instructionVar380 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.INDEX_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let INDEX_BASE = if let Some((len, table)) =
            TableINDEX_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, INDEX_BASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:411:1, end:411:2))"]
#[derive(Clone, Debug)]
struct lhux_instructionVar381 {
    RD: TableRD,
    INDEX_BASE: TableINDEX_BASE,
}
impl lhux_instructionVar381 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhux"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.INDEX_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let INDEX_BASE = if let Some((len, table)) =
            TableINDEX_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, INDEX_BASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:486:1, end:486:2))"]
#[derive(Clone, Debug)]
struct nor_instructionVar382 {
    RD: TableRD,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl nor_instructionVar382 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nor"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:490:1, end:490:2))"]
#[derive(Clone, Debug)]
struct or_instructionVar383 {
    RD: TableRD,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl or_instructionVar383 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:535:1, end:535:2))"]
#[derive(Clone, Debug)]
struct rotrv_instructionVar384 {
    RD32: TableRD32,
    RT32src: TableRT32src,
    RD: TableRD,
    RS32src: TableRS32src,
}
impl rotrv_instructionVar384 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rotrv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD32 = if let Some((len, table)) =
            TableRD32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD32,
                RT32src,
                RD,
                RS32src,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:596:1, end:596:2))"]
#[derive(Clone, Debug)]
struct sllv_instructionVar385 {
    RD: TableRD,
    RD32: TableRD32,
    RS32src: TableRS32src,
    RT32src: TableRT32src,
}
impl sllv_instructionVar385 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sllv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD32 = if let Some((len, table)) =
            TableRD32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD,
                RD32,
                RS32src,
                RT32src,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:604:1, end:604:2))"]
#[derive(Clone, Debug)]
struct slt_instructionVar386 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl slt_instructionVar386 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slt"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:616:1, end:616:2))"]
#[derive(Clone, Debug)]
struct sltu_instructionVar387 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl sltu_instructionVar387 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sltu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:628:1, end:628:2))"]
#[derive(Clone, Debug)]
struct srav_instructionVar388 {
    RD32: TableRD32,
    RT32src: TableRT32src,
    RS32src: TableRS32src,
    RD: TableRD,
}
impl srav_instructionVar388 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srav"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD32 = if let Some((len, table)) =
            TableRD32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD32,
                RT32src,
                RS32src,
                RD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:643:1, end:643:2))"]
#[derive(Clone, Debug)]
struct srlv_instructionVar389 {
    RT32src: TableRT32src,
    RS32src: TableRS32src,
    RD32: TableRD32,
    RD: TableRD,
}
impl srlv_instructionVar389 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srlv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD32 = if let Some((len, table)) =
            TableRD32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32src,
                RS32src,
                RD32,
                RD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:656:1, end:656:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar390 {
    RS32src: TableRS32src,
    RD32: TableRD32,
    RD: TableRD,
    RT32src: TableRT32src,
}
impl sub_instructionVar390 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD32 = if let Some((len, table)) =
            TableRD32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS32src,
                RD32,
                RD,
                RT32src,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:663:1, end:663:2))"]
#[derive(Clone, Debug)]
struct subu_instructionVar391 {
    RT32src: TableRT32src,
    RS32src: TableRS32src,
    RD32: TableRD32,
    RD: TableRD,
}
impl subu_instructionVar391 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD32 = if let Some((len, table)) =
            TableRD32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32src,
                RS32src,
                RD32,
                RD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:796:1, end:796:2))"]
#[derive(Clone, Debug)]
struct xor_instructionVar392 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl xor_instructionVar392 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xor"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:820:1, end:820:2))"]
#[derive(Clone, Debug)]
struct dadd_instructionVar393 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl dadd_instructionVar393 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dadd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:828:1, end:828:2))"]
#[derive(Clone, Debug)]
struct daddu_instructionVar394 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl daddu_instructionVar394 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("daddu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1087:1, end:1087:2))"]
#[derive(Clone, Debug)]
struct lwle_instructionVar395 {
    OFF_BASER6: TableOFF_BASER6,
    RTsrc: TableRTsrc,
    RT: TableRT,
}
impl lwle_instructionVar395 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwle"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                OFF_BASER6,
                RTsrc,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1095:1, end:1095:2))"]
#[derive(Clone, Debug)]
struct lwre_instructionVar396 {
    RTsrc: TableRTsrc,
    RT: TableRT,
    OFF_BASER6: TableOFF_BASER6,
}
impl lwre_instructionVar396 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwre"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                RT,
                OFF_BASER6,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1310:1, end:1310:2))"]
#[derive(Clone, Debug)]
struct swle_instructionVar397 {
    RTsrc: TableRTsrc,
    OFF_BASER6: TableOFF_BASER6,
    RT: TableRT,
}
impl swle_instructionVar397 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swle"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                OFF_BASER6,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1318:1, end:1318:2))"]
#[derive(Clone, Debug)]
struct swre_instructionVar398 {
    RT: TableRT,
    OFF_BASER6: TableOFF_BASER6,
    RTsrc: TableRTsrc,
}
impl swre_instructionVar398 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swre"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                OFF_BASER6,
                RTsrc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1644:1, end:1644:2))"]
#[derive(Clone, Debug)]
struct ll_instructionVar399 {
    RT: TableRT,
    OFF_BASER6: TableOFF_BASER6,
}
impl ll_instructionVar399 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ll"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, OFF_BASER6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1648:1, end:1648:2))"]
#[derive(Clone, Debug)]
struct llx_instructionVar400 {
    OFF_BASER6: TableOFF_BASER6,
    RT: TableRT,
}
impl llx_instructionVar400 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("llx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1652:1, end:1652:2))"]
#[derive(Clone, Debug)]
struct llxe_instructionVar401 {
    OFF_BASER6: TableOFF_BASER6,
    RT: TableRT,
}
impl llxe_instructionVar401 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("llxe"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1710:1, end:1710:2))"]
#[derive(Clone, Debug)]
struct scx_instructionVar402 {
    OFF_BASER6: TableOFF_BASER6,
    RTsrc: TableRTsrc,
}
impl scx_instructionVar402 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("scx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1714:1, end:1714:2))"]
#[derive(Clone, Debug)]
struct scxe_instructionVar403 {
    OFF_BASER6: TableOFF_BASER6,
    RTsrc: TableRTsrc,
}
impl scxe_instructionVar403 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("scxe"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:116:1, end:116:2))"]
#[derive(Clone, Debug)]
struct addq_ph_instructionVar404 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl addq_ph_instructionVar404 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addq.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:120:1, end:120:2))"]
#[derive(Clone, Debug)]
struct addq_s_ph_instructionVar405 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl addq_s_ph_instructionVar405 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addq_s.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:126:1, end:126:2))"]
#[derive(Clone, Debug)]
struct addq_s_w_instructionVar406 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl addq_s_w_instructionVar406 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addq_s.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:132:1, end:132:2))"]
#[derive(Clone, Debug)]
struct addqh_ph_instructionVar407 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl addqh_ph_instructionVar407 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addqh.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:136:1, end:136:2))"]
#[derive(Clone, Debug)]
struct addqh_r_ph_instructionVar408 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl addqh_r_ph_instructionVar408 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addqh_r.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:142:1, end:142:2))"]
#[derive(Clone, Debug)]
struct addqh_w_instructionVar409 {
    RD: TableRD,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl addqh_w_instructionVar409 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addqh.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:146:1, end:146:2))"]
#[derive(Clone, Debug)]
struct addqh_r_w_instructionVar410 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl addqh_r_w_instructionVar410 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addqh_r.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:152:1, end:152:2))"]
#[derive(Clone, Debug)]
struct addsc_instructionVar411 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl addsc_instructionVar411 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addsc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:158:1, end:158:2))"]
#[derive(Clone, Debug)]
struct addu_ph_instructionVar412 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl addu_ph_instructionVar412 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addu.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:162:1, end:162:2))"]
#[derive(Clone, Debug)]
struct addu_s_ph_instructionVar413 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl addu_s_ph_instructionVar413 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addu_s.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:168:1, end:168:2))"]
#[derive(Clone, Debug)]
struct addu_qb_instructionVar414 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl addu_qb_instructionVar414 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addu.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:172:1, end:172:2))"]
#[derive(Clone, Debug)]
struct addu_s_qb_instructionVar415 {
    RD: TableRD,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl addu_s_qb_instructionVar415 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addu_s.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:178:1, end:178:2))"]
#[derive(Clone, Debug)]
struct addwc_instructionVar416 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl addwc_instructionVar416 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addwc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:184:1, end:184:2))"]
#[derive(Clone, Debug)]
struct adduh_qb_instructionVar417 {
    RD: TableRD,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl adduh_qb_instructionVar417 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adduh.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:188:1, end:188:2))"]
#[derive(Clone, Debug)]
struct adduh_r_qb_instructionVar418 {
    RD: TableRD,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl adduh_r_qb_instructionVar418 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adduh_r.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:194:1, end:194:2))"]
#[derive(Clone, Debug)]
struct append_instructionVar419 {
    sa_dsp: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl append_instructionVar419 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("append"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RSsrc,
                RTsrc,
                sa_dsp,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:264:1, end:264:2))"]
#[derive(Clone, Debug)]
struct cmpgdu_eq_qb_instructionVar420 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl cmpgdu_eq_qb_instructionVar420 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpgdu.eq.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:282:1, end:282:2))"]
#[derive(Clone, Debug)]
struct cmpgdu_lt_qb_instructionVar421 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl cmpgdu_lt_qb_instructionVar421 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpgdu.lt.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:300:1, end:300:2))"]
#[derive(Clone, Debug)]
struct cmpgdu_le_qb_instructionVar422 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl cmpgdu_le_qb_instructionVar422 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpgdu.le.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:320:1, end:320:2))"]
#[derive(Clone, Debug)]
struct cmpgu_eq_qb_instructionVar423 {
    RD: TableRD,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl cmpgu_eq_qb_instructionVar423 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpgu.eq.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:336:1, end:336:2))"]
#[derive(Clone, Debug)]
struct cmpgu_lt_qb_instructionVar424 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl cmpgu_lt_qb_instructionVar424 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpgu.lt.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:352:1, end:352:2))"]
#[derive(Clone, Debug)]
struct cmpgu_le_qb_instructionVar425 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl cmpgu_le_qb_instructionVar425 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpgu.le.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:609:1, end:609:2))"]
#[derive(Clone, Debug)]
struct lbux_instructionVar426 {
    INDEX_BASE: TableINDEX_BASE,
    RD: TableRD,
}
impl lbux_instructionVar426 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbux"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.INDEX_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let INDEX_BASE = if let Some((len, table)) =
            TableINDEX_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { INDEX_BASE, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:621:1, end:621:2))"]
#[derive(Clone, Debug)]
struct lhx_instructionVar427 {
    RD: TableRD,
    INDEX_BASE: TableINDEX_BASE,
}
impl lhx_instructionVar427 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.INDEX_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let INDEX_BASE = if let Some((len, table)) =
            TableINDEX_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, INDEX_BASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:627:1, end:627:2))"]
#[derive(Clone, Debug)]
struct lwx_instructionVar428 {
    RD: TableRD,
    INDEX_BASE: TableINDEX_BASE,
}
impl lwx_instructionVar428 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.INDEX_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let INDEX_BASE = if let Some((len, table)) =
            TableINDEX_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, INDEX_BASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:687:1, end:687:2))"]
#[derive(Clone, Debug)]
struct modsub_instructionVar429 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl modsub_instructionVar429 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("modsub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:735:1, end:735:2))"]
#[derive(Clone, Debug)]
struct mul_ph_instructionVar430 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl mul_ph_instructionVar430 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:739:1, end:739:2))"]
#[derive(Clone, Debug)]
struct mul_s_ph_instructionVar431 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl mul_s_ph_instructionVar431 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul_s.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:745:1, end:745:2))"]
#[derive(Clone, Debug)]
struct muleq_s_w_phl_instructionVar432 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl muleq_s_w_phl_instructionVar432 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("muleq_s.w.phl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:751:1, end:751:2))"]
#[derive(Clone, Debug)]
struct muleq_s_w_phr_instructionVar433 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl muleq_s_w_phr_instructionVar433 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("muleq_s.w.phr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:757:1, end:757:2))"]
#[derive(Clone, Debug)]
struct muleu_s_ph_qbl_instructionVar434 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl muleu_s_ph_qbl_instructionVar434 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("muleu_s.ph.qbl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:763:1, end:763:2))"]
#[derive(Clone, Debug)]
struct muleu_s_ph_qbr_instructionVar435 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl muleu_s_ph_qbr_instructionVar435 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("muleu_s.ph.qbr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:769:1, end:769:2))"]
#[derive(Clone, Debug)]
struct mulq_rs_ph_instructionVar436 {
    RD: TableRD,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl mulq_rs_ph_instructionVar436 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulq_rs.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:775:1, end:775:2))"]
#[derive(Clone, Debug)]
struct mulq_rs_w_instructionVar437 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl mulq_rs_w_instructionVar437 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulq_rs.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:781:1, end:781:2))"]
#[derive(Clone, Debug)]
struct mulq_s_ph_instructionVar438 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl mulq_s_ph_instructionVar438 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulq_s.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:787:1, end:787:2))"]
#[derive(Clone, Debug)]
struct mulq_s_w_instructionVar439 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl mulq_s_w_instructionVar439 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulq_s.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:821:1, end:821:2))"]
#[derive(Clone, Debug)]
struct packrl_ph_instructionVar440 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl packrl_ph_instructionVar440 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("packrl.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:829:1, end:829:2))"]
#[derive(Clone, Debug)]
struct pick_ph_instructionVar441 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl pick_ph_instructionVar441 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pick.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:846:1, end:846:2))"]
#[derive(Clone, Debug)]
struct pick_qb_instructionVar442 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl pick_qb_instructionVar442 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pick.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:933:1, end:933:2))"]
#[derive(Clone, Debug)]
struct precr_qb_ph_instructionVar443 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl precr_qb_ph_instructionVar443 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("precr.qb.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:939:1, end:939:2))"]
#[derive(Clone, Debug)]
struct precr_sra_ph_w_instructionVar444 {
    rt: u8,
    rs: u8,
    sa_dsp: u8,
}
impl precr_sra_ph_w_instructionVar444 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("precr_sra.ph.w"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rt),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rt = token_20(tokens_current);
        let sa_dsp = token_28(tokens_current);
        let rs = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rt, rs, sa_dsp }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:943:1, end:943:2))"]
#[derive(Clone, Debug)]
struct precr_sra_r_ph_w_instructionVar445 {
    rt: u8,
    rs: u8,
    sa_dsp: u8,
}
impl precr_sra_r_ph_w_instructionVar445 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("precr_sra_r.ph.w"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rt),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sa_dsp = token_28(tokens_current);
        let rs = token_6(tokens_current);
        let rt = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rt, rs, sa_dsp }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:949:1, end:949:2))"]
#[derive(Clone, Debug)]
struct precrq_ph_w_instructionVar446 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl precrq_ph_w_instructionVar446 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("precrq.ph.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:955:1, end:955:2))"]
#[derive(Clone, Debug)]
struct precrq_qb_ph_instructionVar447 {
    RD: TableRD,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl precrq_qb_ph_instructionVar447 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("precrq.qb.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:961:1, end:961:2))"]
#[derive(Clone, Debug)]
struct precrqu_s_qb_ph_instructionVar448 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl precrqu_s_qb_ph_instructionVar448 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("precrqu_s.qb.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:967:1, end:967:2))"]
#[derive(Clone, Debug)]
struct precrq_rs_ph_w_instructionVar449 {
    RD: TableRD,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl precrq_rs_ph_w_instructionVar449 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("precrq_rs.ph.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:973:1, end:973:2))"]
#[derive(Clone, Debug)]
struct prepend_instructionVar450 {
    sa_dsp: u8,
    RT: TableRT,
    RSsrc: TableRSsrc,
}
impl prepend_instructionVar450 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("prepend"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, RSsrc, sa_dsp }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:988:1, end:988:2))"]
#[derive(Clone, Debug)]
struct rddsp_instructionVar451 {
    immed1625: u16,
    RD: TableRD,
}
impl rddsp_instructionVar451 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rddsp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.immed1625 & 512 != 0 {
                    -1 & !511
                } else {
                    0
                } | self.immed1625 as i16)
                    .is_negative(),
                (if self.immed1625 & 512 != 0 {
                    -1 & !511
                } else {
                    0
                } | self.immed1625 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed1625 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, immed1625 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:998:1, end:998:2))"]
#[derive(Clone, Debug)]
struct repl_ph_instructionVar452 {
    immed1625: u16,
    RD: TableRD,
}
impl repl_ph_instructionVar452 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("repl.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.immed1625 & 512 != 0 {
                    -1 & !511
                } else {
                    0
                } | self.immed1625 as i16)
                    .is_negative(),
                (if self.immed1625 & 512 != 0 {
                    -1 & !511
                } else {
                    0
                } | self.immed1625 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed1625 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, immed1625 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1051:1, end:1051:2))"]
#[derive(Clone, Debug)]
struct shll_qb_instructionVar453 {
    sa_dsp2: u8,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl shll_qb_instructionVar453 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shll.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp2 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc, sa_dsp2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1058:1, end:1058:2))"]
#[derive(Clone, Debug)]
struct shllv_ph_instructionVar454 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl shllv_ph_instructionVar454 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shllv.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1062:1, end:1062:2))"]
#[derive(Clone, Debug)]
struct shllv_s_ph_instructionVar455 {
    RD: TableRD,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl shllv_s_ph_instructionVar455 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shllv_s.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1068:1, end:1068:2))"]
#[derive(Clone, Debug)]
struct shllv_qb_instructionVar456 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl shllv_qb_instructionVar456 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shllv.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1074:1, end:1074:2))"]
#[derive(Clone, Debug)]
struct shllv_s_w_instructionVar457 {
    RD: TableRD,
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl shllv_s_w_instructionVar457 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shllv_s.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1080:1, end:1080:2))"]
#[derive(Clone, Debug)]
struct shll_s_w_instructionVar458 {
    sa_dsp2: u8,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl shll_s_w_instructionVar458 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shll_s.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp2 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc, sa_dsp2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1087:1, end:1087:2))"]
#[derive(Clone, Debug)]
struct shra_qb_instructionVar459 {
    sa_dsp2: u8,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl shra_qb_instructionVar459 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shra.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp2 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc, sa_dsp2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1092:1, end:1092:2))"]
#[derive(Clone, Debug)]
struct shra_r_qb_instructionVar460 {
    sa_dsp2: u8,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl shra_r_qb_instructionVar460 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shra_r.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp2 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, sa_dsp2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1111:1, end:1111:2))"]
#[derive(Clone, Debug)]
struct shrav_ph_instructionVar461 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl shrav_ph_instructionVar461 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shrav.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1115:1, end:1115:2))"]
#[derive(Clone, Debug)]
struct shrav_r_ph_instructionVar462 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl shrav_r_ph_instructionVar462 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shrav_r.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1121:1, end:1121:2))"]
#[derive(Clone, Debug)]
struct shrav_qb_instructionVar463 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl shrav_qb_instructionVar463 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shrav.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1125:1, end:1125:2))"]
#[derive(Clone, Debug)]
struct shrav_r_qb_instructionVar464 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl shrav_r_qb_instructionVar464 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shrav_r.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1131:1, end:1131:2))"]
#[derive(Clone, Debug)]
struct shrav_r_w_instructionVar465 {
    RD: TableRD,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl shrav_r_w_instructionVar465 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shrav_r.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1137:1, end:1137:2))"]
#[derive(Clone, Debug)]
struct shra_r_w_instructionVar466 {
    sa_dsp2: u8,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl shra_r_w_instructionVar466 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shra_r.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp2 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RTsrc, sa_dsp2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1151:1, end:1151:2))"]
#[derive(Clone, Debug)]
struct shrl_qb_instructionVar467 {
    sa_dsp2: u8,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl shrl_qb_instructionVar467 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shrl.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa_dsp2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa_dsp2 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, sa_dsp2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1158:1, end:1158:2))"]
#[derive(Clone, Debug)]
struct shrlv_ph_instructionVar468 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl shrlv_ph_instructionVar468 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shrlv.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1164:1, end:1164:2))"]
#[derive(Clone, Debug)]
struct shrlv_qb_instructionVar469 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl shrlv_qb_instructionVar469 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("shrlv.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1170:1, end:1170:2))"]
#[derive(Clone, Debug)]
struct subq_ph_instructionVar470 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl subq_ph_instructionVar470 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subq.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1174:1, end:1174:2))"]
#[derive(Clone, Debug)]
struct subq_s_ph_instructionVar471 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl subq_s_ph_instructionVar471 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subq_s.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1180:1, end:1180:2))"]
#[derive(Clone, Debug)]
struct subq_s_w_instructionVar472 {
    RD: TableRD,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl subq_s_w_instructionVar472 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subq_s.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1186:1, end:1186:2))"]
#[derive(Clone, Debug)]
struct subqh_ph_instructionVar473 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    RD: TableRD,
}
impl subqh_ph_instructionVar473 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subqh.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1190:1, end:1190:2))"]
#[derive(Clone, Debug)]
struct subqh_r_ph_instructionVar474 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl subqh_r_ph_instructionVar474 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subqh_r.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1196:1, end:1196:2))"]
#[derive(Clone, Debug)]
struct subqh_w_instructionVar475 {
    RSsrc: TableRSsrc,
    RD: TableRD,
    RTsrc: TableRTsrc,
}
impl subqh_w_instructionVar475 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subqh.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RD, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1200:1, end:1200:2))"]
#[derive(Clone, Debug)]
struct subqh_r_w_instructionVar476 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl subqh_r_w_instructionVar476 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subqh_r.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1206:1, end:1206:2))"]
#[derive(Clone, Debug)]
struct subu_ph_instructionVar477 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl subu_ph_instructionVar477 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subu.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1210:1, end:1210:2))"]
#[derive(Clone, Debug)]
struct subu_s_ph_instructionVar478 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl subu_s_ph_instructionVar478 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subu_s.ph"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1216:1, end:1216:2))"]
#[derive(Clone, Debug)]
struct subu_qb_instructionVar479 {
    RD: TableRD,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl subu_qb_instructionVar479 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subu.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1220:1, end:1220:2))"]
#[derive(Clone, Debug)]
struct subu_s_qb_instructionVar480 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl subu_s_qb_instructionVar480 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subu_s.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1226:1, end:1226:2))"]
#[derive(Clone, Debug)]
struct subuh_qb_instructionVar481 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl subuh_qb_instructionVar481 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subuh.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1230:1, end:1230:2))"]
#[derive(Clone, Debug)]
struct subuh_r_qb_instructionVar482 {
    RTsrc: TableRTsrc,
    RD: TableRD,
    RSsrc: TableRSsrc,
}
impl subuh_r_qb_instructionVar482 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subuh_r.qb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RD, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips_dsp.sinc, start:1236:1, end:1236:2))"]
#[derive(Clone, Debug)]
struct wrdsp_instructionVar483 {
    mask: u16,
    RSsrc: TableRSsrc,
}
impl wrdsp_instructionVar483 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrdsp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mask as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mask = token_27(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, mask }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:106:1, end:106:2))"]
#[derive(Clone, Debug)]
struct cachee_instructionVar484 {
    op: u8,
    OFF_BASER6: TableOFF_BASER6,
}
impl cachee_instructionVar484 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cachee"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.op as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let op = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, op }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:362:1, end:362:2))"]
#[derive(Clone, Debug)]
struct lbe_instructionVar485 {
    OFF_BASER6: TableOFF_BASER6,
    RT: TableRT,
}
impl lbe_instructionVar485 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbe"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:371:1, end:371:2))"]
#[derive(Clone, Debug)]
struct lbue_instructionVar486 {
    OFF_BASER6: TableOFF_BASER6,
    RT: TableRT,
}
impl lbue_instructionVar486 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbue"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:380:1, end:380:2))"]
#[derive(Clone, Debug)]
struct lhe_instructionVar487 {
    OFF_BASER6: TableOFF_BASER6,
    RT: TableRT,
}
impl lhe_instructionVar487 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhe"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:389:1, end:389:2))"]
#[derive(Clone, Debug)]
struct lhue_instructionVar488 {
    OFF_BASER6: TableOFF_BASER6,
    RT: TableRT,
}
impl lhue_instructionVar488 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhue"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:393:1, end:393:2))"]
#[derive(Clone, Debug)]
struct lle_instructionVar489 {
    OFF_BASER6: TableOFF_BASER6,
    RT: TableRT,
}
impl lle_instructionVar489 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lle"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:402:1, end:402:2))"]
#[derive(Clone, Debug)]
struct lwe_instructionVar490 {
    OFF_BASER6: TableOFF_BASER6,
    RT: TableRT,
}
impl lwe_instructionVar490 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwe"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:506:1, end:506:2))"]
#[derive(Clone, Debug)]
struct prefe_instructionVar491 {
    hint: u8,
    OFF_BASER6: TableOFF_BASER6,
}
impl prefe_instructionVar491 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("prefe"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_36_display(self.hint),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let hint = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, hint }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:516:1, end:516:2))"]
#[derive(Clone, Debug)]
struct rdhwr_instructionVar492 {
    rd_hw: u8,
    sel_0608: u8,
    RT: TableRT,
}
impl rdhwr_instructionVar492 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdhwr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_1_display(self.rd_hw),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sel_0608 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd_hw = token_28(tokens_current);
        let sel_0608 = token_38(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                rd_hw,
                sel_0608,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:734:1, end:734:2))"]
#[derive(Clone, Debug)]
struct movf_S_instructionVar493 {
    fd: u8,
    fs: u8,
    cc: u8,
    fmt1: Tablefmt1,
}
impl movf_S_instructionVar493 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movf.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let cc = token_17(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:741:1, end:741:2))"]
#[derive(Clone, Debug)]
struct movf_D_instructionVar494 {
    fd: u8,
    fs: u8,
    cc: u8,
    fmt1: Tablefmt1,
}
impl movf_D_instructionVar494 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movf.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let cc = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:748:1, end:748:2))"]
#[derive(Clone, Debug)]
struct movf_PS_instructionVar495 {
    fd: u8,
    fs: u8,
    cc: u8,
    fmt1: Tablefmt1,
}
impl movf_PS_instructionVar495 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movf.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cc = token_17(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:777:1, end:777:2))"]
#[derive(Clone, Debug)]
struct movt_S_instructionVar496 {
    fd: u8,
    fs: u8,
    cc: u8,
    fmt1: Tablefmt1,
}
impl movt_S_instructionVar496 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movt.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let cc = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:784:1, end:784:2))"]
#[derive(Clone, Debug)]
struct movt_D_instructionVar497 {
    fd: u8,
    fs: u8,
    cc: u8,
    fmt1: Tablefmt1,
}
impl movt_D_instructionVar497 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movt.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let cc = token_17(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:791:1, end:791:2))"]
#[derive(Clone, Debug)]
struct movt_PS_instructionVar498 {
    fd: u8,
    fs: u8,
    cc: u8,
    fmt1: Tablefmt1,
}
impl movt_PS_instructionVar498 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movt.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cc = token_17(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1233:1, end:1233:2))"]
#[derive(Clone, Debug)]
struct pll_ps_instructionVar499 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl pll_ps_instructionVar499 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pll.ps"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1237:1, end:1237:2))"]
#[derive(Clone, Debug)]
struct plu_ps_instructionVar500 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl plu_ps_instructionVar500 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("plu.ps"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1243:1, end:1243:2))"]
#[derive(Clone, Debug)]
struct pul_ps_instructionVar501 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl pul_ps_instructionVar501 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pul.ps"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1246:1, end:1246:2))"]
#[derive(Clone, Debug)]
struct puu_ps_instructionVar502 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl puu_ps_instructionVar502 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("puu.ps"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:25:1, end:25:2))"]
#[derive(Clone, Debug)]
struct abs_PS_instructionVar503 {
    fd: u8,
    fs: u8,
    fmt1: Tablefmt1,
}
impl abs_PS_instructionVar503 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("abs.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:36:1, end:36:2))"]
#[derive(Clone, Debug)]
struct add_PS_instructionVar504 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl add_PS_instructionVar504 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:140:1, end:140:2))"]
#[derive(Clone, Debug)]
struct cvt_PS_S_instructionVar505 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl cvt_PS_S_instructionVar505 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.PS.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdD = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:254:1, end:254:2))"]
#[derive(Clone, Debug)]
struct mov_PS_instructionVar506 {
    fd: u8,
    fs: u8,
    fmt1: Tablefmt1,
}
impl mov_PS_instructionVar506 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:277:1, end:277:2))"]
#[derive(Clone, Debug)]
struct mul_PS_instructionVar507 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl mul_PS_instructionVar507 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:288:1, end:288:2))"]
#[derive(Clone, Debug)]
struct neg_PS_instructionVar508 {
    fd: u8,
    fs: u8,
    fmt1: Tablefmt1,
}
impl neg_PS_instructionVar508 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("neg.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:344:1, end:344:2))"]
#[derive(Clone, Debug)]
struct sub_PS_instructionVar509 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl sub_PS_instructionVar509 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub.PS"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.fmt1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:530:1, end:530:2))"]
#[derive(Clone, Debug)]
struct c_f_S_instructionVar510 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_f_S_instructionVar510 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.f.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:534:1, end:534:2))"]
#[derive(Clone, Debug)]
struct c_f_D_instructionVar511 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_f_D_instructionVar511 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.f.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:538:1, end:538:2))"]
#[derive(Clone, Debug)]
struct c_f_PS_instructionVar512 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_f_PS_instructionVar512 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.f.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fdD = token_37(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:542:1, end:542:2))"]
#[derive(Clone, Debug)]
struct c_un_S_instructionVar513 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_un_S_instructionVar513 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.un.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:546:1, end:546:2))"]
#[derive(Clone, Debug)]
struct c_un_D_instructionVar514 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_un_D_instructionVar514 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.un.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:550:1, end:550:2))"]
#[derive(Clone, Debug)]
struct c_un_PS_instructionVar515 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_un_PS_instructionVar515 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.un.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:554:1, end:554:2))"]
#[derive(Clone, Debug)]
struct c_eq_S_instructionVar516 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_eq_S_instructionVar516 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.eq.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:558:1, end:558:2))"]
#[derive(Clone, Debug)]
struct c_eq_D_instructionVar517 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_eq_D_instructionVar517 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.eq.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:562:1, end:562:2))"]
#[derive(Clone, Debug)]
struct c_eq_PS_instructionVar518 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_eq_PS_instructionVar518 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.eq.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:566:1, end:566:2))"]
#[derive(Clone, Debug)]
struct c_ueq_S_instructionVar519 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ueq_S_instructionVar519 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ueq.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:570:1, end:570:2))"]
#[derive(Clone, Debug)]
struct c_ueq_D_instructionVar520 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ueq_D_instructionVar520 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ueq.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:574:1, end:574:2))"]
#[derive(Clone, Debug)]
struct c_ueq_PS_instructionVar521 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ueq_PS_instructionVar521 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ueq.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:578:1, end:578:2))"]
#[derive(Clone, Debug)]
struct c_olt_S_instructionVar522 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_olt_S_instructionVar522 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.olt.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:582:1, end:582:2))"]
#[derive(Clone, Debug)]
struct c_olt_D_instructionVar523 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_olt_D_instructionVar523 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.olt.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:586:1, end:586:2))"]
#[derive(Clone, Debug)]
struct c_olt_PS_instructionVar524 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_olt_PS_instructionVar524 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.olt.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:590:1, end:590:2))"]
#[derive(Clone, Debug)]
struct c_ult_S_instructionVar525 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ult_S_instructionVar525 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ult.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:594:1, end:594:2))"]
#[derive(Clone, Debug)]
struct c_ult_D_instructionVar526 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ult_D_instructionVar526 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ult.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:598:1, end:598:2))"]
#[derive(Clone, Debug)]
struct c_ult_PS_instructionVar527 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ult_PS_instructionVar527 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ult.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:602:1, end:602:2))"]
#[derive(Clone, Debug)]
struct c_ole_S_instructionVar528 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ole_S_instructionVar528 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ole.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:606:1, end:606:2))"]
#[derive(Clone, Debug)]
struct c_ole_D_instructionVar529 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ole_D_instructionVar529 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ole.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:610:1, end:610:2))"]
#[derive(Clone, Debug)]
struct c_ole_PS_instructionVar530 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ole_PS_instructionVar530 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ole.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:614:1, end:614:2))"]
#[derive(Clone, Debug)]
struct c_ule_S_instructionVar531 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ule_S_instructionVar531 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ule.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:618:1, end:618:2))"]
#[derive(Clone, Debug)]
struct c_ule_D_instructionVar532 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ule_D_instructionVar532 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ule.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:622:1, end:622:2))"]
#[derive(Clone, Debug)]
struct c_ule_PS_instructionVar533 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ule_PS_instructionVar533 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ule.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:628:1, end:628:2))"]
#[derive(Clone, Debug)]
struct c_sf_S_instructionVar534 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_sf_S_instructionVar534 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.sf.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:632:1, end:632:2))"]
#[derive(Clone, Debug)]
struct c_sf_D_instructionVar535 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_sf_D_instructionVar535 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.sf.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:636:1, end:636:2))"]
#[derive(Clone, Debug)]
struct c_sf_PS_instructionVar536 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_sf_PS_instructionVar536 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.sf.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:640:1, end:640:2))"]
#[derive(Clone, Debug)]
struct c_ngle_S_instructionVar537 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ngle_S_instructionVar537 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngle.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:644:1, end:644:2))"]
#[derive(Clone, Debug)]
struct c_ngle_D_instructionVar538 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ngle_D_instructionVar538 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngle.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ftD = token_20(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:648:1, end:648:2))"]
#[derive(Clone, Debug)]
struct c_ngle_PS_instructionVar539 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ngle_PS_instructionVar539 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngle.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:652:1, end:652:2))"]
#[derive(Clone, Debug)]
struct c_seq_S_instructionVar540 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_seq_S_instructionVar540 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.seq.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:656:1, end:656:2))"]
#[derive(Clone, Debug)]
struct c_seq_D_instructionVar541 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_seq_D_instructionVar541 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.seq.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:660:1, end:660:2))"]
#[derive(Clone, Debug)]
struct c_seq_PS_instructionVar542 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_seq_PS_instructionVar542 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.seq.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:664:1, end:664:2))"]
#[derive(Clone, Debug)]
struct c_ngl_S_instructionVar543 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ngl_S_instructionVar543 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngl.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:668:1, end:668:2))"]
#[derive(Clone, Debug)]
struct c_ngl_D_instructionVar544 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ngl_D_instructionVar544 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngl.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:672:1, end:672:2))"]
#[derive(Clone, Debug)]
struct c_ngl_PS_instructionVar545 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ngl_PS_instructionVar545 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngl.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:676:1, end:676:2))"]
#[derive(Clone, Debug)]
struct c_lt_S_instructionVar546 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_lt_S_instructionVar546 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.lt.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:680:1, end:680:2))"]
#[derive(Clone, Debug)]
struct c_lt_D_instructionVar547 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_lt_D_instructionVar547 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.lt.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:684:1, end:684:2))"]
#[derive(Clone, Debug)]
struct c_lt_PS_instructionVar548 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_lt_PS_instructionVar548 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.lt.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:688:1, end:688:2))"]
#[derive(Clone, Debug)]
struct c_nge_S_instructionVar549 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_nge_S_instructionVar549 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.nge.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:692:1, end:692:2))"]
#[derive(Clone, Debug)]
struct c_nge_D_instructionVar550 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_nge_D_instructionVar550 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.nge.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ftD = token_20(tokens_current);
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:696:1, end:696:2))"]
#[derive(Clone, Debug)]
struct c_nge_PS_instructionVar551 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_nge_PS_instructionVar551 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.nge.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:700:1, end:700:2))"]
#[derive(Clone, Debug)]
struct c_le_S_instructionVar552 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_le_S_instructionVar552 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.le.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:704:1, end:704:2))"]
#[derive(Clone, Debug)]
struct c_le_D_instructionVar553 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_le_D_instructionVar553 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.le.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:708:1, end:708:2))"]
#[derive(Clone, Debug)]
struct c_le_PS_instructionVar554 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_le_PS_instructionVar554 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.le.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ftD = token_20(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:712:1, end:712:2))"]
#[derive(Clone, Debug)]
struct c_ngt_S_instructionVar555 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ngt_S_instructionVar555 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngt.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:716:1, end:716:2))"]
#[derive(Clone, Debug)]
struct c_ngt_D_instructionVar556 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ngt_D_instructionVar556 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngt.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:720:1, end:720:2))"]
#[derive(Clone, Debug)]
struct c_ngt_PS_instructionVar557 {
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl c_ngt_PS_instructionVar557 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngt.PS"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:753:1, end:753:2))"]
#[derive(Clone, Debug)]
struct movn_S_instructionVar558 {
    fd: u8,
    fs: u8,
    fmt1: Tablefmt1,
    RTsrc: TableRTsrc,
}
impl movn_S_instructionVar558 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movn.S"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt1,
                RTsrc,
                fd,
                fs,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:758:1, end:758:2))"]
#[derive(Clone, Debug)]
struct movn_D_instructionVar559 {
    fd: u8,
    fs: u8,
    fmt1: Tablefmt1,
    RTsrc: TableRTsrc,
}
impl movn_D_instructionVar559 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movn.D"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt1,
                RTsrc,
                fd,
                fs,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:763:1, end:763:2))"]
#[derive(Clone, Debug)]
struct movn_PS_instructionVar560 {
    fd: u8,
    fs: u8,
    RTsrc: TableRTsrc,
    fmt1: Tablefmt1,
}
impl movn_PS_instructionVar560 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movn.PS"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                fmt1,
                fd,
                fs,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:796:1, end:796:2))"]
#[derive(Clone, Debug)]
struct movz_S_instructionVar561 {
    fd: u8,
    fs: u8,
    RTsrc: TableRTsrc,
    fmt1: Tablefmt1,
}
impl movz_S_instructionVar561 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movz.S"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                fmt1,
                fd,
                fs,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:801:1, end:801:2))"]
#[derive(Clone, Debug)]
struct movz_D_instructionVar562 {
    fd: u8,
    fs: u8,
    RTsrc: TableRTsrc,
    fmt1: Tablefmt1,
}
impl movz_D_instructionVar562 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movz.D"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                fmt1,
                fd,
                fs,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:806:1, end:806:2))"]
#[derive(Clone, Debug)]
struct movz_PS_instructionVar563 {
    fd: u8,
    fs: u8,
    RTsrc: TableRTsrc,
    fmt1: Tablefmt1,
}
impl movz_PS_instructionVar563 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movz.PS"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                fmt1,
                fd,
                fs,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:908:1, end:908:2))"]
#[derive(Clone, Debug)]
struct sel_S_instructionVar564 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl sel_S_instructionVar564 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sel.S"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:914:1, end:914:2))"]
#[derive(Clone, Debug)]
struct sel_D_instructionVar565 {
    fd: u8,
    fs: u8,
    ft: u8,
}
impl sel_D_instructionVar565 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sel.D"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:934:1, end:934:2))"]
#[derive(Clone, Debug)]
struct cmp_af_S_instructionVar566 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_af_S_instructionVar566 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.af.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:938:1, end:938:2))"]
#[derive(Clone, Debug)]
struct cmp_af_D_instructionVar567 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_af_D_instructionVar567 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.af.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:943:1, end:943:2))"]
#[derive(Clone, Debug)]
struct cmp_un_S_instructionVar568 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_un_S_instructionVar568 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.un.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:947:1, end:947:2))"]
#[derive(Clone, Debug)]
struct cmp_un_D_instructionVar569 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_un_D_instructionVar569 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.un.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:952:1, end:952:2))"]
#[derive(Clone, Debug)]
struct cmp_or_S_instructionVar570 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_or_S_instructionVar570 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.or.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:956:1, end:956:2))"]
#[derive(Clone, Debug)]
struct cmp_or_D_instructionVar571 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_or_D_instructionVar571 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.or.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:961:1, end:961:2))"]
#[derive(Clone, Debug)]
struct cmp_eq_S_instructionVar572 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_eq_S_instructionVar572 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.eq.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:965:1, end:965:2))"]
#[derive(Clone, Debug)]
struct cmp_eq_D_instructionVar573 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_eq_D_instructionVar573 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.eq.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:970:1, end:970:2))"]
#[derive(Clone, Debug)]
struct cmp_une_S_instructionVar574 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_une_S_instructionVar574 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.une.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:975:1, end:975:2))"]
#[derive(Clone, Debug)]
struct cmp_une_D_instructionVar575 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_une_D_instructionVar575 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.une.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:980:1, end:980:2))"]
#[derive(Clone, Debug)]
struct cmp_ueq_S_instructionVar576 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_ueq_S_instructionVar576 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ueq.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:985:1, end:985:2))"]
#[derive(Clone, Debug)]
struct cmp_ueq_D_instructionVar577 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_ueq_D_instructionVar577 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ueq.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:990:1, end:990:2))"]
#[derive(Clone, Debug)]
struct cmp_ne_S_instructionVar578 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_ne_S_instructionVar578 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ne.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:995:1, end:995:2))"]
#[derive(Clone, Debug)]
struct cmp_ne_D_instructionVar579 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_ne_D_instructionVar579 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ne.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1000:1, end:1000:2))"]
#[derive(Clone, Debug)]
struct cmp_lt_S_instructionVar580 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_lt_S_instructionVar580 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.lt.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1004:1, end:1004:2))"]
#[derive(Clone, Debug)]
struct cmp_lt_D_instructionVar581 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_lt_D_instructionVar581 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.lt.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1009:1, end:1009:2))"]
#[derive(Clone, Debug)]
struct cmp_ult_S_instructionVar582 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_ult_S_instructionVar582 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ult.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1014:1, end:1014:2))"]
#[derive(Clone, Debug)]
struct cmp_ult_D_instructionVar583 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_ult_D_instructionVar583 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ult.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1019:1, end:1019:2))"]
#[derive(Clone, Debug)]
struct cmp_le_S_instructionVar584 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_le_S_instructionVar584 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.le.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1024:1, end:1024:2))"]
#[derive(Clone, Debug)]
struct cmp_le_D_instructionVar585 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_le_D_instructionVar585 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.le.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1029:1, end:1029:2))"]
#[derive(Clone, Debug)]
struct cmp_ule_S_instructionVar586 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_ule_S_instructionVar586 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ule.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1034:1, end:1034:2))"]
#[derive(Clone, Debug)]
struct cmp_ule_D_instructionVar587 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_ule_D_instructionVar587 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ule.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1041:1, end:1041:2))"]
#[derive(Clone, Debug)]
struct cmp_saf_S_instructionVar588 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_saf_S_instructionVar588 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.saf.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1045:1, end:1045:2))"]
#[derive(Clone, Debug)]
struct cmp_saf_D_instructionVar589 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_saf_D_instructionVar589 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.saf.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1050:1, end:1050:2))"]
#[derive(Clone, Debug)]
struct cmp_sun_S_instructionVar590 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sun_S_instructionVar590 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sun.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1054:1, end:1054:2))"]
#[derive(Clone, Debug)]
struct cmp_sun_D_instructionVar591 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sun_D_instructionVar591 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sun.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fdD = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1059:1, end:1059:2))"]
#[derive(Clone, Debug)]
struct cmp_sor_S_instructionVar592 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sor_S_instructionVar592 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sor.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1063:1, end:1063:2))"]
#[derive(Clone, Debug)]
struct cmp_sor_D_instructionVar593 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sor_D_instructionVar593 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sor.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1068:1, end:1068:2))"]
#[derive(Clone, Debug)]
struct cmp_seq_S_instructionVar594 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_seq_S_instructionVar594 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.seq.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1072:1, end:1072:2))"]
#[derive(Clone, Debug)]
struct cmp_seq_D_instructionVar595 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_seq_D_instructionVar595 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.seq.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1077:1, end:1077:2))"]
#[derive(Clone, Debug)]
struct cmp_sune_S_instructionVar596 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sune_S_instructionVar596 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sune.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1081:1, end:1081:2))"]
#[derive(Clone, Debug)]
struct cmp_sune_D_instructionVar597 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sune_D_instructionVar597 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sune.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1086:1, end:1086:2))"]
#[derive(Clone, Debug)]
struct cmp_sueq_S_instructionVar598 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sueq_S_instructionVar598 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sueq.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1091:1, end:1091:2))"]
#[derive(Clone, Debug)]
struct cmp_sueq_D_instructionVar599 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sueq_D_instructionVar599 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sueq.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1096:1, end:1096:2))"]
#[derive(Clone, Debug)]
struct cmp_sne_S_instructionVar600 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sne_S_instructionVar600 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sne.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1100:1, end:1100:2))"]
#[derive(Clone, Debug)]
struct cmp_sne_D_instructionVar601 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sne_D_instructionVar601 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sne.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1105:1, end:1105:2))"]
#[derive(Clone, Debug)]
struct cmp_slt_S_instructionVar602 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_slt_S_instructionVar602 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.slt.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1109:1, end:1109:2))"]
#[derive(Clone, Debug)]
struct cmp_slt_D_instructionVar603 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_slt_D_instructionVar603 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.slt.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1114:1, end:1114:2))"]
#[derive(Clone, Debug)]
struct cmp_sult_S_instructionVar604 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sult_S_instructionVar604 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sult.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1118:1, end:1118:2))"]
#[derive(Clone, Debug)]
struct cmp_sult_D_instructionVar605 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sult_D_instructionVar605 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sult.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1123:1, end:1123:2))"]
#[derive(Clone, Debug)]
struct cmp_sle_S_instructionVar606 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sle_S_instructionVar606 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sle.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1127:1, end:1127:2))"]
#[derive(Clone, Debug)]
struct cmp_sle_D_instructionVar607 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sle_D_instructionVar607 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sle.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1132:1, end:1132:2))"]
#[derive(Clone, Debug)]
struct cmp_sule_S_instructionVar608 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sule_S_instructionVar608 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sule.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:1136:1, end:1136:2))"]
#[derive(Clone, Debug)]
struct cmp_sule_D_instructionVar609 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt6: Tablefmt6,
}
impl cmp_sule_D_instructionVar609 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sule.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt6 = if let Some((len, table)) =
            Tablefmt6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ftD = token_20(tokens_current);
        let ft = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt6, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:526:1, end:526:2))"]
#[derive(Clone, Debug)]
struct rotr_instructionVar610 {
    sa: u8,
    RD32: TableRD32,
    RD: TableRD,
    RT32src: TableRT32src,
}
impl rotr_instructionVar610 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rotr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD32 = if let Some((len, table)) =
            TableRD32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD32,
                RD,
                RT32src,
                sa,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:550:1, end:550:2))"]
#[derive(Clone, Debug)]
struct sbe_instructionVar611 {
    OFF_BASER6: TableOFF_BASER6,
    RTsrc: TableRTsrc,
}
impl sbe_instructionVar611 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbe"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:554:1, end:554:2))"]
#[derive(Clone, Debug)]
struct sce_instructionVar612 {
    OFF_BASER6: TableOFF_BASER6,
    RTsrc: TableRTsrc,
}
impl sce_instructionVar612 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sce"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:584:1, end:584:2))"]
#[derive(Clone, Debug)]
struct she_instructionVar613 {
    RTsrc: TableRTsrc,
    OFF_BASER6: TableOFF_BASER6,
}
impl she_instructionVar613 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("she"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, OFF_BASER6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:589:1, end:589:2))"]
#[derive(Clone, Debug)]
struct sll_instructionVar614 {
    sa: u8,
    RT32src: TableRT32src,
    RD: TableRD,
    RD32: TableRD32,
}
impl sll_instructionVar614 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sll"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD32 = if let Some((len, table)) =
            TableRD32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32src,
                RD,
                RD32,
                sa,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:621:1, end:621:2))"]
#[derive(Clone, Debug)]
struct sra_instructionVar615 {
    sa: u8,
    RD32: TableRD32,
    RT32src: TableRT32src,
    RD: TableRD,
}
impl sra_instructionVar615 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sra"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD32 = if let Some((len, table)) =
            TableRD32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD32,
                RT32src,
                RD,
                sa,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:636:1, end:636:2))"]
#[derive(Clone, Debug)]
struct srl_instructionVar616 {
    sa: u8,
    RD32: TableRD32,
    RD: TableRD,
    RT32src: TableRT32src,
}
impl srl_instructionVar616 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD32 = if let Some((len, table)) =
            TableRD32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sa = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD32,
                RD,
                RT32src,
                sa,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:683:1, end:683:2))"]
#[derive(Clone, Debug)]
struct swe_instructionVar617 {
    OFF_BASER6: TableOFF_BASER6,
    RTsrc: TableRTsrc,
}
impl swe_instructionVar617 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swe"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:19:1, end:19:2))"]
#[derive(Clone, Debug)]
struct abs_S_instructionVar618 {
    fd: u8,
    fs: u8,
    fmt1: Tablefmt1,
}
impl abs_S_instructionVar618 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("abs.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:22:1, end:22:2))"]
#[derive(Clone, Debug)]
struct abs_D_instructionVar619 {
    fd: u8,
    fs: u8,
    fmt1: Tablefmt1,
}
impl abs_D_instructionVar619 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("abs.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:30:1, end:30:2))"]
#[derive(Clone, Debug)]
struct add_S_instructionVar620 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl add_S_instructionVar620 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:33:1, end:33:2))"]
#[derive(Clone, Debug)]
struct add_D_instructionVar621 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl add_D_instructionVar621 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:191:1, end:191:2))"]
#[derive(Clone, Debug)]
struct div_S_instructionVar622 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt2: Tablefmt2,
}
impl div_S_instructionVar622 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("div.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:194:1, end:194:2))"]
#[derive(Clone, Debug)]
struct div_D_instructionVar623 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt2: Tablefmt2,
}
impl div_D_instructionVar623 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("div.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt2 = if let Some((len, table)) =
            Tablefmt2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt2, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:248:1, end:248:2))"]
#[derive(Clone, Debug)]
struct mov_S_instructionVar624 {
    fd: u8,
    fs: u8,
    fmt1: Tablefmt1,
}
impl mov_S_instructionVar624 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:251:1, end:251:2))"]
#[derive(Clone, Debug)]
struct mov_D_instructionVar625 {
    fd: u8,
    fs: u8,
    fmt1: Tablefmt1,
}
impl mov_D_instructionVar625 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:271:1, end:271:2))"]
#[derive(Clone, Debug)]
struct mul_S_instructionVar626 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl mul_S_instructionVar626 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:274:1, end:274:2))"]
#[derive(Clone, Debug)]
struct mul_D_instructionVar627 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl mul_D_instructionVar627 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:282:1, end:282:2))"]
#[derive(Clone, Debug)]
struct neg_S_instructionVar628 {
    fd: u8,
    fs: u8,
    fmt1: Tablefmt1,
}
impl neg_S_instructionVar628 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("neg.S"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:285:1, end:285:2))"]
#[derive(Clone, Debug)]
struct neg_D_instructionVar629 {
    fd: u8,
    fs: u8,
    fmt1: Tablefmt1,
}
impl neg_D_instructionVar629 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("neg.D"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:338:1, end:338:2))"]
#[derive(Clone, Debug)]
struct sub_S_instructionVar630 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl sub_S_instructionVar630 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub.S"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.fmt1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:341:1, end:341:2))"]
#[derive(Clone, Debug)]
struct sub_D_instructionVar631 {
    fd: u8,
    fs: u8,
    ft: u8,
    fmt1: Tablefmt1,
}
impl sub_D_instructionVar631 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub.D"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.fmt1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt1 = if let Some((len, table)) =
            Tablefmt1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmt1, fd, fs, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:776:1, end:776:2))"]
#[derive(Clone, Debug)]
struct wait_instructionVar632 {}
impl wait_instructionVar632 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wait"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let copfill = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1405:1, end:1405:2))"]
#[derive(Clone, Debug)]
struct align_instructionVar633 {
    bp2: u8,
    RD: TableRD,
    RT32src: TableRT32src,
    RS32src: TableRS32src,
}
impl align_instructionVar633 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("align"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.bp2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let bp2 = token_39(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD,
                RT32src,
                RS32src,
                bp2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1656:1, end:1656:2))"]
#[derive(Clone, Debug)]
struct lsa_instructionVar634 {
    RD: TableRD,
    RS32src: TableRS32src,
    RT32src: TableRT32src,
    SAV: TableSAV,
}
impl lsa_instructionVar634 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsa"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SAV
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SAV = if let Some((len, table)) =
            TableSAV::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT32src = if let Some((len, table)) =
            TableRT32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD,
                RS32src,
                RT32src,
                SAV,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:382:1, end:382:2))"]
#[derive(Clone, Debug)]
struct ldxc1_instructionVar635 {
    fd: u8,
    INDEX_BASE: TableINDEX_BASE,
}
impl ldxc1_instructionVar635 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldxc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.INDEX_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let INDEX_BASE = if let Some((len, table)) =
            TableINDEX_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { INDEX_BASE, fd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:387:1, end:387:2))"]
#[derive(Clone, Debug)]
struct luxc1_instructionVar636 {
    fd: u8,
    INDEX_BASE: TableINDEX_BASE,
}
impl luxc1_instructionVar636 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("luxc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.INDEX_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let INDEX_BASE = if let Some((len, table)) =
            TableINDEX_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { INDEX_BASE, fd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:393:1, end:393:2))"]
#[derive(Clone, Debug)]
struct lwxc1_instructionVar637 {
    fd: u8,
    INDEX_BASE: TableINDEX_BASE,
}
impl lwxc1_instructionVar637 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwxc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.INDEX_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let INDEX_BASE = if let Some((len, table)) =
            TableINDEX_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { INDEX_BASE, fd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:377:1, end:377:2))"]
#[derive(Clone, Debug)]
struct alnv_PS_instructionVar638 {
    fd: u8,
    fs: u8,
    ft: u8,
    rs: u8,
}
impl alnv_PS_instructionVar638 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("alnv.PS"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = token_6(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fdD = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fd, fs, ft, rs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:398:1, end:398:2))"]
#[derive(Clone, Debug)]
struct madd_S_instructionVar639 {
    fd: u8,
    fr: u8,
    fs: u8,
    ft: u8,
    fmt5: Tablefmt5,
}
impl madd_S_instructionVar639 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("madd.S"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt5 = if let Some((len, table)) =
            Tablefmt5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fr = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt5,
                fd,
                fr,
                fs,
                ft,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:401:1, end:401:2))"]
#[derive(Clone, Debug)]
struct madd_D_instructionVar640 {
    fd: u8,
    fr: u8,
    fs: u8,
    ft: u8,
    fmt5: Tablefmt5,
}
impl madd_D_instructionVar640 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("madd.D"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt5 = if let Some((len, table)) =
            Tablefmt5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let frD = token_6(tokens_current);
        let fr = token_6(tokens_current);
        let fs = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt5,
                fd,
                fr,
                fs,
                ft,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:405:1, end:405:2))"]
#[derive(Clone, Debug)]
struct madd_PS_instructionVar641 {
    fd: u8,
    fr: u8,
    fs: u8,
    ft: u8,
    fmt5: Tablefmt5,
}
impl madd_PS_instructionVar641 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("madd.PS"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt5 = if let Some((len, table)) =
            Tablefmt5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let fr = token_6(tokens_current);
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt5,
                fd,
                fr,
                fs,
                ft,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:410:1, end:410:2))"]
#[derive(Clone, Debug)]
struct msub_S_instructionVar642 {
    fd: u8,
    fr: u8,
    fs: u8,
    ft: u8,
    fmt5: Tablefmt5,
}
impl msub_S_instructionVar642 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msub.S"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt5 = if let Some((len, table)) =
            Tablefmt5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fr = token_6(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt5,
                fd,
                fr,
                fs,
                ft,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:413:1, end:413:2))"]
#[derive(Clone, Debug)]
struct msub_D_instructionVar643 {
    fd: u8,
    fr: u8,
    fs: u8,
    ft: u8,
    fmt5: Tablefmt5,
}
impl msub_D_instructionVar643 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msub.D"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt5 = if let Some((len, table)) =
            Tablefmt5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdD = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let fr = token_6(tokens_current);
        let frD = token_6(tokens_current);
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt5,
                fd,
                fr,
                fs,
                ft,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:417:1, end:417:2))"]
#[derive(Clone, Debug)]
struct msub_PS_instructionVar644 {
    fd: u8,
    fr: u8,
    fs: u8,
    ft: u8,
    fmt5: Tablefmt5,
}
impl msub_PS_instructionVar644 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msub.PS"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt5 = if let Some((len, table)) =
            Tablefmt5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fr = token_6(tokens_current);
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt5,
                fd,
                fr,
                fs,
                ft,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:422:1, end:422:2))"]
#[derive(Clone, Debug)]
struct nmadd_S_instructionVar645 {
    fd: u8,
    fr: u8,
    fs: u8,
    ft: u8,
    fmt5: Tablefmt5,
}
impl nmadd_S_instructionVar645 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmadd.S"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt5 = if let Some((len, table)) =
            Tablefmt5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let fr = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt5,
                fd,
                fr,
                fs,
                ft,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:425:1, end:425:2))"]
#[derive(Clone, Debug)]
struct nmadd_D_instructionVar646 {
    fd: u8,
    fr: u8,
    fs: u8,
    ft: u8,
    fmt5: Tablefmt5,
}
impl nmadd_D_instructionVar646 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmadd.D"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt5 = if let Some((len, table)) =
            Tablefmt5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fdD = token_37(tokens_current);
        let fsD = token_28(tokens_current);
        let frD = token_6(tokens_current);
        let ftD = token_20(tokens_current);
        let fr = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt5,
                fd,
                fr,
                fs,
                ft,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:429:1, end:429:2))"]
#[derive(Clone, Debug)]
struct nmadd_PS_instructionVar647 {
    fd: u8,
    fr: u8,
    fs: u8,
    ft: u8,
    fmt5: Tablefmt5,
}
impl nmadd_PS_instructionVar647 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmadd.PS"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt5 = if let Some((len, table)) =
            Tablefmt5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fd = token_37(tokens_current);
        let fr = token_6(tokens_current);
        let ft = token_20(tokens_current);
        let fdD = token_37(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt5,
                fd,
                fr,
                fs,
                ft,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:434:1, end:434:2))"]
#[derive(Clone, Debug)]
struct nmsub_S_instructionVar648 {
    fd: u8,
    fr: u8,
    fs: u8,
    ft: u8,
    fmt5: Tablefmt5,
}
impl nmsub_S_instructionVar648 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmsub.S"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt5 = if let Some((len, table)) =
            Tablefmt5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fr = token_6(tokens_current);
        let ft = token_20(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt5,
                fd,
                fr,
                fs,
                ft,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:437:1, end:437:2))"]
#[derive(Clone, Debug)]
struct nmsub_D_instructionVar649 {
    fd: u8,
    fr: u8,
    fs: u8,
    ft: u8,
    fmt5: Tablefmt5,
}
impl nmsub_D_instructionVar649 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmsub.D"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt5 = if let Some((len, table)) =
            Tablefmt5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let ftD = token_20(tokens_current);
        let fdD = token_37(tokens_current);
        let fr = token_6(tokens_current);
        let fd = token_37(tokens_current);
        let fs = token_28(tokens_current);
        let ft = token_20(tokens_current);
        let frD = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt5,
                fd,
                fr,
                fs,
                ft,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:441:1, end:441:2))"]
#[derive(Clone, Debug)]
struct nmsub_PS_instructionVar650 {
    fd: u8,
    fr: u8,
    fs: u8,
    ft: u8,
    fmt5: Tablefmt5,
}
impl nmsub_PS_instructionVar650 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmsub.PS"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmt5 = if let Some((len, table)) =
            Tablefmt5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fs = token_28(tokens_current);
        let fd = token_37(tokens_current);
        let ft = token_20(tokens_current);
        let fr = token_6(tokens_current);
        let ftD = token_20(tokens_current);
        let fsD = token_28(tokens_current);
        let fdD = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmt5,
                fd,
                fr,
                fs,
                ft,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:454:1, end:454:2))"]
#[derive(Clone, Debug)]
struct suxc1_instructionVar651 {
    fs: u8,
    INDEX_BASE: TableINDEX_BASE,
}
impl suxc1_instructionVar651 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("suxc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.INDEX_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let INDEX_BASE = if let Some((len, table)) =
            TableINDEX_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsD = token_28(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { INDEX_BASE, fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:96:1, end:96:2))"]
#[derive(Clone, Debug)]
struct break_instructionVar652 {
    breakcode: u32,
}
impl break_instructionVar652 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("break"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.breakcode as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let breakcode = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { breakcode }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:866:1, end:866:2))"]
#[derive(Clone, Debug)]
struct bc2f_instructionVar653 {
    cc: u8,
    Rel16: TableRel16,
}
impl bc2f_instructionVar653 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2f"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cc = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:879:1, end:879:2))"]
#[derive(Clone, Debug)]
struct bc2fl_instructionVar654 {
    cc: u8,
    Rel16: TableRel16,
}
impl bc2fl_instructionVar654 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2fl"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cc = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:892:1, end:892:2))"]
#[derive(Clone, Debug)]
struct bc2t_instructionVar655 {
    cc: u8,
    Rel16: TableRel16,
}
impl bc2t_instructionVar655 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2t"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cc = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:905:1, end:905:2))"]
#[derive(Clone, Debug)]
struct bc2tl_instructionVar656 {
    cc: u8,
    Rel16: TableRel16,
}
impl bc2tl_instructionVar656 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2tl"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cc = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:474:1, end:474:2))"]
#[derive(Clone, Debug)]
struct bc1f_instructionVar657 {
    cc: u8,
    Rel16: TableRel16,
}
impl bc1f_instructionVar657 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1f"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cc = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:488:1, end:488:2))"]
#[derive(Clone, Debug)]
struct bc1fl_instructionVar658 {
    cc: u8,
    Rel16: TableRel16,
}
impl bc1fl_instructionVar658 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1fl"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cc = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:503:1, end:503:2))"]
#[derive(Clone, Debug)]
struct bc1t_instructionVar659 {
    cc: u8,
    Rel16: TableRel16,
}
impl bc1t_instructionVar659 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1t"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cc = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:517:1, end:517:2))"]
#[derive(Clone, Debug)]
struct bc1tl_instructionVar660 {
    cc: u8,
    Rel16: TableRel16,
}
impl bc1tl_instructionVar660 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1tl"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cc as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cc = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1025:1, end:1025:2))"]
#[derive(Clone, Debug)]
struct lui_instructionVar661 {
    immed: u16,
    RT: TableRT,
}
impl lui_instructionVar661 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lui"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1114:1, end:1114:2))"]
#[derive(Clone, Debug)]
struct lwl_instructionVar662 {
    OFF_BASE: TableOFF_BASE,
    RT: TableRT,
}
impl lwl_instructionVar662 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_PAIR_INSTRUCTION_FLAG(
                u8::try_from(i128::try_from(context.read_PAIR_INSTRUCTION_FLAG()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("lwl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_PAIR_INSTRUCTION_FLAG(u8::try_from(1i128 & 1).unwrap());
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1116:1, end:1116:2))"]
#[derive(Clone, Debug)]
struct lwr_instructionVar663 {
    OFF_BASE: TableOFF_BASE,
    RT: TableRT,
}
impl lwr_instructionVar663 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_PAIR_INSTRUCTION_FLAG(u8::try_from(0i128 & 1).unwrap());
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1338:1, end:1338:2))"]
#[derive(Clone, Debug)]
struct swl_instructionVar664 {
    OFF_BASE: TableOFF_BASE,
    RTsrc: TableRTsrc,
}
impl swl_instructionVar664 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_PAIR_INSTRUCTION_FLAG(
                u8::try_from(i128::try_from(context.read_PAIR_INSTRUCTION_FLAG()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("swl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_PAIR_INSTRUCTION_FLAG(u8::try_from(1i128 & 1).unwrap());
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1340:1, end:1340:2))"]
#[derive(Clone, Debug)]
struct swr_instructionVar665 {
    RTsrc: TableRTsrc,
    OFF_BASE: TableOFF_BASE,
}
impl swr_instructionVar665 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_PAIR_INSTRUCTION_FLAG(u8::try_from(0i128 & 1).unwrap());
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, OFF_BASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1401:1, end:1401:2))"]
#[derive(Clone, Debug)]
struct addiupc_instructionVar666 {
    RSsrc: TableRSsrc,
    S19L2: TableS19L2,
}
impl addiupc_instructionVar666 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiupc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.S19L2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S19L2 = if let Some((len, table)) =
            TableS19L2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, S19L2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1446:1, end:1446:2))"]
#[derive(Clone, Debug)]
struct bc2eqz_instructionVar667 {
    op: u8,
    Rel16: TableRel16,
}
impl bc2eqz_instructionVar667 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2eqz"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.op as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let op = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, op }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1452:1, end:1452:2))"]
#[derive(Clone, Debug)]
struct bc2nez_instructionVar668 {
    op: u8,
    Rel16: TableRel16,
}
impl bc2nez_instructionVar668 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2nez"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.op as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let op = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, op }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1459:1, end:1459:2))"]
#[derive(Clone, Debug)]
struct blezalc_instructionVar669 {
    RTsrc: TableRTsrc,
    Rel16: TableRel16,
}
impl blezalc_instructionVar669 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blezalc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, Rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1476:1, end:1476:2))"]
#[derive(Clone, Debug)]
struct bgtzalc_instructionVar670 {
    Rel16: TableRel16,
    RTsrc: TableRTsrc,
}
impl bgtzalc_instructionVar670 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgtzalc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1499:1, end:1499:2))"]
#[derive(Clone, Debug)]
struct beqc_instructionVar671 {
    RSsrc: TableRSsrc,
    Rel16: TableRel16,
    RTsrc: TableRTsrc,
}
impl beqc_instructionVar671 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beqc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_6(tokens_current) == 0 {
            return None;
        }
        if i128::try_from(token_6(tokens_current)).unwrap()
            >= i128::try_from(token_20(tokens_current)).unwrap()
        {
            return None;
        }
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RSsrc,
                Rel16,
                RTsrc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1520:1, end:1520:2))"]
#[derive(Clone, Debug)]
struct bnec_instructionVar672 {
    RTsrc: TableRTsrc,
    Rel16: TableRel16,
    RSsrc: TableRSsrc,
}
impl bnec_instructionVar672 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnec"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_6(tokens_current) == 0 {
            return None;
        }
        if i128::try_from(token_6(tokens_current)).unwrap()
            >= i128::try_from(token_20(tokens_current)).unwrap()
        {
            return None;
        }
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                Rel16,
                RSsrc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1613:1, end:1613:2))"]
#[derive(Clone, Debug)]
struct jialc_instructionVar673 {
    simmed: u16,
    RTsrc: TableRTsrc,
}
impl jialc_instructionVar673 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jialc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1621:1, end:1621:2))"]
#[derive(Clone, Debug)]
struct jic_instructionVar674 {
    simmed: u16,
    RTsrc: TableRTsrc,
}
impl jic_instructionVar674 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jic"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1635:1, end:1635:2))"]
#[derive(Clone, Debug)]
struct ldc2_instructionVar675 {
    simmed11: u16,
    baser6: u8,
    RTsrc: TableRTsrc,
}
impl ldc2_instructionVar675 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldc2"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.simmed11 as u64),
            <DisplayElement>::Literal("("),
            meaning_0_display(self.baser6),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let baser6 = token_28(tokens_current);
        let simmed11 = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                simmed11,
                baser6,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1662:1, end:1662:2))"]
#[derive(Clone, Debug)]
struct lwc2_instructionVar676 {
    simmed11: u16,
    baser6: u8,
    RTsrc: TableRTsrc,
}
impl lwc2_instructionVar676 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwc2"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.simmed11 as u64),
            <DisplayElement>::Literal("("),
            meaning_0_display(self.baser6),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed11 = token_41(tokens_current);
        let baser6 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                simmed11,
                baser6,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1671:1, end:1671:2))"]
#[derive(Clone, Debug)]
struct lwpc_instructionVar677 {
    S19L2: TableS19L2,
    RS: TableRS,
}
impl lwpc_instructionVar677 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwpc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.S19L2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS = if let Some((len, table)) =
            TableRS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S19L2 = if let Some((len, table)) =
            TableS19L2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S19L2, RS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:815:1, end:815:2))"]
#[derive(Clone, Debug)]
struct bc1eqz_instructionVar678 {
    ft: u8,
    Rel16: TableRel16,
}
impl bc1eqz_instructionVar678 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1eqz"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:822:1, end:822:2))"]
#[derive(Clone, Debug)]
struct bc1nez_instructionVar679 {
    ft: u8,
    Rel16: TableRel16,
}
impl bc1nez_instructionVar679 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1nez"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2486:1, end:2486:2))"]
#[derive(Clone, Debug)]
struct lwle_instructionVar680 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl lwle_instructionVar680 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwle"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2510:1, end:2510:2))"]
#[derive(Clone, Debug)]
struct lwre_instructionVar681 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl lwre_instructionVar681 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwre"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2877:1, end:2877:2))"]
#[derive(Clone, Debug)]
struct swle_instructionVar682 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl swle_instructionVar682 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swle"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2903:1, end:2903:2))"]
#[derive(Clone, Debug)]
struct swre_instructionVar683 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl swre_instructionVar683 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swre"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3213:1, end:3213:2))"]
#[derive(Clone, Debug)]
struct cache_instructionVar684 {
    mic_cop5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl cache_instructionVar684 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cache"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_cop5 as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base0 = token_53(tokens_current);
        let mic_cop5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_cop5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3558:1, end:3558:2))"]
#[derive(Clone, Debug)]
struct llx_instructionVar685 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl llx_instructionVar685 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("llx"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3567:1, end:3567:2))"]
#[derive(Clone, Debug)]
struct llxe_instructionVar686 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl llxe_instructionVar686 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("llxe"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3728:1, end:3728:2))"]
#[derive(Clone, Debug)]
struct scx_instructionVar687 {
    mic_base0: u8,
    RT5L: TableRT5L,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl scx_instructionVar687 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("scx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                EXT_CODE9E,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3738:1, end:3738:2))"]
#[derive(Clone, Debug)]
struct scxe_instructionVar688 {
    mic_base0: u8,
    RT5L: TableRT5L,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl scxe_instructionVar688 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("scxe"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                EXT_CODE9E,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:102:1, end:102:2))"]
#[derive(Clone, Debug)]
struct cache_instructionVar689 {
    op: u8,
    OFF_BASER6: TableOFF_BASER6,
}
impl cache_instructionVar689 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cache"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.op as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASER6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_1(tokens) != 47 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c48(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_1(tokens) != 31 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    if token_42(tokens) != 37 {
                        return None;
                    }
                    if token_43(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c48(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let OFF_BASER6 = if let Some((len, table)) =
            TableOFF_BASER6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let op = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASER6, op }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:422:1, end:422:2))"]
#[derive(Clone, Debug)]
struct mfc0_instructionVar690 {
    RT: TableRT,
    RD0: TableRD0,
}
impl mfc0_instructionVar690 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfc0"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RD0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD0 = if let Some((len, table)) =
            TableRD0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, RD0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:455:1, end:455:2))"]
#[derive(Clone, Debug)]
struct mtc0_instructionVar691 {
    sel: u8,
    RD0: TableRD0,
    RTsrc: TableRTsrc,
}
impl mtc0_instructionVar691 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtc0"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RD0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sel as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD0 = if let Some((len, table)) =
            TableRD0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sel = token_49(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD0, RTsrc, sel }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:463:1, end:463:2))"]
#[derive(Clone, Debug)]
struct mthc0_instructionVar692 {
    sel: u8,
    RD0: TableRD0,
    RTsrc: TableRTsrc,
}
impl mthc0_instructionVar692 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mthc0"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RD0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sel as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RD0 = if let Some((len, table)) =
            TableRD0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sel = token_49(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD0, RTsrc, sel }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:115:1, end:115:2))"]
#[derive(Clone, Debug)]
struct cfc2_instructionVar693 {
    immed: u16,
    RT: TableRT,
}
impl cfc2_instructionVar693 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cfc2"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:154:1, end:154:2))"]
#[derive(Clone, Debug)]
struct ctc2_instructionVar694 {
    immed: u16,
    RTsrc: TableRTsrc,
}
impl ctc2_instructionVar694 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ctc2"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:427:1, end:427:2))"]
#[derive(Clone, Debug)]
struct mfc2_instructionVar695 {
    immed: u16,
    RT: TableRT,
}
impl mfc2_instructionVar695 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfc2"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:433:1, end:433:2))"]
#[derive(Clone, Debug)]
struct mfhc2_instructionVar696 {
    immed: u16,
    RT: TableRT,
}
impl mfhc2_instructionVar696 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfhc2"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_14(tokens_current);
        let fs = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:440:1, end:440:2))"]
#[derive(Clone, Debug)]
struct li_instructionVar697 {
    simmed: u16,
    RT: TableRT,
}
impl li_instructionVar697 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("li"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:459:1, end:459:2))"]
#[derive(Clone, Debug)]
struct mtc2_instructionVar698 {
    immed: u16,
    RTsrc: TableRTsrc,
}
impl mtc2_instructionVar698 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtc2"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:468:1, end:468:2))"]
#[derive(Clone, Debug)]
struct mthc2_instructionVar699 {
    immed: u16,
    RTsrc: TableRTsrc,
}
impl mthc2_instructionVar699 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mthc2"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:663:1, end:663:2))"]
#[derive(Clone, Debug)]
struct cachee_instructionVar700 {
    mic_cop5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl cachee_instructionVar700 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cachee"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_cop5 as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_cop5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_cop5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:881:1, end:881:2))"]
#[derive(Clone, Debug)]
struct lbe_instructionVar701 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl lbe_instructionVar701 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbe"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:897:1, end:897:2))"]
#[derive(Clone, Debug)]
struct lbue_instructionVar702 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl lbue_instructionVar702 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbue"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:937:1, end:937:2))"]
#[derive(Clone, Debug)]
struct lhe_instructionVar703 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl lhe_instructionVar703 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhe"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:953:1, end:953:2))"]
#[derive(Clone, Debug)]
struct lhue_instructionVar704 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl lhue_instructionVar704 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhue"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:973:1, end:973:2))"]
#[derive(Clone, Debug)]
struct ll_instructionVar705 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl ll_instructionVar705 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ll"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:982:1, end:982:2))"]
#[derive(Clone, Debug)]
struct lle_instructionVar706 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl lle_instructionVar706 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lle"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1005:1, end:1005:2))"]
#[derive(Clone, Debug)]
struct lwe_instructionVar707 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl lwe_instructionVar707 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwe"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1199:1, end:1199:2))"]
#[derive(Clone, Debug)]
struct pref_instructionVar708 {
    mic_cop5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl pref_instructionVar708 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pref"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_cop5 as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base0 = token_53(tokens_current);
        let mic_cop5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_cop5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1205:1, end:1205:2))"]
#[derive(Clone, Debug)]
struct prefe_instructionVar709 {
    mic_cop5: u8,
    mic_base0: u8,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl prefe_instructionVar709 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("prefe"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_cop5 as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base0 = token_53(tokens_current);
        let mic_cop5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE9E,
                mic_cop5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1277:1, end:1277:2))"]
#[derive(Clone, Debug)]
struct sbe_instructionVar710 {
    mic_base0: u8,
    RT5L: TableRT5L,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl sbe_instructionVar710 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbe"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                EXT_CODE9E,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1293:1, end:1293:2))"]
#[derive(Clone, Debug)]
struct sc_instructionVar711 {
    mic_base0: u8,
    RT5L: TableRT5L,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl sc_instructionVar711 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                EXT_CODE9E,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1303:1, end:1303:2))"]
#[derive(Clone, Debug)]
struct sce_instructionVar712 {
    mic_base0: u8,
    RT5L: TableRT5L,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl sce_instructionVar712 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sce"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                EXT_CODE9E,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1352:1, end:1352:2))"]
#[derive(Clone, Debug)]
struct she_instructionVar713 {
    mic_base0: u8,
    RT5L: TableRT5L,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl she_instructionVar713 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("she"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                EXT_CODE9E,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1471:1, end:1471:2))"]
#[derive(Clone, Debug)]
struct swe_instructionVar714 {
    mic_base0: u8,
    RT5L: TableRT5L,
    EXT_CODE9E: TableEXT_CODE9E,
}
impl swe_instructionVar714 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swe"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE9E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE9E = if let Some((len, table)) =
            TableEXT_CODE9E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                EXT_CODE9E,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:145:1, end:145:2))"]
#[derive(Clone, Debug)]
struct cop2_instructionVar715 {
    cofun: u32,
}
impl cop2_instructionVar715 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cop2"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.cofun as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let cofun = token_12(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cofun }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:204:1, end:204:2))"]
#[derive(Clone, Debug)]
struct ext_instructionVar716 {
    lsb: u8,
    RT: TableRT,
    ExtSize: TableExtSize,
    RSsrc: TableRSsrc,
}
impl ext_instructionVar716 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ext"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.lsb as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.ExtSize
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ExtSize = if let Some((len, table)) =
            TableExtSize::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lsb = token_37(tokens_current);
        let msbd = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                ExtSize,
                RSsrc,
                lsb,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:214:1, end:214:2))"]
#[derive(Clone, Debug)]
struct ins_instructionVar717 {
    lsb: u8,
    RSsrc: TableRSsrc,
    RT: TableRT,
    InsSize: TableInsSize,
    RTsrc: TableRTsrc,
}
impl ins_instructionVar717 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ins"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.lsb as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.InsSize
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let InsSize = if let Some((len, table)) =
            TableInsSize::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lsb = token_37(tokens_current);
        let msbd = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RSsrc,
                RT,
                InsSize,
                RTsrc,
                lsb,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:560:1, end:560:2))"]
#[derive(Clone, Debug)]
struct sdbbp_instructionVar718 {
    breakcode: u32,
}
impl sdbbp_instructionVar718 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdbbp"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.breakcode as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let breakcode = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { breakcode }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:695:1, end:695:2))"]
#[derive(Clone, Debug)]
struct synci_instructionVar719 {
    OFF_BASE: TableOFF_BASE,
}
impl synci_instructionVar719 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("synci"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:699:1, end:699:2))"]
#[derive(Clone, Debug)]
struct syscall_instructionVar720 {}
impl syscall_instructionVar720 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("syscall"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let breakcode = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:705:1, end:705:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar721 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl teq_instructionVar721 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let code = token_36(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:712:1, end:712:2))"]
#[derive(Clone, Debug)]
struct tge_instructionVar722 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl tge_instructionVar722 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tge"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let code = token_36(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:719:1, end:719:2))"]
#[derive(Clone, Debug)]
struct tgeu_instructionVar723 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl tgeu_instructionVar723 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tgeu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let code = token_36(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:754:1, end:754:2))"]
#[derive(Clone, Debug)]
struct tlt_instructionVar724 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
}
impl tlt_instructionVar724 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlt"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let code = token_36(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:761:1, end:761:2))"]
#[derive(Clone, Debug)]
struct tltu_instructionVar725 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl tltu_instructionVar725 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tltu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let code = token_36(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:768:1, end:768:2))"]
#[derive(Clone, Debug)]
struct tne_instructionVar726 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl tne_instructionVar726 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tne"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let code = token_36(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:838:1, end:838:2))"]
#[derive(Clone, Debug)]
struct addi_instructionVar727 {
    simmed: u16,
    RT32: TableRT32,
    RS32src: TableRS32src,
    RT: TableRT,
}
impl addi_instructionVar727 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT32 = if let Some((len, table)) =
            TableRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32,
                RS32src,
                RT,
                simmed,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:913:1, end:913:2))"]
#[derive(Clone, Debug)]
struct beql_instructionVar728 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    Rel16: TableRel16,
}
impl beql_instructionVar728 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beql"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                RSsrc,
                Rel16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:974:1, end:974:2))"]
#[derive(Clone, Debug)]
struct bnel_instructionVar729 {
    Rel16: TableRel16,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl bnel_instructionVar729 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnel"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16,
                RSsrc,
                RTsrc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1004:1, end:1004:2))"]
#[derive(Clone, Debug)]
struct jalx_instructionVar730 {
    Abs26: TableAbs26,
}
impl jalx_instructionVar730 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(None, |context| {
            context.write_ISA_MODE(
                u8::try_from(i128::try_from(context.read_ISA_MODE()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("jalx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Abs26
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_ISA_MODE(u8::try_from(1i128 & 1).unwrap());
        let Abs26 = if let Some((len, table)) =
            TableAbs26::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Abs26 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1014:1, end:1014:2))"]
#[derive(Clone, Debug)]
struct ldc2_instructionVar731 {
    rt: u8,
    OFF_BASE: TableOFF_BASE,
}
impl ldc2_instructionVar731 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldc2"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rt),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rt = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, rt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1020:1, end:1020:2))"]
#[derive(Clone, Debug)]
struct ll_instructionVar732 {
    OFF_BASE: TableOFF_BASE,
    RT: TableRT,
}
impl ll_instructionVar732 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ll"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1032:1, end:1032:2))"]
#[derive(Clone, Debug)]
struct lwc2_instructionVar733 {
    rt: u8,
    OFF_BASE: TableOFF_BASE,
}
impl lwc2_instructionVar733 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwc2"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rt),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rt = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, rt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1071:1, end:1071:2))"]
#[derive(Clone, Debug)]
struct lwl_instructionVar734 {
    RTsrc: TableRTsrc,
    RT: TableRT,
    OFF_BASE: TableOFF_BASE,
}
impl lwl_instructionVar734 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                RT,
                OFF_BASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1080:1, end:1080:2))"]
#[derive(Clone, Debug)]
struct lwr_instructionVar735 {
    OFF_BASE: TableOFF_BASE,
    RT: TableRT,
    RTsrc: TableRTsrc,
}
impl lwr_instructionVar735 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                OFF_BASE,
                RT,
                RTsrc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1250:1, end:1250:2))"]
#[derive(Clone, Debug)]
struct sc_instructionVar736 {
    RTsrc: TableRTsrc,
    OFF_BASE: TableOFF_BASE,
    RT: TableRT,
}
impl sc_instructionVar736 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                OFF_BASE,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1293:1, end:1293:2))"]
#[derive(Clone, Debug)]
struct swl_instructionVar737 {
    OFF_BASE: TableOFF_BASE,
    RTsrc: TableRTsrc,
}
impl swl_instructionVar737 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1302:1, end:1302:2))"]
#[derive(Clone, Debug)]
struct swr_instructionVar738 {
    RTsrc: TableRTsrc,
    OFF_BASE: TableOFF_BASE,
}
impl swr_instructionVar738 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, OFF_BASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1391:1, end:1391:2))"]
#[derive(Clone, Debug)]
struct daddi_instructionVar739 {
    simmed: u16,
    RSsrc: TableRSsrc,
    RT: TableRT,
}
impl daddi_instructionVar739 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("daddi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RT, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1416:1, end:1416:2))"]
#[derive(Clone, Debug)]
struct aui_instructionVar740 {
    S16L16: TableS16L16,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl aui_instructionVar740 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("aui"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.S16L16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S16L16 = if let Some((len, table)) =
            TableS16L16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                S16L16,
                RSsrc,
                RTsrc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1437:1, end:1437:2))"]
#[derive(Clone, Debug)]
struct balc_instructionVar741 {
    Rel26: TableRel26,
}
impl balc_instructionVar741 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("balc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel26
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel26 = if let Some((len, table)) =
            TableRel26::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel26 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1442:1, end:1442:2))"]
#[derive(Clone, Debug)]
struct bc_instructionVar742 {
    Rel26: TableRel26,
}
impl bc_instructionVar742 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel26
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rel26 = if let Some((len, table)) =
            TableRel26::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel26 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1503:1, end:1503:2))"]
#[derive(Clone, Debug)]
struct bovc_instructionVar743 {
    RTsrc: TableRTsrc,
    Rel16: TableRel16,
    RSsrc: TableRSsrc,
}
impl bovc_instructionVar743 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bovc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rt32 = token_20(tokens_current);
        let rs32 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                Rel16,
                RSsrc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1524:1, end:1524:2))"]
#[derive(Clone, Debug)]
struct bnvc_instructionVar744 {
    Rel16: TableRel16,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
}
impl bnvc_instructionVar744 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnvc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rt32 = token_20(tokens_current);
        let rs32 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16,
                RSsrc,
                RTsrc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1542:1, end:1542:2))"]
#[derive(Clone, Debug)]
struct bgec_instructionVar745 {
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    Rel16: TableRel16,
}
impl bgec_instructionVar745 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgec"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RSsrc,
                RTsrc,
                Rel16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1556:1, end:1556:2))"]
#[derive(Clone, Debug)]
struct bltc_instructionVar746 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    Rel16: TableRel16,
}
impl bltc_instructionVar746 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                RSsrc,
                Rel16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1561:1, end:1561:2))"]
#[derive(Clone, Debug)]
struct beqzc_instructionVar747 {
    Rel21: TableRel21,
    RSsrc: TableRSsrc,
}
impl beqzc_instructionVar747 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beqzc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel21
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel21 = if let Some((len, table)) =
            TableRel21::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel21, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:1566:1, end:1566:2))"]
#[derive(Clone, Debug)]
struct bnezc_instructionVar748 {
    Rel21: TableRel21,
    RSsrc: TableRSsrc,
}
impl bnezc_instructionVar748 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnezc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel21
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel21 = if let Some((len, table)) =
            TableRel21::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel21, RSsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:25:1, end:25:2))"]
#[derive(Clone, Debug)]
struct addiu_instructionVar749 {
    simmed: u16,
    RT32: TableRT32,
    RT: TableRT,
    RS32src: TableRS32src,
}
impl addiu_instructionVar749 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS32src
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT32 = if let Some((len, table)) =
            TableRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS32src = if let Some((len, table)) =
            TableRS32src::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT32,
                RT,
                RS32src,
                simmed,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:46:1, end:46:2))"]
#[derive(Clone, Debug)]
struct andi_instructionVar750 {
    immed: u16,
    RSsrc: TableRSsrc,
    RT: TableRT,
}
impl andi_instructionVar750 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RT, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:57:1, end:57:2))"]
#[derive(Clone, Debug)]
struct beq_instructionVar751 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    Rel16: TableRel16,
}
impl beq_instructionVar751 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                RSsrc,
                Rel16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:89:1, end:89:2))"]
#[derive(Clone, Debug)]
struct bne_instructionVar752 {
    RTsrc: TableRTsrc,
    RSsrc: TableRSsrc,
    Rel16: TableRel16,
}
impl bne_instructionVar752 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bne"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rel16 = if let Some((len, table)) =
            TableRel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RTsrc,
                RSsrc,
                Rel16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:138:1, end:138:2))"]
#[derive(Clone, Debug)]
struct SPECIAL2_instructionVar753 {
    sa: u8,
    fct: u8,
    RSsrc: TableRSsrc,
    RTsrc: TableRTsrc,
    RD: TableRD,
}
impl SPECIAL2_instructionVar753 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SPECIAL2"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.sa as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.fct as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fct = token_42(tokens_current);
        let sa = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RSsrc,
                RTsrc,
                RD,
                sa,
                fct,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:225:1, end:225:2))"]
#[derive(Clone, Debug)]
struct j_instructionVar754 {
    Abs26: TableAbs26,
}
impl j_instructionVar754 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("j"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Abs26
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Abs26 = if let Some((len, table)) =
            TableAbs26::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Abs26 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:230:1, end:230:2))"]
#[derive(Clone, Debug)]
struct jal_instructionVar755 {
    Abs26: TableAbs26,
}
impl jal_instructionVar755 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jal"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Abs26
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Abs26 = if let Some((len, table)) =
            TableAbs26::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Abs26 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:358:1, end:358:2))"]
#[derive(Clone, Debug)]
struct lb_instructionVar756 {
    RT: TableRT,
    OFF_BASE: TableOFF_BASE,
}
impl lb_instructionVar756 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, OFF_BASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:367:1, end:367:2))"]
#[derive(Clone, Debug)]
struct lbu_instructionVar757 {
    OFF_BASE: TableOFF_BASE,
    RT: TableRT,
}
impl lbu_instructionVar757 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:376:1, end:376:2))"]
#[derive(Clone, Debug)]
struct lh_instructionVar758 {
    RT: TableRT,
    OFF_BASE: TableOFF_BASE,
}
impl lh_instructionVar758 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, OFF_BASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:385:1, end:385:2))"]
#[derive(Clone, Debug)]
struct lhu_instructionVar759 {
    RT: TableRT,
    OFF_BASE: TableOFF_BASE,
}
impl lhu_instructionVar759 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, OFF_BASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:398:1, end:398:2))"]
#[derive(Clone, Debug)]
struct lw_instructionVar760 {
    OFF_BASE: TableOFF_BASE,
    RT: TableRT,
}
impl lw_instructionVar760 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:494:1, end:494:2))"]
#[derive(Clone, Debug)]
struct ori_instructionVar761 {
    immed: u16,
    RT: TableRT,
    RSsrc: TableRSsrc,
}
impl ori_instructionVar761 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ori"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, RSsrc, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:502:1, end:502:2))"]
#[derive(Clone, Debug)]
struct pref_instructionVar762 {
    hint: u8,
    OFF_BASE: TableOFF_BASE,
}
impl pref_instructionVar762 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pref"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_36_display(self.hint),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let hint = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, hint }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:546:1, end:546:2))"]
#[derive(Clone, Debug)]
struct sb_instructionVar763 {
    OFF_BASE: TableOFF_BASE,
    RTsrc: TableRTsrc,
}
impl sb_instructionVar763 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:566:1, end:566:2))"]
#[derive(Clone, Debug)]
struct sdc2_instructionVar764 {
    OFF_BASE: TableOFF_BASE,
    RTsrc: TableRTsrc,
}
impl sdc2_instructionVar764 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdc2"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:580:1, end:580:2))"]
#[derive(Clone, Debug)]
struct sh_instructionVar765 {
    RTsrc: TableRTsrc,
    OFF_BASE: TableOFF_BASE,
}
impl sh_instructionVar765 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RTsrc, OFF_BASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:608:1, end:608:2))"]
#[derive(Clone, Debug)]
struct slti_instructionVar766 {
    simmed: u16,
    RSsrc: TableRSsrc,
    RT: TableRT,
}
impl slti_instructionVar766 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slti"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RT, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:612:1, end:612:2))"]
#[derive(Clone, Debug)]
struct sltiu_instructionVar767 {
    simmed: u16,
    RSsrc: TableRSsrc,
    RT: TableRT,
}
impl sltiu_instructionVar767 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sltiu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RT, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:671:1, end:671:2))"]
#[derive(Clone, Debug)]
struct sw_instructionVar768 {
    OFF_BASE: TableOFF_BASE,
    RTsrc: TableRTsrc,
}
impl sw_instructionVar768 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RTsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RTsrc = if let Some((len, table)) =
            TableRTsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, RTsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:677:1, end:677:2))"]
#[derive(Clone, Debug)]
struct swc2_instructionVar769 {
    hint: u8,
    OFF_BASE: TableOFF_BASE,
}
impl swc2_instructionVar769 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swc2"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_36_display(self.hint),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let hint = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, hint }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:800:1, end:800:2))"]
#[derive(Clone, Debug)]
struct xori_instructionVar770 {
    immed: u16,
    RSsrc: TableRSsrc,
    RT: TableRT,
}
impl xori_instructionVar770 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xori"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RT, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips32Instructions.sinc, start:824:1, end:824:2))"]
#[derive(Clone, Debug)]
struct daddiu_instructionVar771 {
    simmed: u16,
    RSsrc: TableRSsrc,
    RT: TableRT,
}
impl daddiu_instructionVar771 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("daddiu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RSsrc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RSsrc = if let Some((len, table)) =
            TableRSsrc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RSsrc, RT, simmed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:222:1, end:222:2))"]
#[derive(Clone, Debug)]
struct ldc1_instructionVar772 {
    ft: u8,
    OFF_BASE: TableOFF_BASE,
}
impl ldc1_instructionVar772 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:227:1, end:227:2))"]
#[derive(Clone, Debug)]
struct sdc1_instructionVar773 {
    ft: u8,
    OFF_BASE: TableOFF_BASE,
}
impl sdc1_instructionVar773 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        let ftD = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:232:1, end:232:2))"]
#[derive(Clone, Debug)]
struct lwc1_instructionVar774 {
    ft: u8,
    OFF_BASE: TableOFF_BASE,
}
impl lwc1_instructionVar774 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsfloat.sinc, start:349:1, end:349:2))"]
#[derive(Clone, Debug)]
struct swc1_instructionVar775 {
    ft: u8,
    OFF_BASE: TableOFF_BASE,
}
impl swc1_instructionVar775 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.ft),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE = if let Some((len, table)) =
            TableOFF_BASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ft = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE, ft }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:129:1, end:129:2))"]
#[derive(Clone, Debug)]
struct instructionVar776 {
    m16_ext_val: u16,
    instruction: Box<Tableinstruction>,
}
impl instructionVar776 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_value(
            u16::try_from(i128::try_from(token_67(tokens_current)).unwrap() & 2047).unwrap(),
        );
        context_instance.write_ext_is_ext(u8::try_from(1i128 & 1).unwrap());
        context_instance.write_ext_done(u8::try_from(1i128 & 1).unwrap());
        let m16_ext_val = token_67(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                m16_ext_val,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:130:1, end:130:2))"]
#[derive(Clone, Debug)]
struct instructionVar777 {
    m16_tgt_2016: u8,
    m16_tgt_2521: u8,
    m16_jal: u8,
    instruction: Box<Tableinstruction>,
}
impl instructionVar777 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_tgt_2016(
            u8::try_from(i128::try_from(token_69(tokens_current)).unwrap() & 31).unwrap(),
        );
        context_instance.write_ext_tgt_2521(
            u8::try_from(i128::try_from(token_53(tokens_current)).unwrap() & 31).unwrap(),
        );
        context_instance.write_ext_tgt_x(
            u8::try_from(i128::try_from(token_70(tokens_current)).unwrap() & 1).unwrap(),
        );
        context_instance.write_ext_isjal(u8::try_from(1i128 & 1).unwrap());
        context_instance.write_ext_done(u8::try_from(1i128 & 1).unwrap());
        let m16_jal = token_70(tokens_current);
        let m16_tgt_2521 = token_53(tokens_current);
        let m16_tgt_2016 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                m16_tgt_2016,
                m16_tgt_2521,
                m16_jal,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:426:1, end:426:2))"]
#[derive(Clone, Debug)]
struct addiu_instructionVar778 {
    EXT_IS8L3: TableEXT_IS8L3,
}
impl addiu_instructionVar778 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_IS8L3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_IS8L3 = if let Some((len, table)) =
            TableEXT_IS8L3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_IS8L3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:431:1, end:431:2))"]
#[derive(Clone, Debug)]
struct addiu_instructionVar779 {
    EXT_IS8: TableEXT_IS8,
}
impl addiu_instructionVar779 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_IS8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_IS8 = if let Some((len, table)) =
            TableEXT_IS8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_IS8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:452:1, end:452:2))"]
#[derive(Clone, Debug)]
struct addu_instructionVar780 {
    RZ: TableRZ,
    RX32: TableRX32,
    RY32: TableRY32,
    RZ32: TableRZ32,
}
impl addu_instructionVar780 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RZ32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RY32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RY32 = if let Some((len, table)) =
            TableRY32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RZ32 = if let Some((len, table)) =
            TableRZ32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RZ = if let Some((len, table)) =
            TableRZ::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RZ,
                RX32,
                RY32,
                RZ32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:730:1, end:730:2))"]
#[derive(Clone, Debug)]
struct subu_instructionVar781 {
    RZ32: TableRZ32,
    RY32: TableRY32,
    RX32: TableRX32,
    RZ: TableRZ,
}
impl subu_instructionVar781 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RZ32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RY32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RY32 = if let Some((len, table)) =
            TableRY32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RZ32 = if let Some((len, table)) =
            TableRZ32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RZ = if let Some((len, table)) =
            TableRZ::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RZ32,
                RY32,
                RX32,
                RZ,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:394:1, end:394:2))"]
#[derive(Clone, Debug)]
struct addiu_instructionVar782 {
    RX: TableRX,
    RX32: TableRX32,
    EXT_IU8: TableEXT_IU8,
}
impl addiu_instructionVar782 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_IU8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_IU8 = if let Some((len, table)) =
            TableEXT_IU8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RX32, EXT_IU8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:402:1, end:402:2))"]
#[derive(Clone, Debug)]
struct addiu_instructionVar783 {
    EXT_IS8: TableEXT_IS8,
    RX: TableRX,
    RX32: TableRX32,
}
impl addiu_instructionVar783 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_IS8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_IS8 = if let Some((len, table)) =
            TableEXT_IS8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_IS8, RX, RX32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:548:1, end:548:2))"]
#[derive(Clone, Debug)]
struct jr_instructionVar784 {}
impl jr_instructionVar784 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_ext_delay(
                u8::try_from(i128::try_from(context.read_ext_delay()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("jr"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::ra),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:560:1, end:560:2))"]
#[derive(Clone, Debug)]
struct jrc_instructionVar785 {}
impl jrc_instructionVar785 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jrc"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::ra),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:645:1, end:645:2))"]
#[derive(Clone, Debug)]
struct nop_instructionVar786 {}
impl nop_instructionVar786 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nop"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:527:1, end:527:2))"]
#[derive(Clone, Debug)]
struct jalr_instructionVar787 {
    m16_rx: u8,
}
impl jalr_instructionVar787 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_ext_delay(
                u8::try_from(i128::try_from(context.read_ext_delay()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("jalr"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:534:1, end:534:2))"]
#[derive(Clone, Debug)]
struct jalrc_instructionVar788 {
    m16_rx: u8,
}
impl jalrc_instructionVar788 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalrc"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:554:1, end:554:2))"]
#[derive(Clone, Debug)]
struct jr_instructionVar789 {
    m16_rx: u8,
}
impl jr_instructionVar789 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_ext_delay(
                u8::try_from(i128::try_from(context.read_ext_delay()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("jr"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:565:1, end:565:2))"]
#[derive(Clone, Debug)]
struct jrc_instructionVar790 {
    m16_rx: u8,
}
impl jrc_instructionVar790 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jrc"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:602:1, end:602:2))"]
#[derive(Clone, Debug)]
struct mfhi_instructionVar791 {
    m16_rx: u8,
}
impl mfhi_instructionVar791 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfhi"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:606:1, end:606:2))"]
#[derive(Clone, Debug)]
struct mflo_instructionVar792 {
    m16_rx: u8,
}
impl mflo_instructionVar792 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mflo"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:670:1, end:670:2))"]
#[derive(Clone, Debug)]
struct seb_instructionVar793 {
    m16_rx: u8,
}
impl seb_instructionVar793 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("seb"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:676:1, end:676:2))"]
#[derive(Clone, Debug)]
struct seh_instructionVar794 {
    m16_rx: u8,
}
impl seh_instructionVar794 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("seh"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:753:1, end:753:2))"]
#[derive(Clone, Debug)]
struct zeb_instructionVar795 {
    m16_rx: u8,
}
impl zeb_instructionVar795 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("zeb"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:758:1, end:758:2))"]
#[derive(Clone, Debug)]
struct zeh_instructionVar796 {
    m16_rx: u8,
}
impl zeh_instructionVar796 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("zeh"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:459:1, end:459:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar797 {
    m16_rx: u8,
    m16_ry: u8,
}
impl and_instructionVar797 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:478:1, end:478:2))"]
#[derive(Clone, Debug)]
struct break_instructionVar798 {
    m16_code: u8,
}
impl break_instructionVar798 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("break"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.m16_code as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_code = token_66(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_code }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:491:1, end:491:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar799 {
    m16_rx: u8,
    m16_ry: u8,
}
impl cmp_instructionVar799 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_ry = token_55(tokens_current);
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:506:1, end:506:2))"]
#[derive(Clone, Debug)]
struct div_instructionVar800 {
    RY32: TableRY32,
    RX32: TableRX32,
}
impl div_instructionVar800 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("div"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RY32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RY32 = if let Some((len, table)) =
            TableRY32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RY32, RX32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:513:1, end:513:2))"]
#[derive(Clone, Debug)]
struct divu_instructionVar801 {
    RX32: TableRX32,
    RY32: TableRY32,
}
impl divu_instructionVar801 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RY32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RY32 = if let Some((len, table)) =
            TableRY32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX32, RY32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:618:1, end:618:2))"]
#[derive(Clone, Debug)]
struct mult_instructionVar802 {
    RX32: TableRX32,
    RY32: TableRY32,
}
impl mult_instructionVar802 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mult"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RY32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RY32 = if let Some((len, table)) =
            TableRY32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX32, RY32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:627:1, end:627:2))"]
#[derive(Clone, Debug)]
struct multu_instructionVar803 {
    RX32: TableRX32,
    RY32: TableRY32,
}
impl multu_instructionVar803 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("multu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RY32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RY32 = if let Some((len, table)) =
            TableRY32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX32, RY32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:636:1, end:636:2))"]
#[derive(Clone, Debug)]
struct neg_instructionVar804 {
    RX: TableRX,
    RY32: TableRY32,
}
impl neg_instructionVar804 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("neg"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RY32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RY32 = if let Some((len, table)) =
            TableRY32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RY32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:640:1, end:640:2))"]
#[derive(Clone, Debug)]
struct not_instructionVar805 {
    m16_rx: u8,
    m16_ry: u8,
}
impl not_instructionVar805 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("not"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:647:1, end:647:2))"]
#[derive(Clone, Debug)]
struct or_instructionVar806 {
    m16_rx: u8,
    m16_ry: u8,
}
impl or_instructionVar806 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_ry = token_55(tokens_current);
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:666:1, end:666:2))"]
#[derive(Clone, Debug)]
struct sdbbp_instructionVar807 {
    m16_code: u8,
}
impl sdbbp_instructionVar807 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdbbp"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.m16_code as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_code = token_66(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_code }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:690:1, end:690:2))"]
#[derive(Clone, Debug)]
struct sllv_instructionVar808 {
    m16_ry: u8,
    m16_rx: u8,
}
impl sllv_instructionVar808 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sllv"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_ry = token_55(tokens_current);
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_ry, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:694:1, end:694:2))"]
#[derive(Clone, Debug)]
struct slt_instructionVar809 {
    m16_rx: u8,
    m16_ry: u8,
}
impl slt_instructionVar809 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slt"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:710:1, end:710:2))"]
#[derive(Clone, Debug)]
struct sltu_instructionVar810 {
    m16_rx: u8,
    m16_ry: u8,
}
impl sltu_instructionVar810 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sltu"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:718:1, end:718:2))"]
#[derive(Clone, Debug)]
struct srav_instructionVar811 {
    m16_ry: u8,
    m16_rx: u8,
}
impl srav_instructionVar811 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srav"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_ry = token_55(tokens_current);
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_ry, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:726:1, end:726:2))"]
#[derive(Clone, Debug)]
struct srlv_instructionVar812 {
    m16_ry: u8,
    m16_rx: u8,
}
impl srlv_instructionVar812 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srlv"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_ry, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:749:1, end:749:2))"]
#[derive(Clone, Debug)]
struct xor_instructionVar813 {
    m16_rx: u8,
    m16_ry: u8,
}
impl xor_instructionVar813 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xor"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_ry = token_55(tokens_current);
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:418:1, end:418:2))"]
#[derive(Clone, Debug)]
struct addiu_instructionVar814 {
    RY32: TableRY32,
    RX: TableRX,
    EXT_RRIA: TableEXT_RRIA,
    RX32: TableRX32,
}
impl addiu_instructionVar814 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RY32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_RRIA
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RY32 = if let Some((len, table)) =
            TableRY32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_RRIA = if let Some((len, table)) =
            TableEXT_RRIA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RY32,
                RX,
                EXT_RRIA,
                RX32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:436:1, end:436:2))"]
#[derive(Clone, Debug)]
struct addiu_instructionVar815 {
    EXT_IU8: TableEXT_IU8,
    RX: TableRX,
    RX32: TableRX32,
}
impl addiu_instructionVar815 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_IU8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_IU8 = if let Some((len, table)) =
            TableEXT_IU8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_IU8, RX, RX32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:444:1, end:444:2))"]
#[derive(Clone, Debug)]
struct addiu_instructionVar816 {
    EXT_IS8: TableEXT_IS8,
    RX: TableRX,
    RX32: TableRX32,
}
impl addiu_instructionVar816 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_IS8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_IS8 = if let Some((len, table)) =
            TableEXT_IS8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_IS8, RX, RX32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:463:1, end:463:2))"]
#[derive(Clone, Debug)]
struct asmacro_instructionVar817 {}
impl asmacro_instructionVar817 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("asmacro"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, context.read_ext_value_select() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:654:1, end:654:2))"]
#[derive(Clone, Debug)]
struct restore_instructionVar818 {
    REST_TOP: TableREST_TOP,
}
impl restore_instructionVar818 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("restore"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.REST_TOP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let REST_TOP = if let Some((len, table)) =
            TableREST_TOP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REST_TOP }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:658:1, end:658:2))"]
#[derive(Clone, Debug)]
struct save_instructionVar819 {
    SAVE_TOP: TableSAVE_TOP,
}
impl save_instructionVar819 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("save"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.SAVE_TOP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let SAVE_TOP = if let Some((len, table)) =
            TableSAVE_TOP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SAVE_TOP }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:483:1, end:483:2))"]
#[derive(Clone, Debug)]
struct bteqz_instructionVar820 {
    CRel16_m16: TableCRel16_m16,
}
impl bteqz_instructionVar820 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bteqz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CRel16_m16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let CRel16_m16 = if let Some((len, table)) =
            TableCRel16_m16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRel16_m16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:487:1, end:487:2))"]
#[derive(Clone, Debug)]
struct btnez_instructionVar821 {
    CRel16_m16: TableCRel16_m16,
}
impl btnez_instructionVar821 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("btnez"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CRel16_m16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let CRel16_m16 = if let Some((len, table)) =
            TableCRel16_m16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRel16_m16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:495:1, end:495:2))"]
#[derive(Clone, Debug)]
struct cmpi_instructionVar822 {
    m16_rx: u8,
    m16_iu8_imm: u8,
}
impl cmpi_instructionVar822 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpi"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.m16_iu8_imm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        let m16_iu8_imm = token_63(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                m16_rx,
                m16_iu8_imm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:501:1, end:501:2))"]
#[derive(Clone, Debug)]
struct cmpi_instructionVar823 {
    m16_rx: u8,
    EXT_RI: TableEXT_RI,
}
impl cmpi_instructionVar823 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpi"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_RI
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_RI = if let Some((len, table)) =
            TableEXT_RI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_RI, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:610:1, end:610:2))"]
#[derive(Clone, Debug)]
struct move_instructionVar824 {
    m16_mv_rz: u8,
    m16_i8_r32_20: u8,
    m16_i8_r32_43: u8,
}
impl move_instructionVar824 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_22_display(context.read_ext_m16r32()),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_mv_rz),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_reg_low(
            u8::try_from(i128::try_from(token_55(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_ext_reg_high(
            u8::try_from(i128::try_from(token_65(tokens_current)).unwrap() & 3).unwrap(),
        );
        let m16_mv_rz = token_64(tokens_current);
        let m16_i8_r32_20 = token_55(tokens_current);
        let m16_i8_r32_43 = token_65(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                m16_mv_rz,
                m16_i8_r32_20,
                m16_i8_r32_43,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:614:1, end:614:2))"]
#[derive(Clone, Debug)]
struct move_instructionVar825 {
    m16_ry: u8,
    m16_i8_r32: u8,
}
impl move_instructionVar825 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_22_display(self.m16_i8_r32),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_i8_r32 = token_53(tokens_current);
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_ry, m16_i8_r32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:686:1, end:686:2))"]
#[derive(Clone, Debug)]
struct sll_instructionVar826 {
    m16_rx: u8,
    m16_ry: u8,
    EXT_SHIFT: TableEXT_SHIFT,
}
impl sll_instructionVar826 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sll"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_SHIFT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_SHIFT = if let Some((len, table)) =
            TableEXT_SHIFT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_ry = token_55(tokens_current);
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_SHIFT,
                m16_rx,
                m16_ry,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:714:1, end:714:2))"]
#[derive(Clone, Debug)]
struct sra_instructionVar827 {
    m16_rx: u8,
    m16_ry: u8,
    EXT_SHIFT: TableEXT_SHIFT,
}
impl sra_instructionVar827 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sra"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_SHIFT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_SHIFT = if let Some((len, table)) =
            TableEXT_SHIFT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_ry = token_55(tokens_current);
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_SHIFT,
                m16_rx,
                m16_ry,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:722:1, end:722:2))"]
#[derive(Clone, Debug)]
struct srl_instructionVar828 {
    m16_rx: u8,
    m16_ry: u8,
    EXT_SHIFT: TableEXT_SHIFT,
}
impl srl_instructionVar828 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srl"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_SHIFT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_SHIFT = if let Some((len, table)) =
            TableEXT_SHIFT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_SHIFT,
                m16_rx,
                m16_ry,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:745:1, end:745:2))"]
#[derive(Clone, Debug)]
struct sw_instructionVar829 {
    OFF_M16SP: TableOFF_M16SP,
}
impl sw_instructionVar829 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sw"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::ra),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_M16SP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let OFF_M16SP = if let Some((len, table)) =
            TableOFF_M16SP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_M16SP }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:410:1, end:410:2))"]
#[derive(Clone, Debug)]
struct addiu_instructionVar830 {
    RX: TableRX,
    EXT_IS8: TableEXT_IS8,
    RX32: TableRX32,
}
impl addiu_instructionVar830 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_IS8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_IS8 = if let Some((len, table)) =
            TableEXT_IS8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, EXT_IS8, RX32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:466:1, end:466:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar831 {
    Rel16_m16: TableRel16_m16,
}
impl b_instructionVar831 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16_m16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rel16_m16 = if let Some((len, table)) =
            TableRel16_m16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16_m16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:470:1, end:470:2))"]
#[derive(Clone, Debug)]
struct beqz_instructionVar832 {
    RX32: TableRX32,
    CRel16_m16: TableCRel16_m16,
}
impl beqz_instructionVar832 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beqz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CRel16_m16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRel16_m16 = if let Some((len, table)) =
            TableCRel16_m16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX32, CRel16_m16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:474:1, end:474:2))"]
#[derive(Clone, Debug)]
struct bnez_instructionVar833 {
    RX32: TableRX32,
    CRel16_m16: TableCRel16_m16,
}
impl bnez_instructionVar833 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnez"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CRel16_m16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RX32 = if let Some((len, table)) =
            TableRX32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRel16_m16 = if let Some((len, table)) =
            TableCRel16_m16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX32, CRel16_m16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:520:1, end:520:2))"]
#[derive(Clone, Debug)]
struct jal_instructionVar834 {
    Abs26_m16: TableAbs26_m16,
}
impl jal_instructionVar834 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_ext_delay(
                u8::try_from(i128::try_from(context.read_ext_delay()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("jal"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Abs26_m16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_delay(u8::try_from(2i128 & 3).unwrap());
        let Abs26_m16 = if let Some((len, table)) =
            TableAbs26_m16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Abs26_m16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:540:1, end:540:2))"]
#[derive(Clone, Debug)]
struct jalx_instructionVar835 {
    Abs26_m16: TableAbs26_m16,
}
impl jalx_instructionVar835 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(None, |context| {
            context.write_ISA_MODE(
                u8::try_from(i128::try_from(context.read_ISA_MODE()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_ext_delay(
                u8::try_from(i128::try_from(context.read_ext_delay()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("jalx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Abs26_m16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ISA_MODE(u8::try_from(0i128 & 1).unwrap());
        let Abs26_m16 = if let Some((len, table)) =
            TableAbs26_m16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Abs26_m16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:570:1, end:570:2))"]
#[derive(Clone, Debug)]
struct lb_instructionVar836 {
    m16_ry: u8,
    OFF_M16S0: TableOFF_M16S0,
}
impl lb_instructionVar836 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lb"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_M16S0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let OFF_M16S0 = if let Some((len, table)) =
            TableOFF_M16S0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_M16S0, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:574:1, end:574:2))"]
#[derive(Clone, Debug)]
struct lbu_instructionVar837 {
    m16_ry: u8,
    OFF_M16S0: TableOFF_M16S0,
}
impl lbu_instructionVar837 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_M16S0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let OFF_M16S0 = if let Some((len, table)) =
            TableOFF_M16S0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_M16S0, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:578:1, end:578:2))"]
#[derive(Clone, Debug)]
struct lh_instructionVar838 {
    m16_ry: u8,
    OFF_M16S1: TableOFF_M16S1,
}
impl lh_instructionVar838 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lh"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_M16S1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let OFF_M16S1 = if let Some((len, table)) =
            TableOFF_M16S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_M16S1, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:582:1, end:582:2))"]
#[derive(Clone, Debug)]
struct lhu_instructionVar839 {
    m16_ry: u8,
    OFF_M16S1: TableOFF_M16S1,
}
impl lhu_instructionVar839 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_M16S1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let OFF_M16S1 = if let Some((len, table)) =
            TableOFF_M16S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_M16S1, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:586:1, end:586:2))"]
#[derive(Clone, Debug)]
struct li_instructionVar840 {
    m16_rx: u8,
    EXT_LIU8: TableEXT_LIU8,
}
impl li_instructionVar840 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("li"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_LIU8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_LIU8 = if let Some((len, table)) =
            TableEXT_LIU8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_LIU8, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:590:1, end:590:2))"]
#[derive(Clone, Debug)]
struct lw_instructionVar841 {
    m16_ry: u8,
    OFF_M16: TableOFF_M16,
}
impl lw_instructionVar841 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lw"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_M16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let OFF_M16 = if let Some((len, table)) =
            TableOFF_M16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_M16, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:594:1, end:594:2))"]
#[derive(Clone, Debug)]
struct lw_instructionVar842 {
    m16_rx: u8,
    OFF_M16PC: TableOFF_M16PC,
}
impl lw_instructionVar842 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lw"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_M16PC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let OFF_M16PC = if let Some((len, table)) =
            TableOFF_M16PC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_M16PC, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:598:1, end:598:2))"]
#[derive(Clone, Debug)]
struct lw_instructionVar843 {
    m16_rx: u8,
    OFF_M16SP: TableOFF_M16SP,
}
impl lw_instructionVar843 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lw"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_M16SP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let OFF_M16SP = if let Some((len, table)) =
            TableOFF_M16SP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_M16SP, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:662:1, end:662:2))"]
#[derive(Clone, Debug)]
struct sb_instructionVar844 {
    OFF_M16S0: TableOFF_M16S0,
    RY32: TableRY32,
}
impl sb_instructionVar844 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RY32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_M16S0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RY32 = if let Some((len, table)) =
            TableRY32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let OFF_M16S0 = if let Some((len, table)) =
            TableOFF_M16S0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_M16S0, RY32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:682:1, end:682:2))"]
#[derive(Clone, Debug)]
struct sh_instructionVar845 {
    m16_ry: u8,
    OFF_M16S1: TableOFF_M16S1,
}
impl sh_instructionVar845 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sh"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_M16S1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let OFF_M16S1 = if let Some((len, table)) =
            TableOFF_M16S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_M16S1, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:698:1, end:698:2))"]
#[derive(Clone, Debug)]
struct slti_instructionVar846 {
    m16_rx: u8,
    EXT_SET: TableEXT_SET,
}
impl slti_instructionVar846 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slti"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_SET
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_SET = if let Some((len, table)) =
            TableEXT_SET::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_SET, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:704:1, end:704:2))"]
#[derive(Clone, Debug)]
struct sltiu_instructionVar847 {
    m16_rx: u8,
    EXT_SET: TableEXT_SET,
}
impl sltiu_instructionVar847 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sltiu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_SET
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_SET = if let Some((len, table)) =
            TableEXT_SET::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_SET, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:737:1, end:737:2))"]
#[derive(Clone, Debug)]
struct sw_instructionVar848 {
    m16_ry: u8,
    OFF_M16: TableOFF_M16,
}
impl sw_instructionVar848 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sw"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_ry),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_M16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let OFF_M16 = if let Some((len, table)) =
            TableOFF_M16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_ry = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_M16, m16_ry }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:741:1, end:741:2))"]
#[derive(Clone, Debug)]
struct sw_instructionVar849 {
    m16_rx: u8,
    OFF_M16SP: TableOFF_M16SP,
}
impl sw_instructionVar849 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sw"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_M16SP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let OFF_M16SP = if let Some((len, table)) =
            TableOFF_M16SP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_M16SP, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2292:1, end:2292:2))"]
#[derive(Clone, Debug)]
struct cvt_s_PL_instructionVar850 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl cvt_s_PL_instructionVar850 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.s.PL"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2296:1, end:2296:2))"]
#[derive(Clone, Debug)]
struct cvt_s_PU_instructionVar851 {
    mic_ft_5: u8,
    mic_fs: u8,
}
impl cvt_s_PU_instructionVar851 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.s.PU"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_ft_5, mic_fs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2062:1, end:2062:2))"]
#[derive(Clone, Debug)]
struct c_f_S_instructionVar852 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_f_S_instructionVar852 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.f.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2066:1, end:2066:2))"]
#[derive(Clone, Debug)]
struct c_f_D_instructionVar853 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_f_D_instructionVar853 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.f.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2070:1, end:2070:2))"]
#[derive(Clone, Debug)]
struct c_f_PS_instructionVar854 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_f_PS_instructionVar854 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.f.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2074:1, end:2074:2))"]
#[derive(Clone, Debug)]
struct c_un_S_instructionVar855 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_un_S_instructionVar855 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.un.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2079:1, end:2079:2))"]
#[derive(Clone, Debug)]
struct c_un_D_instructionVar856 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_un_D_instructionVar856 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.un.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2084:1, end:2084:2))"]
#[derive(Clone, Debug)]
struct c_un_PS_instructionVar857 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_un_PS_instructionVar857 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.un.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2088:1, end:2088:2))"]
#[derive(Clone, Debug)]
struct c_eq_S_instructionVar858 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_eq_S_instructionVar858 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.eq.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2093:1, end:2093:2))"]
#[derive(Clone, Debug)]
struct c_eq_D_instructionVar859 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_eq_D_instructionVar859 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.eq.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2098:1, end:2098:2))"]
#[derive(Clone, Debug)]
struct c_eq_PS_instructionVar860 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_eq_PS_instructionVar860 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.eq.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2102:1, end:2102:2))"]
#[derive(Clone, Debug)]
struct c_ueq_S_instructionVar861 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ueq_S_instructionVar861 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ueq.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2107:1, end:2107:2))"]
#[derive(Clone, Debug)]
struct c_ueq_D_instructionVar862 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ueq_D_instructionVar862 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ueq.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2112:1, end:2112:2))"]
#[derive(Clone, Debug)]
struct c_ueq_PS_instructionVar863 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ueq_PS_instructionVar863 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ueq.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2116:1, end:2116:2))"]
#[derive(Clone, Debug)]
struct c_olt_S_instructionVar864 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_olt_S_instructionVar864 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.olt.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2121:1, end:2121:2))"]
#[derive(Clone, Debug)]
struct c_olt_D_instructionVar865 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_olt_D_instructionVar865 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.olt.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2126:1, end:2126:2))"]
#[derive(Clone, Debug)]
struct c_olt_PS_instructionVar866 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_olt_PS_instructionVar866 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.olt.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2130:1, end:2130:2))"]
#[derive(Clone, Debug)]
struct c_ult_S_instructionVar867 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ult_S_instructionVar867 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ult.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2135:1, end:2135:2))"]
#[derive(Clone, Debug)]
struct c_ult_D_instructionVar868 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ult_D_instructionVar868 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ult.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2140:1, end:2140:2))"]
#[derive(Clone, Debug)]
struct c_ult_PS_instructionVar869 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ult_PS_instructionVar869 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ult.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2144:1, end:2144:2))"]
#[derive(Clone, Debug)]
struct c_ole_S_instructionVar870 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ole_S_instructionVar870 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ole.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2149:1, end:2149:2))"]
#[derive(Clone, Debug)]
struct c_ole_D_instructionVar871 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ole_D_instructionVar871 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ole.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2154:1, end:2154:2))"]
#[derive(Clone, Debug)]
struct c_ole_PS_instructionVar872 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ole_PS_instructionVar872 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ole.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2158:1, end:2158:2))"]
#[derive(Clone, Debug)]
struct c_ule_S_instructionVar873 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ule_S_instructionVar873 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ule.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2163:1, end:2163:2))"]
#[derive(Clone, Debug)]
struct c_ule_D_instructionVar874 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ule_D_instructionVar874 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ule.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2168:1, end:2168:2))"]
#[derive(Clone, Debug)]
struct c_ule_PS_instructionVar875 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ule_PS_instructionVar875 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ule.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2172:1, end:2172:2))"]
#[derive(Clone, Debug)]
struct c_sf_S_instructionVar876 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_sf_S_instructionVar876 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.sf.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2177:1, end:2177:2))"]
#[derive(Clone, Debug)]
struct c_sf_D_instructionVar877 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_sf_D_instructionVar877 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.sf.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2182:1, end:2182:2))"]
#[derive(Clone, Debug)]
struct c_sf_PS_instructionVar878 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_sf_PS_instructionVar878 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.sf.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2186:1, end:2186:2))"]
#[derive(Clone, Debug)]
struct c_ngle_S_instructionVar879 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ngle_S_instructionVar879 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngle.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2191:1, end:2191:2))"]
#[derive(Clone, Debug)]
struct c_ngle_D_instructionVar880 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ngle_D_instructionVar880 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngle.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2196:1, end:2196:2))"]
#[derive(Clone, Debug)]
struct c_ngle_PS_instructionVar881 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ngle_PS_instructionVar881 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngle.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2200:1, end:2200:2))"]
#[derive(Clone, Debug)]
struct c_seq_S_instructionVar882 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_seq_S_instructionVar882 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.seq.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2205:1, end:2205:2))"]
#[derive(Clone, Debug)]
struct c_seq_D_instructionVar883 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_seq_D_instructionVar883 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.seq.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2210:1, end:2210:2))"]
#[derive(Clone, Debug)]
struct c_seq_PS_instructionVar884 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_seq_PS_instructionVar884 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.seq.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2214:1, end:2214:2))"]
#[derive(Clone, Debug)]
struct c_ngl_S_instructionVar885 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ngl_S_instructionVar885 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngl.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2219:1, end:2219:2))"]
#[derive(Clone, Debug)]
struct c_ngl_D_instructionVar886 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ngl_D_instructionVar886 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngl.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2224:1, end:2224:2))"]
#[derive(Clone, Debug)]
struct c_ngl_PS_instructionVar887 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ngl_PS_instructionVar887 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngl.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2228:1, end:2228:2))"]
#[derive(Clone, Debug)]
struct c_lt_S_instructionVar888 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_lt_S_instructionVar888 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.lt.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2233:1, end:2233:2))"]
#[derive(Clone, Debug)]
struct c_lt_D_instructionVar889 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_lt_D_instructionVar889 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.lt.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2238:1, end:2238:2))"]
#[derive(Clone, Debug)]
struct c_lt_PS_instructionVar890 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_lt_PS_instructionVar890 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.lt.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2242:1, end:2242:2))"]
#[derive(Clone, Debug)]
struct c_nge_S_instructionVar891 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_nge_S_instructionVar891 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.nge.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2247:1, end:2247:2))"]
#[derive(Clone, Debug)]
struct c_nge_D_instructionVar892 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_nge_D_instructionVar892 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.nge.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2252:1, end:2252:2))"]
#[derive(Clone, Debug)]
struct c_nge_PS_instructionVar893 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_nge_PS_instructionVar893 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.nge.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2256:1, end:2256:2))"]
#[derive(Clone, Debug)]
struct c_le_S_instructionVar894 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_le_S_instructionVar894 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.le.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2261:1, end:2261:2))"]
#[derive(Clone, Debug)]
struct c_le_D_instructionVar895 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_le_D_instructionVar895 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.le.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2266:1, end:2266:2))"]
#[derive(Clone, Debug)]
struct c_le_PS_instructionVar896 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_le_PS_instructionVar896 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.le.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2270:1, end:2270:2))"]
#[derive(Clone, Debug)]
struct c_ngt_S_instructionVar897 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ngt_S_instructionVar897 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngt.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2275:1, end:2275:2))"]
#[derive(Clone, Debug)]
struct c_ngt_D_instructionVar898 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ngt_D_instructionVar898 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngt.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2280:1, end:2280:2))"]
#[derive(Clone, Debug)]
struct c_ngt_PS_instructionVar899 {
    micb_cc: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl c_ngt_PS_instructionVar899 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("c.ngt.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_cc,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2613:1, end:2613:2))"]
#[derive(Clone, Debug)]
struct movf_instructionVar900 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    micb_cc: u8,
}
impl movf_instructionVar900 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movf"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_rs32_0,
                micb_cc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2620:1, end:2620:2))"]
#[derive(Clone, Debug)]
struct movf_S_instructionVar901 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_cc: u8,
}
impl movf_S_instructionVar901 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movf.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_cc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2628:1, end:2628:2))"]
#[derive(Clone, Debug)]
struct movf_D_instructionVar902 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_cc: u8,
}
impl movf_D_instructionVar902 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movf.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_cc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2635:1, end:2635:2))"]
#[derive(Clone, Debug)]
struct movf_PS_instructionVar903 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_cc: u8,
}
impl movf_PS_instructionVar903 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movf.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_cc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2663:1, end:2663:2))"]
#[derive(Clone, Debug)]
struct movt_instructionVar904 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    micb_cc: u8,
}
impl movt_instructionVar904 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movt"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_rs32_0,
                micb_cc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2670:1, end:2670:2))"]
#[derive(Clone, Debug)]
struct movt_S_instructionVar905 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_cc: u8,
}
impl movt_S_instructionVar905 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movt.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_cc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2678:1, end:2678:2))"]
#[derive(Clone, Debug)]
struct movt_D_instructionVar906 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_cc: u8,
}
impl movt_D_instructionVar906 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movt.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_cc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2685:1, end:2685:2))"]
#[derive(Clone, Debug)]
struct movt_PS_instructionVar907 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_cc: u8,
}
impl movt_PS_instructionVar907 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movt.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_cc as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_cc = token_104(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_cc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3695:1, end:3695:2))"]
#[derive(Clone, Debug)]
struct rdhwr_instructionVar908 {
    mic_rt32_5: u8,
    mic_rs32_hw: u8,
    micb_sel: u8,
}
impl rdhwr_instructionVar908 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdhwr"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_26_display(self.mic_rs32_hw),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_sel as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_hw = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_sel = token_111(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_rs32_hw,
                micb_sel,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1072:1, end:1072:2))"]
#[derive(Clone, Debug)]
struct lwxs_instructionVar909 {
    micb_rd32: u8,
    mic_index: u8,
    mic_base0: u8,
}
impl lwxs_instructionVar909 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwxs"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_index),
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_index = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c135 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c136 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_72(tokens) != 280 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c136(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c136 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_72(tokens) != 256 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c136(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c135(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_rd32,
                mic_index,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1079:1, end:1079:2))"]
#[derive(Clone, Debug)]
struct mfc0_instructionVar910 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    CPSEL: TableCPSEL,
}
impl mfc0_instructionVar910 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfc0"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CPSEL
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let CPSEL = if let Some((len, table)) =
            TableCPSEL::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CPSEL,
                mic_rt32_5,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1091:1, end:1091:2))"]
#[derive(Clone, Debug)]
struct mfhc0_instructionVar911 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    CPSEL: TableCPSEL,
}
impl mfhc0_instructionVar911 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfhc0"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CPSEL
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let CPSEL = if let Some((len, table)) =
            TableCPSEL::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CPSEL,
                mic_rt32_5,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1122:1, end:1122:2))"]
#[derive(Clone, Debug)]
struct mtc0_instructionVar912 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    CPSEL: TableCPSEL,
}
impl mtc0_instructionVar912 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtc0"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CPSEL
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let CPSEL = if let Some((len, table)) =
            TableCPSEL::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CPSEL,
                mic_rt32_5,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1134:1, end:1134:2))"]
#[derive(Clone, Debug)]
struct mthc0_instructionVar913 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    CPSEL: TableCPSEL,
}
impl mthc0_instructionVar913 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mthc0"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CPSEL
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let CPSEL = if let Some((len, table)) =
            TableCPSEL::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CPSEL,
                mic_rt32_5,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1146:1, end:1146:2))"]
#[derive(Clone, Debug)]
struct mul_instructionVar914 {
    micb_rd32: u8,
    RS0L: TableRS0L,
    RT5L: TableRT5L,
}
impl mul_instructionVar914 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c116 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c117 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_72(tokens) != 528 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c117(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c117 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_72(tokens) != 24 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c117(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c116(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                RT5L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1544:1, end:1544:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar915 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl teq_instructionVar915 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1550:1, end:1550:2))"]
#[derive(Clone, Debug)]
struct tge_instructionVar916 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl tge_instructionVar916 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tge"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1556:1, end:1556:2))"]
#[derive(Clone, Debug)]
struct tgeu_instructionVar917 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl tgeu_instructionVar917 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tgeu"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1586:1, end:1586:2))"]
#[derive(Clone, Debug)]
struct tlt_instructionVar918 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl tlt_instructionVar918 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlt"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1592:1, end:1592:2))"]
#[derive(Clone, Debug)]
struct tltu_instructionVar919 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl tltu_instructionVar919 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tltu"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1598:1, end:1598:2))"]
#[derive(Clone, Debug)]
struct tne_instructionVar920 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl tne_instructionVar920 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tne"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1918:1, end:1918:2))"]
#[derive(Clone, Debug)]
struct add_PS_instructionVar921 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl add_PS_instructionVar921 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2288:1, end:2288:2))"]
#[derive(Clone, Debug)]
struct cvt_PS_instructionVar922 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cvt_PS_instructionVar922 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cvt.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2550:1, end:2550:2))"]
#[derive(Clone, Debug)]
struct lwxc1_instructionVar923 {
    micb_fd: u8,
    mic_index: u8,
    mic_base0: u8,
}
impl lwxc1_instructionVar923 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwxc1"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_index),
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_index = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_index,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2640:1, end:2640:2))"]
#[derive(Clone, Debug)]
struct movn_instructionVar924 {
    micb_rd32: u8,
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl movn_instructionVar924 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movn"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_rd32,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2646:1, end:2646:2))"]
#[derive(Clone, Debug)]
struct movn_S_instructionVar925 {
    micb_fd: u8,
    mic_fs: u8,
    mic_rt32_5: u8,
}
impl movn_S_instructionVar925 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movn.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2653:1, end:2653:2))"]
#[derive(Clone, Debug)]
struct movn_D_instructionVar926 {
    micb_fd: u8,
    mic_fs: u8,
    mic_rt32_5: u8,
}
impl movn_D_instructionVar926 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movn.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2659:1, end:2659:2))"]
#[derive(Clone, Debug)]
struct movn_PS_instructionVar927 {
    micb_fd: u8,
    mic_fs: u8,
    mic_rt32_5: u8,
}
impl movn_PS_instructionVar927 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movn.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2689:1, end:2689:2))"]
#[derive(Clone, Debug)]
struct movz_instructionVar928 {
    micb_rd32: u8,
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl movz_instructionVar928 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movz"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_rd32,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2695:1, end:2695:2))"]
#[derive(Clone, Debug)]
struct movz_S_instructionVar929 {
    micb_fd: u8,
    mic_fs: u8,
    mic_rt32_5: u8,
}
impl movz_S_instructionVar929 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movz.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2702:1, end:2702:2))"]
#[derive(Clone, Debug)]
struct movz_D_instructionVar930 {
    micb_fd: u8,
    mic_fs: u8,
    mic_rt32_5: u8,
}
impl movz_D_instructionVar930 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movz.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2708:1, end:2708:2))"]
#[derive(Clone, Debug)]
struct movz_PS_instructionVar931 {
    micb_fd: u8,
    mic_fs: u8,
    mic_rt32_5: u8,
}
impl movz_PS_instructionVar931 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movz.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2755:1, end:2755:2))"]
#[derive(Clone, Debug)]
struct mul_PS_instructionVar932 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl mul_PS_instructionVar932 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2779:1, end:2779:2))"]
#[derive(Clone, Debug)]
struct pll_PS_instructionVar933 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl pll_PS_instructionVar933 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pll.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2783:1, end:2783:2))"]
#[derive(Clone, Debug)]
struct plu_PS_instructionVar934 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl plu_PS_instructionVar934 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("plu.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2787:1, end:2787:2))"]
#[derive(Clone, Debug)]
struct prefx_instructionVar935 {
    micb_hint: u8,
    mic_index: u8,
    mic_base0: u8,
}
impl prefx_instructionVar935 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("prefx"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_hint as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_index),
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base0 = token_53(tokens_current);
        let mic_index = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_hint = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_hint,
                mic_index,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2792:1, end:2792:2))"]
#[derive(Clone, Debug)]
struct pul_PS_instructionVar936 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl pul_PS_instructionVar936 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pul.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2796:1, end:2796:2))"]
#[derive(Clone, Debug)]
struct puu_PS_instructionVar937 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl puu_PS_instructionVar937 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("puu.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2941:1, end:2941:2))"]
#[derive(Clone, Debug)]
struct sdxc1_instructionVar938 {
    micb_fd: u8,
    mic_index: u8,
    mic_base0: u8,
}
impl sdxc1_instructionVar938 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdxc1"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_index),
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_index = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_index,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2948:1, end:2948:2))"]
#[derive(Clone, Debug)]
struct swxc1_instructionVar939 {
    micb_fd: u8,
    mic_index: u8,
    mic_base0: u8,
}
impl swxc1_instructionVar939 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swxc1"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_index),
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_index = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_index,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3270:1, end:3270:2))"]
#[derive(Clone, Debug)]
struct cmp_af_S_instructionVar940 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_af_S_instructionVar940 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.af.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3275:1, end:3275:2))"]
#[derive(Clone, Debug)]
struct cmp_af_D_instructionVar941 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_af_D_instructionVar941 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.af.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3280:1, end:3280:2))"]
#[derive(Clone, Debug)]
struct cmp_un_S_instructionVar942 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_un_S_instructionVar942 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.un.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3285:1, end:3285:2))"]
#[derive(Clone, Debug)]
struct cmp_un_D_instructionVar943 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_un_D_instructionVar943 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.un.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3290:1, end:3290:2))"]
#[derive(Clone, Debug)]
struct cmp_eq_S_instructionVar944 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_eq_S_instructionVar944 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.eq.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3295:1, end:3295:2))"]
#[derive(Clone, Debug)]
struct cmp_eq_D_instructionVar945 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_eq_D_instructionVar945 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.eq.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3300:1, end:3300:2))"]
#[derive(Clone, Debug)]
struct cmp_ueq_S_instructionVar946 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_ueq_S_instructionVar946 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ueq.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3305:1, end:3305:2))"]
#[derive(Clone, Debug)]
struct cmp_ueq_D_instructionVar947 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_ueq_D_instructionVar947 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ueq.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3310:1, end:3310:2))"]
#[derive(Clone, Debug)]
struct cmp_lt_S_instructionVar948 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_lt_S_instructionVar948 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.lt.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3315:1, end:3315:2))"]
#[derive(Clone, Debug)]
struct cmp_lt_D_instructionVar949 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_lt_D_instructionVar949 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.lt.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3320:1, end:3320:2))"]
#[derive(Clone, Debug)]
struct cmp_ult_S_instructionVar950 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_ult_S_instructionVar950 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ult.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3325:1, end:3325:2))"]
#[derive(Clone, Debug)]
struct cmp_ult_D_instructionVar951 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_ult_D_instructionVar951 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ult.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3330:1, end:3330:2))"]
#[derive(Clone, Debug)]
struct cmp_le_S_instructionVar952 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_le_S_instructionVar952 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.le.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3335:1, end:3335:2))"]
#[derive(Clone, Debug)]
struct cmp_le_D_instructionVar953 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_le_D_instructionVar953 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.le.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3340:1, end:3340:2))"]
#[derive(Clone, Debug)]
struct cmp_ule_S_instructionVar954 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_ule_S_instructionVar954 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ule.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3345:1, end:3345:2))"]
#[derive(Clone, Debug)]
struct cmp_ule_D_instructionVar955 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_ule_D_instructionVar955 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ule.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3350:1, end:3350:2))"]
#[derive(Clone, Debug)]
struct cmp_saf_S_instructionVar956 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_saf_S_instructionVar956 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.saf.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3355:1, end:3355:2))"]
#[derive(Clone, Debug)]
struct cmp_saf_D_instructionVar957 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_saf_D_instructionVar957 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.saf.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3360:1, end:3360:2))"]
#[derive(Clone, Debug)]
struct cmp_sun_S_instructionVar958 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sun_S_instructionVar958 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sun.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3365:1, end:3365:2))"]
#[derive(Clone, Debug)]
struct cmp_sun_D_instructionVar959 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sun_D_instructionVar959 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sun.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3370:1, end:3370:2))"]
#[derive(Clone, Debug)]
struct cmp_seq_S_instructionVar960 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_seq_S_instructionVar960 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.seq.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3375:1, end:3375:2))"]
#[derive(Clone, Debug)]
struct cmp_seq_D_instructionVar961 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_seq_D_instructionVar961 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.seq.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3380:1, end:3380:2))"]
#[derive(Clone, Debug)]
struct cmp_sueq_S_instructionVar962 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sueq_S_instructionVar962 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sueq.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3385:1, end:3385:2))"]
#[derive(Clone, Debug)]
struct cmp_sueq_D_instructionVar963 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sueq_D_instructionVar963 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sueq.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3390:1, end:3390:2))"]
#[derive(Clone, Debug)]
struct cmp_slt_S_instructionVar964 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_slt_S_instructionVar964 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.slt.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3395:1, end:3395:2))"]
#[derive(Clone, Debug)]
struct cmp_slt_D_instructionVar965 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_slt_D_instructionVar965 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.slt.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3400:1, end:3400:2))"]
#[derive(Clone, Debug)]
struct cmp_sult_S_instructionVar966 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sult_S_instructionVar966 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sult.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3405:1, end:3405:2))"]
#[derive(Clone, Debug)]
struct cmp_sult_D_instructionVar967 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sult_D_instructionVar967 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sult.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3410:1, end:3410:2))"]
#[derive(Clone, Debug)]
struct cmp_sle_S_instructionVar968 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sle_S_instructionVar968 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sle.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3415:1, end:3415:2))"]
#[derive(Clone, Debug)]
struct cmp_sle_D_instructionVar969 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sle_D_instructionVar969 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sle.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3420:1, end:3420:2))"]
#[derive(Clone, Debug)]
struct cmp_sule_S_instructionVar970 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sule_S_instructionVar970 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sule.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3425:1, end:3425:2))"]
#[derive(Clone, Debug)]
struct cmp_sule_D_instructionVar971 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sule_D_instructionVar971 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sule.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3430:1, end:3430:2))"]
#[derive(Clone, Debug)]
struct cmp_or_S_instructionVar972 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_or_S_instructionVar972 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.or.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3435:1, end:3435:2))"]
#[derive(Clone, Debug)]
struct cmp_or_D_instructionVar973 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_or_D_instructionVar973 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.or.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3440:1, end:3440:2))"]
#[derive(Clone, Debug)]
struct cmp_une_S_instructionVar974 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_une_S_instructionVar974 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.une.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3446:1, end:3446:2))"]
#[derive(Clone, Debug)]
struct cmp_une_D_instructionVar975 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_une_D_instructionVar975 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.une.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3451:1, end:3451:2))"]
#[derive(Clone, Debug)]
struct cmp_ne_S_instructionVar976 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_ne_S_instructionVar976 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ne.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3457:1, end:3457:2))"]
#[derive(Clone, Debug)]
struct cmp_ne_D_instructionVar977 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_ne_D_instructionVar977 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.ne.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3462:1, end:3462:2))"]
#[derive(Clone, Debug)]
struct cmp_sor_S_instructionVar978 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sor_S_instructionVar978 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sor.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3467:1, end:3467:2))"]
#[derive(Clone, Debug)]
struct cmp_sor_D_instructionVar979 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sor_D_instructionVar979 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sor.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3472:1, end:3472:2))"]
#[derive(Clone, Debug)]
struct cmp_sune_S_instructionVar980 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sune_S_instructionVar980 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sune.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3477:1, end:3477:2))"]
#[derive(Clone, Debug)]
struct cmp_sune_D_instructionVar981 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sune_D_instructionVar981 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sune.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3482:1, end:3482:2))"]
#[derive(Clone, Debug)]
struct cmp_sne_S_instructionVar982 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sne_S_instructionVar982 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sne.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3487:1, end:3487:2))"]
#[derive(Clone, Debug)]
struct cmp_sne_D_instructionVar983 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl cmp_sne_D_instructionVar983 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.sne.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3492:1, end:3492:2))"]
#[derive(Clone, Debug)]
struct div_instructionVar984 {
    micb_rd32: u8,
    RS0L: TableRS0L,
    RT5L: TableRT5L,
}
impl div_instructionVar984 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("div"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                RT5L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3497:1, end:3497:2))"]
#[derive(Clone, Debug)]
struct divu_instructionVar985 {
    micb_rd32: u8,
    RS0L: TableRS0L,
    RT5L: TableRT5L,
}
impl divu_instructionVar985 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                RT5L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3597:1, end:3597:2))"]
#[derive(Clone, Debug)]
struct maddf_S_instructionVar986 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl maddf_S_instructionVar986 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maddf.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3602:1, end:3602:2))"]
#[derive(Clone, Debug)]
struct maddf_D_instructionVar987 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl maddf_D_instructionVar987 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maddf.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3606:1, end:3606:2))"]
#[derive(Clone, Debug)]
struct max_S_instructionVar988 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl max_S_instructionVar988 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("max.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3612:1, end:3612:2))"]
#[derive(Clone, Debug)]
struct max_D_instructionVar989 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl max_D_instructionVar989 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("max.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3617:1, end:3617:2))"]
#[derive(Clone, Debug)]
struct maxa_S_instructionVar990 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl maxa_S_instructionVar990 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maxa.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3623:1, end:3623:2))"]
#[derive(Clone, Debug)]
struct maxa_D_instructionVar991 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl maxa_D_instructionVar991 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maxa.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3628:1, end:3628:2))"]
#[derive(Clone, Debug)]
struct min_S_instructionVar992 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl min_S_instructionVar992 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("min.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3634:1, end:3634:2))"]
#[derive(Clone, Debug)]
struct min_D_instructionVar993 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl min_D_instructionVar993 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("min.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3639:1, end:3639:2))"]
#[derive(Clone, Debug)]
struct mina_S_instructionVar994 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl mina_S_instructionVar994 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mina.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3645:1, end:3645:2))"]
#[derive(Clone, Debug)]
struct mina_D_instructionVar995 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl mina_D_instructionVar995 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mina.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3650:1, end:3650:2))"]
#[derive(Clone, Debug)]
struct mod_instructionVar996 {
    micb_rd32: u8,
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl mod_instructionVar996 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mod"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                RS0L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3655:1, end:3655:2))"]
#[derive(Clone, Debug)]
struct modu_instructionVar997 {
    micb_rd32: u8,
    RS0L: TableRS0L,
    RT5L: TableRT5L,
}
impl modu_instructionVar997 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("modu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                RT5L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3660:1, end:3660:2))"]
#[derive(Clone, Debug)]
struct msubf_S_instructionVar998 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl msubf_S_instructionVar998 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msubf.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3666:1, end:3666:2))"]
#[derive(Clone, Debug)]
struct msubf_D_instructionVar999 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl msubf_D_instructionVar999 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msubf.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3670:1, end:3670:2))"]
#[derive(Clone, Debug)]
struct muh_instructionVar1000 {
    micb_rd32: u8,
    RS0L: TableRS0L,
    RT5L: TableRT5L,
}
impl muh_instructionVar1000 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("muh"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                RT5L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3678:1, end:3678:2))"]
#[derive(Clone, Debug)]
struct mulu_instructionVar1001 {
    micb_rd32: u8,
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl mulu_instructionVar1001 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                RS0L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3686:1, end:3686:2))"]
#[derive(Clone, Debug)]
struct muhu_instructionVar1002 {
    micb_rd32: u8,
    RS0L: TableRS0L,
    RT5L: TableRT5L,
}
impl muhu_instructionVar1002 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("muhu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                RT5L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3747:1, end:3747:2))"]
#[derive(Clone, Debug)]
struct seleqz_instructionVar1003 {
    micb_rd32: u8,
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl seleqz_instructionVar1003 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("seleqz"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_rd32,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3756:1, end:3756:2))"]
#[derive(Clone, Debug)]
struct selnez_instructionVar1004 {
    micb_rd32: u8,
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl selnez_instructionVar1004 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("selnez"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_rd32,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3765:1, end:3765:2))"]
#[derive(Clone, Debug)]
struct sel_S_instructionVar1005 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl sel_S_instructionVar1005 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sel.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3770:1, end:3770:2))"]
#[derive(Clone, Debug)]
struct sel_D_instructionVar1006 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl sel_D_instructionVar1006 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sel.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3775:1, end:3775:2))"]
#[derive(Clone, Debug)]
struct seleqz_S_instructionVar1007 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl seleqz_S_instructionVar1007 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("seleqz.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3779:1, end:3779:2))"]
#[derive(Clone, Debug)]
struct seleqz_D_instructionVar1008 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl seleqz_D_instructionVar1008 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("seleqz.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3783:1, end:3783:2))"]
#[derive(Clone, Debug)]
struct selnez_S_instructionVar1009 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl selnez_S_instructionVar1009 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("selnez.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3787:1, end:3787:2))"]
#[derive(Clone, Debug)]
struct selnez_D_instructionVar1010 {
    mic_ft_5: u8,
    mic_fs: u8,
    micb_fd: u8,
}
impl selnez_D_instructionVar1010 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("selnez.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_ft_5,
                mic_fs,
                micb_fd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:568:1, end:568:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar1011 {
    micb_rd32: u8,
    RS0L: TableRS0L,
    RT5L: TableRT5L,
}
impl add_instructionVar1011 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                RT5L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:578:1, end:578:2))"]
#[derive(Clone, Debug)]
struct add_S_instructionVar1012 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl add_S_instructionVar1012 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:583:1, end:583:2))"]
#[derive(Clone, Debug)]
struct add_D_instructionVar1013 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl add_D_instructionVar1013 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1932:1, end:1932:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar1014 {
    Rel16_mic: TableRel16_mic,
}
impl b_instructionVar1014 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1942:1, end:1942:2))"]
#[derive(Clone, Debug)]
struct bal_instructionVar1015 {
    Rel16_mic: TableRel16_mic,
}
impl bal_instructionVar1015 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bal"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2394:1, end:2394:2))"]
#[derive(Clone, Debug)]
struct jr16_instructionVar1016 {}
impl jr16_instructionVar1016 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jr16"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::ra),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2417:1, end:2417:2))"]
#[derive(Clone, Debug)]
struct jrc_instructionVar1017 {}
impl jrc_instructionVar1017 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jrc"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::ra),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3096:1, end:3096:2))"]
#[derive(Clone, Debug)]
struct bad1_instructionVar1018 {
    Rel16_mic: TableRel16_mic,
}
impl bad1_instructionVar1018 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bad1"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3113:1, end:3113:2))"]
#[derive(Clone, Debug)]
struct bad2_instructionVar1019 {
    Rel16_mic: TableRel16_mic,
}
impl bad2_instructionVar1019 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bad2"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3130:1, end:3130:2))"]
#[derive(Clone, Debug)]
struct beqzalc_instructionVar1020 {
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl beqzalc_instructionVar1020 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beqzalc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        if token_69(tokens_current) == 0 {
            return None;
        }
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3152:1, end:3152:2))"]
#[derive(Clone, Debug)]
struct bnezalc_instructionVar1021 {
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bnezalc_instructionVar1021 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnezalc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        if token_69(tokens_current) == 0 {
            return None;
        }
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3173:1, end:3173:2))"]
#[derive(Clone, Debug)]
struct bad3_instructionVar1022 {
    Rel16_mic: TableRel16_mic,
}
impl bad3_instructionVar1022 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bad3"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3186:1, end:3186:2))"]
#[derive(Clone, Debug)]
struct bad4_instructionVar1023 {
    Rel16_mic: TableRel16_mic,
}
impl bad4_instructionVar1023 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bad4"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3553:1, end:3553:2))"]
#[derive(Clone, Debug)]
struct jrc16_instructionVar1024 {}
impl jrc16_instructionVar1024 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jrc16"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::ra),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:659:1, end:659:2))"]
#[derive(Clone, Debug)]
struct break16_instructionVar1025 {
    SDB16: TableSDB16,
}
impl break16_instructionVar1025 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("break16"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let SDB16 = if let Some((len, table)) =
            TableSDB16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c69 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c70 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_88(tokens) != 40 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c70(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c70 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_83(tokens) != 27 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c70(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c69(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SDB16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1316:1, end:1316:2))"]
#[derive(Clone, Debug)]
struct sdbbp16_instructionVar1026 {
    SDB16: TableSDB16,
}
impl sdbbp16_instructionVar1026 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdbbp16"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.SDB16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let SDB16 = if let Some((len, table)) =
            TableSDB16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c74 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c75 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_88(tokens) != 44 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c75(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c75 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_83(tokens) != 59 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c75(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c74(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SDB16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1948:1, end:1948:2))"]
#[derive(Clone, Debug)]
struct bc1f_instructionVar1027 {
    COP2CC: TableCOP2CC,
    Rel16_mic: TableRel16_mic,
}
impl bc1f_instructionVar1027 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1f"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.COP2CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let COP2CC = if let Some((len, table)) =
            TableCOP2CC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COP2CC, Rel16_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1956:1, end:1956:2))"]
#[derive(Clone, Debug)]
struct bc1t_instructionVar1028 {
    COP2CC: TableCOP2CC,
    Rel16_mic: TableRel16_mic,
}
impl bc1t_instructionVar1028 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1t"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.COP2CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let COP2CC = if let Some((len, table)) =
            TableCOP2CC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COP2CC, Rel16_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1964:1, end:1964:2))"]
#[derive(Clone, Debug)]
struct bc2f_instructionVar1029 {
    COP2CC: TableCOP2CC,
    Rel16_mic: TableRel16_mic,
}
impl bc2f_instructionVar1029 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2f"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.COP2CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let COP2CC = if let Some((len, table)) =
            TableCOP2CC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COP2CC, Rel16_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1971:1, end:1971:2))"]
#[derive(Clone, Debug)]
struct bc2t_instructionVar1030 {
    COP2CC: TableCOP2CC,
    Rel16_mic: TableRel16_mic,
}
impl bc2t_instructionVar1030 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2t"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.COP2CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let COP2CC = if let Some((len, table)) =
            TableCOP2CC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COP2CC, Rel16_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1534:1, end:1534:2))"]
#[derive(Clone, Debug)]
struct synci_instructionVar1031 {
    mic_base0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl synci_instructionVar1031 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("synci"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c87 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c88 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_69(tokens) != 16 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c88(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c88 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_69(tokens) != 12 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c88(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c87(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3024:1, end:3024:2))"]
#[derive(Clone, Debug)]
struct align_instructionVar1032 {
    micb_rd32: u8,
    micb_bp: u8,
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl align_instructionVar1032 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("align"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_bp as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        let micb_bp = token_93(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                RS0L,
                micb_rd32,
                micb_bp,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3576:1, end:3576:2))"]
#[derive(Clone, Debug)]
struct lsa_instructionVar1033 {
    micb_rd32: u8,
    RT5L: TableRT5L,
    RS0L: TableRS0L,
    EXT_SA9: TableEXT_SA9,
}
impl lsa_instructionVar1033 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsa"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_SA9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_SA9 = if let Some((len, table)) =
            TableEXT_SA9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                RS0L,
                EXT_SA9,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3791:1, end:3791:2))"]
#[derive(Clone, Debug)]
struct sigrie_instructionVar1034 {
    mic_imm6r6: u8,
    EXT_CODE16: TableEXT_CODE16,
}
impl sigrie_instructionVar1034 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sigrie"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.EXT_CODE16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_imm6(
            u8::try_from(i128::try_from(token_83(tokens_current)).unwrap() & 63).unwrap(),
        );
        let mic_imm6r6 = token_83(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE16 = if let Some((len, table)) =
            TableEXT_CODE16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE16,
                mic_imm6r6,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1928:1, end:1928:2))"]
#[derive(Clone, Debug)]
struct alnv_ps_instructionVar1035 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
    micb_rs32: u8,
}
impl alnv_ps_instructionVar1035 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("alnv.ps"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rs32),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        let micb_rs32 = token_105(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
                micb_rs32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1990:1, end:1990:2))"]
#[derive(Clone, Debug)]
struct beqzc_instructionVar1036 {
    mic_rs32_0: u8,
    Rel16_mic: TableRel16_mic,
}
impl beqzc_instructionVar1036 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beqzc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1994:1, end:1994:2))"]
#[derive(Clone, Debug)]
struct bgez_instructionVar1037 {
    mic_rs32_0: u8,
    Rel16_mic: TableRel16_mic,
}
impl bgez_instructionVar1037 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgez"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2000:1, end:2000:2))"]
#[derive(Clone, Debug)]
struct bgezal_instructionVar1038 {
    mic_rs32_0: u8,
    Rel16_mic: TableRel16_mic,
}
impl bgezal_instructionVar1038 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgezal"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2007:1, end:2007:2))"]
#[derive(Clone, Debug)]
struct bgezals_instructionVar1039 {
    mic_rs32_0: u8,
    Rel16_mic: TableRel16_mic,
}
impl bgezals_instructionVar1039 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgezals"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2014:1, end:2014:2))"]
#[derive(Clone, Debug)]
struct bgtz_instructionVar1040 {
    mic_rs32_0: u8,
    Rel16_mic: TableRel16_mic,
}
impl bgtz_instructionVar1040 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgtz"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2020:1, end:2020:2))"]
#[derive(Clone, Debug)]
struct blez_instructionVar1041 {
    mic_rs32_0: u8,
    Rel16_mic: TableRel16_mic,
}
impl blez_instructionVar1041 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blez"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2026:1, end:2026:2))"]
#[derive(Clone, Debug)]
struct bltz_instructionVar1042 {
    mic_rs32_0: u8,
    Rel16_mic: TableRel16_mic,
}
impl bltz_instructionVar1042 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltz"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2032:1, end:2032:2))"]
#[derive(Clone, Debug)]
struct bltzal_instructionVar1043 {
    mic_rs32_0: u8,
    Rel16_mic: TableRel16_mic,
}
impl bltzal_instructionVar1043 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltzal"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2039:1, end:2039:2))"]
#[derive(Clone, Debug)]
struct bltzals_instructionVar1044 {
    mic_rs32_0: u8,
    Rel16_mic: TableRel16_mic,
}
impl bltzals_instructionVar1044 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltzals"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2058:1, end:2058:2))"]
#[derive(Clone, Debug)]
struct bnezc_instructionVar1045 {
    mic_rs32_0: u8,
    Rel16_mic: TableRel16_mic,
}
impl bnezc_instructionVar1045 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnezc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2537:1, end:2537:2))"]
#[derive(Clone, Debug)]
struct lwl_instructionVar1046 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl lwl_instructionVar1046 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_PAIR_INSTRUCTION_FLAG(
                u8::try_from(i128::try_from(context.read_PAIR_INSTRUCTION_FLAG()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("lwl"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_PAIR_INSTRUCTION_FLAG(u8::try_from(1i128 & 1).unwrap());
        let mic_base0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2539:1, end:2539:2))"]
#[derive(Clone, Debug)]
struct lwr_instructionVar1047 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl lwr_instructionVar1047 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_PAIR_INSTRUCTION_FLAG(u8::try_from(0i128 & 1).unwrap());
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2930:1, end:2930:2))"]
#[derive(Clone, Debug)]
struct swl_instructionVar1048 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl swl_instructionVar1048 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_PAIR_INSTRUCTION_FLAG(
                u8::try_from(i128::try_from(context.read_PAIR_INSTRUCTION_FLAG()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("swl"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_PAIR_INSTRUCTION_FLAG(u8::try_from(1i128 & 1).unwrap());
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2932:1, end:2932:2))"]
#[derive(Clone, Debug)]
struct swr_instructionVar1049 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl swr_instructionVar1049 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_PAIR_INSTRUCTION_FLAG(u8::try_from(0i128 & 1).unwrap());
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2284:1, end:2284:2))"]
#[derive(Clone, Debug)]
struct cache_instructionVar1050 {
    mic_cop5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl cache_instructionVar1050 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cache"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_cop5 as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_cop5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_cop5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2335:1, end:2335:2))"]
#[derive(Clone, Debug)]
struct jalr16_instructionVar1051 {
    mic_rs32_0: u8,
}
impl jalr16_instructionVar1051 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalr16"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2342:1, end:2342:2))"]
#[derive(Clone, Debug)]
struct jalrs16_instructionVar1052 {
    mic_rs32_0: u8,
}
impl jalrs16_instructionVar1052 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalrs16"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2388:1, end:2388:2))"]
#[derive(Clone, Debug)]
struct jr16_instructionVar1053 {
    mic_rs32_0: u8,
}
impl jr16_instructionVar1053 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jr16"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2400:1, end:2400:2))"]
#[derive(Clone, Debug)]
struct jraddiusp_instructionVar1054 {
    EXT_CODE5: TableEXT_CODE5,
}
impl jraddiusp_instructionVar1054 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jraddiusp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.EXT_CODE5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_CODE5 = if let Some((len, table)) =
            TableEXT_CODE5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_CODE5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2412:1, end:2412:2))"]
#[derive(Clone, Debug)]
struct jrc_instructionVar1055 {
    mic_rs32_0: u8,
}
impl jrc_instructionVar1055 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jrc"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2474:1, end:2474:2))"]
#[derive(Clone, Debug)]
struct lwl_instructionVar1056 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl lwl_instructionVar1056 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwl"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2498:1, end:2498:2))"]
#[derive(Clone, Debug)]
struct lwr_instructionVar1057 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl lwr_instructionVar1057 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2569:1, end:2569:2))"]
#[derive(Clone, Debug)]
struct madd_S_instructionVar1058 {
    micb_fd: u8,
    micb_fr: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl madd_S_instructionVar1058 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("madd.S"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fr = token_105(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                micb_fr,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2574:1, end:2574:2))"]
#[derive(Clone, Debug)]
struct madd_D_instructionVar1059 {
    micb_fd: u8,
    micb_fr: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl madd_D_instructionVar1059 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("madd.D"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_frD = token_105(tokens_current);
        let micb_fd = token_52(tokens_current);
        let micb_fr = token_105(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                micb_fr,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2578:1, end:2578:2))"]
#[derive(Clone, Debug)]
struct madd_PS_instructionVar1060 {
    micb_fd: u8,
    micb_fr: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl madd_PS_instructionVar1060 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("madd.PS"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        let micb_fr = token_105(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                micb_fr,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2597:1, end:2597:2))"]
#[derive(Clone, Debug)]
struct mfhi16_instructionVar1061 {
    mic_rd32_0: u8,
}
impl mfhi16_instructionVar1061 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfhi16"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rd32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rd32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rd32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2605:1, end:2605:2))"]
#[derive(Clone, Debug)]
struct mflo16_instructionVar1062 {
    mic_rd32_0: u8,
}
impl mflo16_instructionVar1062 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mflo16"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rd32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rd32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rd32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2723:1, end:2723:2))"]
#[derive(Clone, Debug)]
struct msub_S_instructionVar1063 {
    micb_fd: u8,
    micb_fr: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl msub_S_instructionVar1063 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msub.S"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fr = token_105(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                micb_fr,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2728:1, end:2728:2))"]
#[derive(Clone, Debug)]
struct msub_D_instructionVar1064 {
    micb_fd: u8,
    micb_fr: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl msub_D_instructionVar1064 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msub.D"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ftD_5 = token_69(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_frD = token_105(tokens_current);
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        let micb_fr = token_105(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                micb_fr,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2732:1, end:2732:2))"]
#[derive(Clone, Debug)]
struct msub_PS_instructionVar1065 {
    micb_fd: u8,
    micb_fr: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl msub_PS_instructionVar1065 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msub.PS"));
        let extend: [DisplayElement; 11usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        let micb_fr = token_105(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                micb_fr,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2864:1, end:2864:2))"]
#[derive(Clone, Debug)]
struct swl_instructionVar1066 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl swl_instructionVar1066 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swl"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2890:1, end:2890:2))"]
#[derive(Clone, Debug)]
struct swr_instructionVar1067 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl swr_instructionVar1067 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2955:1, end:2955:2))"]
#[derive(Clone, Debug)]
struct teqi_instructionVar1068 {
    mic_rs32_0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl teqi_instructionVar1068 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teqi"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2962:1, end:2962:2))"]
#[derive(Clone, Debug)]
struct tgei_instructionVar1069 {
    mic_rs32_0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl tgei_instructionVar1069 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tgei"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2969:1, end:2969:2))"]
#[derive(Clone, Debug)]
struct tgeiu_instructionVar1070 {
    mic_rs32_0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl tgeiu_instructionVar1070 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tgeiu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2976:1, end:2976:2))"]
#[derive(Clone, Debug)]
struct tlti_instructionVar1071 {
    mic_rs32_0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl tlti_instructionVar1071 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlti"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2983:1, end:2983:2))"]
#[derive(Clone, Debug)]
struct tltiu_instructionVar1072 {
    mic_rs32_0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl tltiu_instructionVar1072 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tltiu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2990:1, end:2990:2))"]
#[derive(Clone, Debug)]
struct tnei_instructionVar1073 {
    mic_rs32_0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl tnei_instructionVar1073 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tnei"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3030:1, end:3030:2))"]
#[derive(Clone, Debug)]
struct aluipc_instructionVar1074 {
    mic_rt32_5: u8,
    EXT_MS32: TableEXT_MS32,
}
impl aluipc_instructionVar1074 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("aluipc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS32 = if let Some((len, table)) =
            TableEXT_MS32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS32,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3042:1, end:3042:2))"]
#[derive(Clone, Debug)]
struct auipc_instructionVar1075 {
    mic_rt32_5: u8,
    EXT_MS32: TableEXT_MS32,
}
impl auipc_instructionVar1075 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("auipc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS32 = if let Some((len, table)) =
            TableEXT_MS32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS32,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3063:1, end:3063:2))"]
#[derive(Clone, Debug)]
struct bc1eqzc_instructionVar1076 {
    mic_ft_0: u8,
    Rel16_mic: TableRel16_mic,
}
impl bc1eqzc_instructionVar1076 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1eqzc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_ft_0 as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_ft_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3068:1, end:3068:2))"]
#[derive(Clone, Debug)]
struct bc1nezc_instructionVar1077 {
    mic_ft_0: u8,
    Rel16_mic: TableRel16_mic,
}
impl bc1nezc_instructionVar1077 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc1nezc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_ft_0 as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_ft_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3073:1, end:3073:2))"]
#[derive(Clone, Debug)]
struct bc2eqzc_instructionVar1078 {
    mic_ct: u8,
    Rel16_mic: TableRel16_mic,
}
impl bc2eqzc_instructionVar1078 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2eqzc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_ct as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ct = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16_mic, mic_ct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3079:1, end:3079:2))"]
#[derive(Clone, Debug)]
struct bc2nezc_instructionVar1079 {
    mic_ct: u8,
    Rel16_mic: TableRel16_mic,
}
impl bc2nezc_instructionVar1079 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc2nezc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_ct as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ct = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel16_mic, mic_ct }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3097:1, end:3097:2))"]
#[derive(Clone, Debug)]
struct blezalc_instructionVar1080 {
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl blezalc_instructionVar1080 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blezalc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3103:1, end:3103:2))"]
#[derive(Clone, Debug)]
struct bgezalc_instructionVar1081 {
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bgezalc_instructionVar1081 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgezalc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        if i128::try_from(token_69(tokens_current)).unwrap()
            != i128::try_from(token_53(tokens_current)).unwrap()
        {
            return None;
        }
        if token_69(tokens_current) == 0 {
            return None;
        }
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3114:1, end:3114:2))"]
#[derive(Clone, Debug)]
struct bgtzalc_instructionVar1082 {
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bgtzalc_instructionVar1082 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgtzalc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3120:1, end:3120:2))"]
#[derive(Clone, Debug)]
struct bltzalc_instructionVar1083 {
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bltzalc_instructionVar1083 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltzalc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        if i128::try_from(token_69(tokens_current)).unwrap()
            != i128::try_from(token_53(tokens_current)).unwrap()
        {
            return None;
        }
        if token_69(tokens_current) == 0 {
            return None;
        }
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3136:1, end:3136:2))"]
#[derive(Clone, Debug)]
struct beqc_instructionVar1084 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl beqc_instructionVar1084 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beqc"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        if token_53(tokens_current) == 0 {
            return None;
        }
        if i128::try_from(token_53(tokens_current)).unwrap()
            >= i128::try_from(token_69(tokens_current)).unwrap()
        {
            return None;
        }
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3158:1, end:3158:2))"]
#[derive(Clone, Debug)]
struct bnec_instructionVar1085 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bnec_instructionVar1085 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnec"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        if token_53(tokens_current) == 0 {
            return None;
        }
        if i128::try_from(token_53(tokens_current)).unwrap()
            >= i128::try_from(token_69(tokens_current)).unwrap()
        {
            return None;
        }
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3174:1, end:3174:2))"]
#[derive(Clone, Debug)]
struct blezc_instructionVar1086 {
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl blezc_instructionVar1086 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blezc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3178:1, end:3178:2))"]
#[derive(Clone, Debug)]
struct bgezc_instructionVar1087 {
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bgezc_instructionVar1087 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgezc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        if i128::try_from(token_69(tokens_current)).unwrap()
            != i128::try_from(token_53(tokens_current)).unwrap()
        {
            return None;
        }
        if token_69(tokens_current) == 0 {
            return None;
        }
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3187:1, end:3187:2))"]
#[derive(Clone, Debug)]
struct bgtzc_instructionVar1088 {
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bgtzc_instructionVar1088 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgtzc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3191:1, end:3191:2))"]
#[derive(Clone, Debug)]
struct bltzc_instructionVar1089 {
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bltzc_instructionVar1089 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltzc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        if i128::try_from(token_69(tokens_current)).unwrap()
            != i128::try_from(token_53(tokens_current)).unwrap()
        {
            return None;
        }
        if token_69(tokens_current) == 0 {
            return None;
        }
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3203:1, end:3203:2))"]
#[derive(Clone, Debug)]
struct bad6_instructionVar1090 {
    Rel21_mic: TableRel21_mic,
}
impl bad6_instructionVar1090 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bad6"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel21_mic = if let Some((len, table)) =
            TableRel21_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel21_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3522:1, end:3522:2))"]
#[derive(Clone, Debug)]
struct jalrc16_instructionVar1091 {
    mic_rs32_5: u8,
}
impl jalrc16_instructionVar1091 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jalrc16"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3528:1, end:3528:2))"]
#[derive(Clone, Debug)]
struct jialc_instructionVar1092 {
    mic_rt32_0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl jialc_instructionVar1092 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jialc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_rt32_0 as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rt32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3535:1, end:3535:2))"]
#[derive(Clone, Debug)]
struct jic_instructionVar1093 {
    mic_rt32_0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl jic_instructionVar1093 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jic"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_rt32_0 as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rt32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3541:1, end:3541:2))"]
#[derive(Clone, Debug)]
struct jrcaddiusp_instructionVar1094 {
    EXT_CODE5R6: TableEXT_CODE5R6,
}
impl jrcaddiusp_instructionVar1094 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jrcaddiusp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.EXT_CODE5R6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_CODE5R6 = if let Some((len, table)) =
            TableEXT_CODE5R6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_CODE5R6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3548:1, end:3548:2))"]
#[derive(Clone, Debug)]
struct jrc16_instructionVar1095 {
    mic_rs32_5: u8,
}
impl jrc16_instructionVar1095 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jrc16"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3581:1, end:3581:2))"]
#[derive(Clone, Debug)]
struct lwpc_instructionVar1096 {
    mic_rt32_5: u8,
    mic_imm02: u8,
    EXT_MS19: TableEXT_MS19,
}
impl lwpc_instructionVar1096 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwpc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS19
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_imm3(
            u8::try_from(i128::try_from(token_64(tokens_current)).unwrap() & 7).unwrap(),
        );
        let mic_rt32_5 = token_69(tokens_current);
        let mic_imm02 = token_64(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS19 = if let Some((len, table)) =
            TableEXT_MS19::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS19,
                mic_rt32_5,
                mic_imm02,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3589:1, end:3589:2))"]
#[derive(Clone, Debug)]
struct lwupc_instructionVar1097 {
    mic_rt32_5: u8,
    mic_imm02: u8,
    EXT_MS19: TableEXT_MS19,
}
impl lwupc_instructionVar1097 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwupc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS19
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_imm3(
            u8::try_from(i128::try_from(token_64(tokens_current)).unwrap() & 7).unwrap(),
        );
        let mic_imm02 = token_64(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS19 = if let Some((len, table)) =
            TableEXT_MS19::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS19,
                mic_rt32_5,
                mic_imm02,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:593:1, end:593:2))"]
#[derive(Clone, Debug)]
struct addiupc_instructionVar1098 {
    mic_imm7: u8,
    RST7R5: TableRST7R5,
    EXT_MSPC: TableEXT_MSPC,
}
impl addiupc_instructionVar1098 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiupc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RST7R5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MSPC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_addim(
            u8::try_from(i128::try_from(token_81(tokens_current)).unwrap() & 127).unwrap(),
        );
        let RST7R5 = if let Some((len, table)) =
            TableRST7R5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c94 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if context_param.read_REL6() == 0 {
                    return Some(((), (), 0));
                }
                let mut sub_pattern_c94 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    if token_65(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c94(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c94(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let mic_imm7 = token_81(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MSPC = if let Some((len, table)) =
            TableEXT_MSPC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RST7R5,
                EXT_MSPC,
                mic_imm7,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:599:1, end:599:2))"]
#[derive(Clone, Debug)]
struct addiur1sp_instructionVar1099 {
    mic_rd7: u8,
    EXT_MU6: TableEXT_MU6,
}
impl addiur1sp_instructionVar1099 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiur1sp"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rd7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MU6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_MU6 = if let Some((len, table)) =
            TableEXT_MU6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rd7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_MU6, mic_rd7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:608:1, end:608:2))"]
#[derive(Clone, Debug)]
struct addiur2_instructionVar1100 {
    mic_rd7: u8,
    RS4L: TableRS4L,
    EXT_CODE3: TableEXT_CODE3,
}
impl addiur2_instructionVar1100 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiur2"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rd7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS4L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS4L = if let Some((len, table)) =
            TableRS4L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_CODE3 = if let Some((len, table)) =
            TableEXT_CODE3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rd7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS4L,
                EXT_CODE3,
                mic_rd7,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:613:1, end:613:2))"]
#[derive(Clone, Debug)]
struct addiusp_instructionVar1101 {
    EXT_CODE9: TableEXT_CODE9,
}
impl addiusp_instructionVar1101 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiusp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.EXT_CODE9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_CODE9 = if let Some((len, table)) =
            TableEXT_CODE9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_CODE9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:622:1, end:622:2))"]
#[derive(Clone, Debug)]
struct addius5_instructionVar1102 {
    mic_imm4s: u8,
    RD5L: TableRD5L,
}
impl addius5_instructionVar1102 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addius5"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.mic_imm4s & 8 != 0 { -1 & !7 } else { 0 } | self.mic_imm4s as i8)
                    .is_negative(),
                (if self.mic_imm4s & 8 != 0 { -1 & !7 } else { 0 } | self.mic_imm4s as i8).abs()
                    as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RD5L = if let Some((len, table)) =
            TableRD5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rd32_5 = token_69(tokens_current);
        let mic_imm4s = token_84(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD5L, mic_imm4s }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:628:1, end:628:2))"]
#[derive(Clone, Debug)]
struct addu_instructionVar1103 {
    micb_rd32: u8,
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl addu_instructionVar1103 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                RS0L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:633:1, end:633:2))"]
#[derive(Clone, Debug)]
struct addu16_instructionVar1104 {
    RD7R1: TableRD7R1,
    RT4L: TableRT4L,
    RS1R7L: TableRS1R7L,
}
impl addu16_instructionVar1104 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addu16"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD7R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT4L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS1R7L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RD7R1 = if let Some((len, table)) =
            TableRD7R1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT4L = if let Some((len, table)) =
            TableRT4L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1R7L = if let Some((len, table)) =
            TableRS1R7L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD7R1,
                RT4L,
                RS1R7L,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:638:1, end:638:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar1105 {
    micb_rd32: u8,
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl and_instructionVar1105 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_rd32,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:642:1, end:642:2))"]
#[derive(Clone, Debug)]
struct and16_instructionVar1106 {
    RS0R4: TableRS0R4,
    RT3R7: TableRT3R7,
}
impl and16_instructionVar1106 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and16"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT3R7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0R4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT3R7 = if let Some((len, table)) =
            TableRT3R7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS0R4 = if let Some((len, table)) =
            TableRS0R4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c86 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c87 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_73(tokens) != 2 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c87(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c87 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_62(tokens) != 1 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c87(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c86(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS0R4, RT3R7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:808:1, end:808:2))"]
#[derive(Clone, Debug)]
struct div_S_instructionVar1107 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl div_S_instructionVar1107 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("div.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:815:1, end:815:2))"]
#[derive(Clone, Debug)]
struct div_D_instructionVar1108 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl div_D_instructionVar1108 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("div.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_fs = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1151:1, end:1151:2))"]
#[derive(Clone, Debug)]
struct mul_S_instructionVar1109 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl mul_S_instructionVar1109 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1156:1, end:1156:2))"]
#[derive(Clone, Debug)]
struct mul_D_instructionVar1110 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl mul_D_instructionVar1110 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_fsD = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1174:1, end:1174:2))"]
#[derive(Clone, Debug)]
struct nor_instructionVar1111 {
    micb_rd32: u8,
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl nor_instructionVar1111 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nor"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_rd32,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1182:1, end:1182:2))"]
#[derive(Clone, Debug)]
struct or_instructionVar1112 {
    micb_rd32: u8,
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl or_instructionVar1112 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_rd32,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1224:1, end:1224:2))"]
#[derive(Clone, Debug)]
struct rotr_instructionVar1113 {
    mic_rt32_5: u8,
    micb_sa: u8,
    RS0L: TableRS0L,
}
impl rotr_instructionVar1113 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rotr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_sa as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_sa = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                mic_rt32_5,
                micb_sa,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1231:1, end:1231:2))"]
#[derive(Clone, Debug)]
struct rotrv_instructionVar1114 {
    micb_rd32: u8,
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl rotrv_instructionVar1114 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rotrv"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                RS0L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1368:1, end:1368:2))"]
#[derive(Clone, Debug)]
struct sll_instructionVar1115 {
    mic_rt32_5: u8,
    micb_sa: u8,
    RS0L: TableRS0L,
}
impl sll_instructionVar1115 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sll"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_sa as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_sa = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                mic_rt32_5,
                micb_sa,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1372:1, end:1372:2))"]
#[derive(Clone, Debug)]
struct sllv_instructionVar1116 {
    micb_rd32: u8,
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl sllv_instructionVar1116 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sllv"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                RS0L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1381:1, end:1381:2))"]
#[derive(Clone, Debug)]
struct slt_instructionVar1117 {
    micb_rd32: u8,
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl slt_instructionVar1117 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slt"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_rd32,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1398:1, end:1398:2))"]
#[derive(Clone, Debug)]
struct sltu_instructionVar1118 {
    micb_rd32: u8,
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl sltu_instructionVar1118 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sltu"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_rd32,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1412:1, end:1412:2))"]
#[derive(Clone, Debug)]
struct sra_instructionVar1119 {
    mic_rt32_5: u8,
    micb_sa: u8,
    RS0L: TableRS0L,
}
impl sra_instructionVar1119 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sra"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_sa as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_sa = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                mic_rt32_5,
                micb_sa,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1416:1, end:1416:2))"]
#[derive(Clone, Debug)]
struct srav_instructionVar1120 {
    micb_rd32: u8,
    RS0L: TableRS0L,
    RT5L: TableRT5L,
}
impl srav_instructionVar1120 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srav"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                RT5L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1421:1, end:1421:2))"]
#[derive(Clone, Debug)]
struct srl_instructionVar1121 {
    mic_rt32_5: u8,
    micb_sa: u8,
    RS0L: TableRS0L,
}
impl srl_instructionVar1121 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srl"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_sa as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_sa = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                mic_rt32_5,
                micb_sa,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1425:1, end:1425:2))"]
#[derive(Clone, Debug)]
struct srlv_instructionVar1122 {
    micb_rd32: u8,
    RS0L: TableRS0L,
    RT5L: TableRT5L,
}
impl srlv_instructionVar1122 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srlv"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                RT5L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1436:1, end:1436:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar1123 {
    micb_rd32: u8,
    RS0L: TableRS0L,
    RT5L: TableRT5L,
}
impl sub_instructionVar1123 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                RT5L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1446:1, end:1446:2))"]
#[derive(Clone, Debug)]
struct sub_S_instructionVar1124 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl sub_S_instructionVar1124 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub.S"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1451:1, end:1451:2))"]
#[derive(Clone, Debug)]
struct sub_D_instructionVar1125 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl sub_D_instructionVar1125 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub.D"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fd = token_52(tokens_current);
        let micb_fdD = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1455:1, end:1455:2))"]
#[derive(Clone, Debug)]
struct subu_instructionVar1126 {
    micb_rd32: u8,
    RT5L: TableRT5L,
    RS0L: TableRS0L,
}
impl subu_instructionVar1126 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                RS0L,
                micb_rd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1639:1, end:1639:2))"]
#[derive(Clone, Debug)]
struct xor_instructionVar1127 {
    micb_rd32: u8,
    mic_rs32_0: u8,
    mic_rt32_5: u8,
}
impl xor_instructionVar1127 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xor"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.micb_rd32),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_rd32,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2804:1, end:2804:2))"]
#[derive(Clone, Debug)]
struct sub_PS_instructionVar1128 {
    micb_fd: u8,
    mic_fs: u8,
    mic_ft_5: u8,
}
impl sub_PS_instructionVar1128 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub.PS"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.micb_fd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_fs),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        let mic_fsD = token_53(tokens_current);
        let mic_fs = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_fdD = token_52(tokens_current);
        let micb_fd = token_52(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_fd,
                mic_fs,
                mic_ft_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:655:1, end:655:2))"]
#[derive(Clone, Debug)]
struct break_instructionVar1129 {}
impl break_instructionVar1129 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("break"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:831:1, end:831:2))"]
#[derive(Clone, Debug)]
struct ext_instructionVar1130 {
    mic_rt32_5: u8,
    micb_pos: u8,
    RS0L: TableRS0L,
    SIZEP: TableSIZEP,
}
impl ext_instructionVar1130 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ext"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_pos as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SIZEP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let SIZEP = if let Some((len, table)) =
            TableSIZEP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let micb_pos = token_105(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                SIZEP,
                mic_rt32_5,
                micb_pos,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:862:1, end:862:2))"]
#[derive(Clone, Debug)]
struct ins_instructionVar1131 {
    micb_pos: u8,
    RT5L: TableRT5L,
    RS0L: TableRS0L,
    SIZEQ: TableSIZEQ,
}
impl ins_instructionVar1131 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ins"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_pos as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SIZEQ
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let SIZEQ = if let Some((len, table)) =
            TableSIZEQ::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let micb_pos = token_105(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                RS0L,
                SIZEQ,
                micb_pos,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:707:1, end:707:2))"]
#[derive(Clone, Debug)]
struct cop2_instructionVar1132 {
    mic_code: u16,
    EXT_MU23: TableEXT_MU23,
}
impl cop2_instructionVar1132 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cop2"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.EXT_MU23
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_code(
            u16::try_from(i128::try_from(token_72(tokens_current)).unwrap() & 1023).unwrap(),
        );
        let mic_code = token_72(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MU23 = if let Some((len, table)) =
            TableEXT_MU23::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_MU23, mic_code }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1495:1, end:1495:2))"]
#[derive(Clone, Debug)]
struct swc2_instructionVar1133 {
    mic_rt32_5: u8,
    micb_offset11s: u16,
    mic_base0: u8,
}
impl swc2_instructionVar1133 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swc2"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.micb_offset11s & 1024 != 0 {
                    -1 & !1023
                } else {
                    0
                } | self.micb_offset11s as i16)
                    .is_negative(),
                (if self.micb_offset11s & 1024 != 0 {
                    -1 & !1023
                } else {
                    0
                } | self.micb_offset11s as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_offset11s = token_67(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                micb_offset11s,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:921:1, end:921:2))"]
#[derive(Clone, Debug)]
struct ldc2_instructionVar1134 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl ldc2_instructionVar1134 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldc2"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:991:1, end:991:2))"]
#[derive(Clone, Debug)]
struct lui_instructionVar1135 {
    micb_imm16: u16,
    RS0RT5: TableRS0RT5,
}
impl lui_instructionVar1135 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lui"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS0RT5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_imm16 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0RT5 = if let Some((len, table)) =
            TableRS0RT5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c64 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c65 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_71(tokens) != 16 {
                        return None;
                    }
                    if token_69(tokens) != 13 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c65(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c65 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_71(tokens) != 4 {
                        return None;
                    }
                    if token_53(tokens) != 0 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c65(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c64(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_imm16 = token_68(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS0RT5, micb_imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1021:1, end:1021:2))"]
#[derive(Clone, Debug)]
struct lwm16_instructionVar1136 {
    LOAD_TOP16: TableLOAD_TOP16,
}
impl lwm16_instructionVar1136 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwm16"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.LOAD_TOP16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LOAD_TOP16 = if let Some((len, table)) =
            TableLOAD_TOP16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c81 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c82 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_73(tokens) != 4 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c82(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c82 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_62(tokens) != 2 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c82(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c81(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LOAD_TOP16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1025:1, end:1025:2))"]
#[derive(Clone, Debug)]
struct lwm32_instructionVar1137 {
    mic_base0: u8,
    mic_rlist: u8,
    LOAD_TOP: TableLOAD_TOP,
}
impl lwm32_instructionVar1137 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwm32"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.LOAD_TOP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_basea(
            u8::try_from(i128::try_from(token_53(tokens_current)).unwrap() & 31).unwrap(),
        );
        context_instance.write_ext_32_rlist(
            u8::try_from(i128::try_from(token_69(tokens_current)).unwrap() & 31).unwrap(),
        );
        let mic_rlist = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let LOAD_TOP = if let Some((len, table)) =
            TableLOAD_TOP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                LOAD_TOP,
                mic_base0,
                mic_rlist,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1037:1, end:1037:2))"]
#[derive(Clone, Debug)]
struct lwc2_instructionVar1138 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl lwc2_instructionVar1138 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwc2"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1045:1, end:1045:2))"]
#[derive(Clone, Debug)]
struct lwp_instructionVar1139 {
    mic_rd32_5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl lwp_instructionVar1139 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwp"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rd32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_rdset(
            u8::try_from(
                i128::try_from(token_69(tokens_current))
                    .unwrap()
                    .wrapping_add(1i128)
                    & 31,
            )
            .unwrap(),
        );
        let mic_base0 = token_53(tokens_current);
        let mic_rd32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_rd32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1117:1, end:1117:2))"]
#[derive(Clone, Debug)]
struct movep_instructionVar1140 {
    mic_encrd: u8,
    mic_encre: u8,
    mic_encrt: u8,
    mic_bit3: u8,
    mic_bit01: u8,
    ENCRS: TableENCRS,
}
impl movep_instructionVar1140 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movep"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_31_display(self.mic_encrd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_32_display(self.mic_encre),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.ENCRS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_29_display(self.mic_encrt),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_16_rshi(
            u8::try_from(i128::try_from(token_86(tokens_current)).unwrap() & 1).unwrap(),
        );
        context_instance.write_ext_16_rslo(
            u8::try_from(i128::try_from(token_60(tokens_current)).unwrap() & 3).unwrap(),
        );
        let ENCRS = if let Some((len, table)) =
            TableENCRS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_encre = token_76(tokens_current);
        let mic_bit3 = token_86(tokens_current);
        let mic_encrt = token_75(tokens_current);
        let mic_bit01 = token_60(tokens_current);
        let mic_encrd = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ENCRS,
                mic_encrd,
                mic_encre,
                mic_encrt,
                mic_bit3,
                mic_bit01,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1178:1, end:1178:2))"]
#[derive(Clone, Debug)]
struct not16_instructionVar1141 {
    RS0R4: TableRS0R4,
    RT3R7: TableRT3R7,
}
impl not16_instructionVar1141 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("not16"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT3R7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0R4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT3R7 = if let Some((len, table)) =
            TableRT3R7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS0R4 = if let Some((len, table)) =
            TableRS0R4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c86 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c87 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_73(tokens) != 0 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c87(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c87 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_62(tokens) != 0 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c87(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c86(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS0R4, RT3R7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1191:1, end:1191:2))"]
#[derive(Clone, Debug)]
struct or16_instructionVar1142 {
    RS0R4: TableRS0R4,
    RT3R7: TableRT3R7,
}
impl or16_instructionVar1142 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or16"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT3R7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0R4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT3R7 = if let Some((len, table)) =
            TableRT3R7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS0R4 = if let Some((len, table)) =
            TableRS0R4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c85 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c86 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_73(tokens) != 3 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c86(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c86 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_62(tokens) != 9 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c86(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c85(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS0R4, RT3R7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1328:1, end:1328:2))"]
#[derive(Clone, Debug)]
struct sdc2_instructionVar1143 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_CODE12: TableEXT_CODE12,
}
impl sdc2_instructionVar1143 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdc2"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE12,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1377:1, end:1377:2))"]
#[derive(Clone, Debug)]
struct sll16_instructionVar1144 {
    mic_rd7: u8,
    EXT_SA: TableEXT_SA,
    RT4L: TableRT4L,
}
impl sll16_instructionVar1144 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sll16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rd7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT4L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_SA
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT4L = if let Some((len, table)) =
            TableRT4L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_SA = if let Some((len, table)) =
            TableEXT_SA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rd7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_SA,
                RT4L,
                mic_rd7,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1430:1, end:1430:2))"]
#[derive(Clone, Debug)]
struct srl16_instructionVar1145 {
    mic_rd7: u8,
    RT4L: TableRT4L,
    EXT_SA: TableEXT_SA,
}
impl srl16_instructionVar1145 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srl16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rd7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT4L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_SA
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT4L = if let Some((len, table)) =
            TableRT4L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_SA = if let Some((len, table)) =
            TableEXT_SA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rd7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT4L,
                EXT_SA,
                mic_rd7,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1459:1, end:1459:2))"]
#[derive(Clone, Debug)]
struct subu16_instructionVar1146 {
    RS1R7L: TableRS1R7L,
    RD7R1: TableRD7R1,
    RT4L: TableRT4L,
}
impl subu16_instructionVar1146 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subu16"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD7R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS1R7L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT4L
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RD7R1 = if let Some((len, table)) =
            TableRD7R1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT4L = if let Some((len, table)) =
            TableRT4L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1R7L = if let Some((len, table)) =
            TableRS1R7L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS1R7L,
                RD7R1,
                RT4L,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1511:1, end:1511:2))"]
#[derive(Clone, Debug)]
struct swp_instructionVar1147 {
    mic_base0: u8,
    mic_rs32_5: u8,
    RSEXTL: TableRSEXTL,
    RT5L: TableRT5L,
    EXT_CODE12: TableEXT_CODE12,
}
impl swp_instructionVar1147 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_rs1set(
            u8::try_from(
                i128::try_from(token_69(tokens_current))
                    .unwrap()
                    .wrapping_add(1i128)
                    & 31,
            )
            .unwrap(),
        );
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RSEXTL = if let Some((len, table)) =
            TableRSEXTL::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_base0 = token_53(tokens_current);
        let mic_rs32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RSEXTL,
                RT5L,
                EXT_CODE12,
                mic_base0,
                mic_rs32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1522:1, end:1522:2))"]
#[derive(Clone, Debug)]
struct swm16_instructionVar1148 {
    STORE_TOP16: TableSTORE_TOP16,
}
impl swm16_instructionVar1148 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swm16"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.STORE_TOP16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let STORE_TOP16 = if let Some((len, table)) =
            TableSTORE_TOP16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c83 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c84 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_73(tokens) != 5 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c84(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c84 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_62(tokens) != 10 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c84(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c83(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STORE_TOP16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1526:1, end:1526:2))"]
#[derive(Clone, Debug)]
struct swm32_instructionVar1149 {
    mic_base0: u8,
    mic_rlist: u8,
    STORE_TOP: TableSTORE_TOP,
}
impl swm32_instructionVar1149 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swm32"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.STORE_TOP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_basea(
            u8::try_from(i128::try_from(token_53(tokens_current)).unwrap() & 31).unwrap(),
        );
        context_instance.write_ext_32_rlist(
            u8::try_from(i128::try_from(token_69(tokens_current)).unwrap() & 31).unwrap(),
        );
        let mic_base0 = token_53(tokens_current);
        let mic_rlist = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let STORE_TOP = if let Some((len, table)) =
            TableSTORE_TOP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                STORE_TOP,
                mic_base0,
                mic_rlist,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1648:1, end:1648:2))"]
#[derive(Clone, Debug)]
struct xor16_instructionVar1150 {
    RT3R7: TableRT3R7,
    RS0R4: TableRS0R4,
}
impl xor16_instructionVar1150 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xor16"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT3R7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0R4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT3R7 = if let Some((len, table)) =
            TableRT3R7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS0R4 = if let Some((len, table)) =
            TableRS0R4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c86 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c87 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_73(tokens) != 1 {
                        return None;
                    }
                    if context_instance.read_REL6() != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c87(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c87 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 2;
                    if token_62(tokens) != 8 {
                        return None;
                    }
                    if context_instance.read_REL6() != 1 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c87(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c86(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT3R7, RS0R4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1922:1, end:1922:2))"]
#[derive(Clone, Debug)]
struct addi_instructionVar1151 {
    mic_rt32_5: u8,
    RS0L: TableRS0L,
    EXT_MS16: TableEXT_MS16,
}
impl addi_instructionVar1151 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addi"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                EXT_MS16,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1937:1, end:1937:2))"]
#[derive(Clone, Debug)]
struct b16_instructionVar1152 {
    Rel10_mic: TableRel10_mic,
}
impl b16_instructionVar1152 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b16"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel10_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rel10_mic = if let Some((len, table)) =
            TableRel10_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel10_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1978:1, end:1978:2))"]
#[derive(Clone, Debug)]
struct beq_instructionVar1153 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl beq_instructionVar1153 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beq"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1984:1, end:1984:2))"]
#[derive(Clone, Debug)]
struct beqz16_instructionVar1154 {
    mic_rs7: u8,
    Rel7_mic: TableRel7_mic,
}
impl beqz16_instructionVar1154 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beqz16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rs7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel7_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rel7_mic = if let Some((len, table)) =
            TableRel7_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rs7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel7_mic, mic_rs7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2046:1, end:2046:2))"]
#[derive(Clone, Debug)]
struct bne_instructionVar1155 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bne_instructionVar1155 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bne"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2052:1, end:2052:2))"]
#[derive(Clone, Debug)]
struct bnez16_instructionVar1156 {
    mic_rs7: u8,
    Rel7_mic: TableRel7_mic,
}
impl bnez16_instructionVar1156 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnez16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rs7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel7_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rel7_mic = if let Some((len, table)) =
            TableRel7_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rs7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel7_mic, mic_rs7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2310:1, end:2310:2))"]
#[derive(Clone, Debug)]
struct j_instructionVar1157 {
    mic_code: u16,
    Abs26_mic1: TableAbs26_mic1,
}
impl j_instructionVar1157 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("j"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Abs26_mic1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_code(
            u16::try_from(i128::try_from(token_72(tokens_current)).unwrap() & 1023).unwrap(),
        );
        let mic_code = token_72(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Abs26_mic1 = if let Some((len, table)) =
            TableAbs26_mic1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Abs26_mic1,
                mic_code,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2315:1, end:2315:2))"]
#[derive(Clone, Debug)]
struct jal_instructionVar1158 {
    mic_code: u16,
    Abs26_mic1: TableAbs26_mic1,
}
impl jal_instructionVar1158 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jal"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Abs26_mic1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_code(
            u16::try_from(i128::try_from(token_72(tokens_current)).unwrap() & 1023).unwrap(),
        );
        let mic_code = token_72(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Abs26_mic1 = if let Some((len, table)) =
            TableAbs26_mic1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Abs26_mic1,
                mic_code,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2363:1, end:2363:2))"]
#[derive(Clone, Debug)]
struct jals_instructionVar1159 {
    mic_code: u16,
    Abs26_mic1: TableAbs26_mic1,
}
impl jals_instructionVar1159 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jals"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Abs26_mic1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_code(
            u16::try_from(i128::try_from(token_72(tokens_current)).unwrap() & 1023).unwrap(),
        );
        let mic_code = token_72(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Abs26_mic1 = if let Some((len, table)) =
            TableAbs26_mic1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Abs26_mic1,
                mic_code,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:2369:1, end:2369:2))"]
#[derive(Clone, Debug)]
struct jalx_instructionVar1160 {
    mic_code: u16,
    Abs26_mic2: TableAbs26_mic2,
}
impl jalx_instructionVar1160 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(None, |context| {
            context.write_ISA_MODE(
                u8::try_from(i128::try_from(context.read_ISA_MODE()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("jalx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Abs26_mic2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_code(
            u16::try_from(i128::try_from(token_72(tokens_current)).unwrap() & 1023).unwrap(),
        );
        context_instance.write_ISA_MODE(u8::try_from(0i128 & 1).unwrap());
        let mic_code = token_72(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Abs26_mic2 = if let Some((len, table)) =
            TableAbs26_mic2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Abs26_mic2,
                mic_code,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3037:1, end:3037:2))"]
#[derive(Clone, Debug)]
struct aui_instructionVar1161 {
    mic_rt32_5: u8,
    RS0L: TableRS0L,
    EXT_MS32: TableEXT_MS32,
}
impl aui_instructionVar1161 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("aui"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS32 = if let Some((len, table)) =
            TableEXT_MS32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                EXT_MS32,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3050:1, end:3050:2))"]
#[derive(Clone, Debug)]
struct balc_instructionVar1162 {
    Rel26_mic: TableRel26_mic,
}
impl balc_instructionVar1162 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("balc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel26_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel26_mic = if let Some((len, table)) =
            TableRel26_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel26_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3055:1, end:3055:2))"]
#[derive(Clone, Debug)]
struct bc_instructionVar1163 {
    Rel26_mic: TableRel26_mic,
}
impl bc_instructionVar1163 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel26_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel26_mic = if let Some((len, table)) =
            TableRel26_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel26_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3059:1, end:3059:2))"]
#[derive(Clone, Debug)]
struct bc16_instructionVar1164 {
    Rel10_mic: TableRel10_mic,
}
impl bc16_instructionVar1164 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bc16"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rel10_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rel10_mic = if let Some((len, table)) =
            TableRel10_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel10_mic }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3085:1, end:3085:2))"]
#[derive(Clone, Debug)]
struct beqzc16_instructionVar1165 {
    mic_rs7: u8,
    Rel7_mic: TableRel7_mic,
}
impl beqzc16_instructionVar1165 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beqzc16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rs7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel7_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rel7_mic = if let Some((len, table)) =
            TableRel7_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rs7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel7_mic, mic_rs7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3089:1, end:3089:2))"]
#[derive(Clone, Debug)]
struct bnezc16_instructionVar1166 {
    mic_rs7: u8,
    Rel7_mic: TableRel7_mic,
}
impl bnezc16_instructionVar1166 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnezc16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rs7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel7_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rel7_mic = if let Some((len, table)) =
            TableRel7_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rs7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rel7_mic, mic_rs7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3109:1, end:3109:2))"]
#[derive(Clone, Debug)]
struct bgeuc_instructionVar1167 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bgeuc_instructionVar1167 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgeuc"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3125:1, end:3125:2))"]
#[derive(Clone, Debug)]
struct bltuc_instructionVar1168 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bltuc_instructionVar1168 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltuc"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3140:1, end:3140:2))"]
#[derive(Clone, Debug)]
struct bovc_instructionVar1169 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    RT5L: TableRT5L,
    RS0L: TableRS0L,
    Rel16_mic: TableRel16_mic,
}
impl bovc_instructionVar1169 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bovc"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                RS0L,
                Rel16_mic,
                mic_rt32_5,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3162:1, end:3162:2))"]
#[derive(Clone, Debug)]
struct bnvc_instructionVar1170 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    RS0L: TableRS0L,
    RT5L: TableRT5L,
    Rel16_mic: TableRel16_mic,
}
impl bnvc_instructionVar1170 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnvc"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                RT5L,
                Rel16_mic,
                mic_rt32_5,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3182:1, end:3182:2))"]
#[derive(Clone, Debug)]
struct bgec_instructionVar1171 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bgec_instructionVar1171 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bgec"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3195:1, end:3195:2))"]
#[derive(Clone, Debug)]
struct bltc_instructionVar1172 {
    mic_rs32_0: u8,
    mic_rt32_5: u8,
    Rel16_mic: TableRel16_mic,
}
impl bltc_instructionVar1172 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bltc"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Rel16_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel16_mic = if let Some((len, table)) =
            TableRel16_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel16_mic,
                mic_rs32_0,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3199:1, end:3199:2))"]
#[derive(Clone, Debug)]
struct beqzc_instructionVar1173 {
    mic_rs32_5: u8,
    mic_imm5: u8,
    Rel21_mic: TableRel21_mic,
}
impl beqzc_instructionVar1173 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("beqzc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel21_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_imm5(
            u8::try_from(i128::try_from(token_53(tokens_current)).unwrap() & 31).unwrap(),
        );
        let mic_rs32_5 = token_69(tokens_current);
        let mic_imm5 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel21_mic = if let Some((len, table)) =
            TableRel21_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel21_mic,
                mic_rs32_5,
                mic_imm5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:3204:1, end:3204:2))"]
#[derive(Clone, Debug)]
struct bnezc_instructionVar1174 {
    mic_rs32_5: u8,
    mic_imm5: u8,
    Rel21_mic: TableRel21_mic,
}
impl bnezc_instructionVar1174 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bnezc"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Rel21_mic
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_32_imm5(
            u8::try_from(i128::try_from(token_53(tokens_current)).unwrap() & 31).unwrap(),
        );
        let mic_rs32_5 = token_69(tokens_current);
        let mic_imm5 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rel21_mic = if let Some((len, table)) =
            TableRel21_mic::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rel21_mic,
                mic_rs32_5,
                mic_imm5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:587:1, end:587:2))"]
#[derive(Clone, Debug)]
struct addiu_instructionVar1175 {
    mic_rt32_5: u8,
    RS0L: TableRS0L,
    EXT_MS16: TableEXT_MS16,
}
impl addiu_instructionVar1175 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addiu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RS0L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RS0L = if let Some((len, table)) =
            TableRS0L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS0L,
                EXT_MS16,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:646:1, end:646:2))"]
#[derive(Clone, Debug)]
struct andi_instructionVar1176 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    micb_imm16: u16,
}
impl andi_instructionVar1176 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andi"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_imm16 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_imm16 = token_68(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_rs32_0,
                micb_imm16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:651:1, end:651:2))"]
#[derive(Clone, Debug)]
struct andi16_instructionVar1177 {
    mic_rd7: u8,
    mic_rs4: u8,
    EXT_CODE4A: TableEXT_CODE4A,
}
impl andi16_instructionVar1177 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andi16"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rd7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rs4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE4A
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_CODE4A = if let Some((len, table)) =
            TableEXT_CODE4A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rd7 = token_76(tokens_current);
        let mic_rs4 = token_75(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE4A,
                mic_rd7,
                mic_rs4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:873:1, end:873:2))"]
#[derive(Clone, Debug)]
struct lb_instructionVar1178 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl lb_instructionVar1178 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lb"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:889:1, end:889:2))"]
#[derive(Clone, Debug)]
struct lbu_instructionVar1179 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl lbu_instructionVar1179 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:905:1, end:905:2))"]
#[derive(Clone, Debug)]
struct lbu16_instructionVar1180 {
    mic_rt7: u8,
    mic_base4: u8,
    EXT_CODE4B: TableEXT_CODE4B,
}
impl lbu16_instructionVar1180 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbu16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rt7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE4B
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_25_display(self.mic_base4),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_CODE4B = if let Some((len, table)) =
            TableEXT_CODE4B::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt7 = token_76(tokens_current);
        let mic_base4 = token_75(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE4B,
                mic_rt7,
                mic_base4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:913:1, end:913:2))"]
#[derive(Clone, Debug)]
struct ldc1_instructionVar1181 {
    mic_ft_5: u8,
    mic_base0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl ldc1_instructionVar1181 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_ft_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:929:1, end:929:2))"]
#[derive(Clone, Debug)]
struct lh_instructionVar1182 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl lh_instructionVar1182 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lh"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:945:1, end:945:2))"]
#[derive(Clone, Debug)]
struct lhu_instructionVar1183 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl lhu_instructionVar1183 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhu"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:961:1, end:961:2))"]
#[derive(Clone, Debug)]
struct lhu16_instructionVar1184 {
    mic_rt7: u8,
    mic_base4: u8,
    EXT_CODE4C: TableEXT_CODE4C,
}
impl lhu16_instructionVar1184 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhu16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rt7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE4C
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_25_display(self.mic_base4),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_CODE4C = if let Some((len, table)) =
            TableEXT_CODE4C::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt7 = token_76(tokens_current);
        let mic_base4 = token_75(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE4C,
                mic_rt7,
                mic_base4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:969:1, end:969:2))"]
#[derive(Clone, Debug)]
struct li16_instructionVar1185 {
    mic_rd7: u8,
    EXT_CODE7: TableEXT_CODE7,
}
impl li16_instructionVar1185 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("li16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rd7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_CODE7 = if let Some((len, table)) =
            TableEXT_CODE7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rd7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_CODE7, mic_rd7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:997:1, end:997:2))"]
#[derive(Clone, Debug)]
struct lw_instructionVar1186 {
    mic_rt32_5: u8,
    mic_base0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl lw_instructionVar1186 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lw"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rt32_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1013:1, end:1013:2))"]
#[derive(Clone, Debug)]
struct lw16_instructionVar1187 {
    mic_rt7: u8,
    mic_base4: u8,
    EXT_CODE4D: TableEXT_CODE4D,
}
impl lw16_instructionVar1187 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lw16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rt7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE4D
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_25_display(self.mic_base4),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_CODE4D = if let Some((len, table)) =
            TableEXT_CODE4D::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt7 = token_76(tokens_current);
        let mic_base4 = token_75(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE4D,
                mic_rt7,
                mic_base4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1029:1, end:1029:2))"]
#[derive(Clone, Debug)]
struct lwc1_instructionVar1188 {
    mic_ft_5: u8,
    mic_base0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl lwc1_instructionVar1188 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base0 = token_53(tokens_current);
        let mic_ft_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_ft_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1056:1, end:1056:2))"]
#[derive(Clone, Debug)]
struct lwgp_instructionVar1189 {
    mic_rt7: u8,
    EXT_CODE7A: TableEXT_CODE7A,
}
impl lwgp_instructionVar1189 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwgp"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_25_display(self.mic_rt7),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE7A
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            <DisplayElement>::Register(Register::gp),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_CODE7A = if let Some((len, table)) =
            TableEXT_CODE7A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE7A,
                mic_rt7,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1064:1, end:1064:2))"]
#[derive(Clone, Debug)]
struct lwsp_instructionVar1190 {
    mic_rt32_5: u8,
    EXT_CODE5: TableEXT_CODE5,
}
impl lwsp_instructionVar1190 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwsp"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_CODE5 = if let Some((len, table)) =
            TableEXT_CODE5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE5,
                mic_rt32_5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1112:1, end:1112:2))"]
#[derive(Clone, Debug)]
struct move16_instructionVar1191 {
    mic_rd32_5: u8,
    mic_rs32_0: u8,
}
impl move16_instructionVar1191 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move16"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rd32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rd32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rd32_5,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1186:1, end:1186:2))"]
#[derive(Clone, Debug)]
struct ori_instructionVar1192 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    micb_imm16: u16,
}
impl ori_instructionVar1192 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ori"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_imm16 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_imm16 = token_68(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_rs32_0,
                micb_imm16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1269:1, end:1269:2))"]
#[derive(Clone, Debug)]
struct sb_instructionVar1193 {
    mic_base0: u8,
    RT5L: TableRT5L,
    EXT_MS16: TableEXT_MS16,
}
impl sb_instructionVar1193 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                EXT_MS16,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1285:1, end:1285:2))"]
#[derive(Clone, Debug)]
struct sb16_instructionVar1194 {
    mic_encrt2: u8,
    mic_off4: u8,
    mic_base4: u8,
}
impl sb16_instructionVar1194 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sb16"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_30_display(self.mic_encrt2),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.mic_off4 as u64),
            <DisplayElement>::Literal("("),
            meaning_25_display(self.mic_base4),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_base4 = token_75(tokens_current);
        let mic_off4 = token_62(tokens_current);
        let mic_encrt2 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_encrt2,
                mic_off4,
                mic_base4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1320:1, end:1320:2))"]
#[derive(Clone, Debug)]
struct sdc1_instructionVar1195 {
    mic_ft_5: u8,
    mic_base0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl sdc1_instructionVar1195 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        let mic_ftD_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_ft_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1344:1, end:1344:2))"]
#[derive(Clone, Debug)]
struct sh_instructionVar1196 {
    mic_base0: u8,
    RT5L: TableRT5L,
    EXT_MS16: TableEXT_MS16,
}
impl sh_instructionVar1196 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                EXT_MS16,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1360:1, end:1360:2))"]
#[derive(Clone, Debug)]
struct sh16_instructionVar1197 {
    mic_encrt2: u8,
    mic_base4: u8,
    EXT_CODE4C: TableEXT_CODE4C,
}
impl sh16_instructionVar1197 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sh16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_30_display(self.mic_encrt2),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE4C
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_25_display(self.mic_base4),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_CODE4C = if let Some((len, table)) =
            TableEXT_CODE4C::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_encrt2 = token_76(tokens_current);
        let mic_base4 = token_75(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE4C,
                mic_encrt2,
                mic_base4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1386:1, end:1386:2))"]
#[derive(Clone, Debug)]
struct slti_instructionVar1198 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl slti_instructionVar1198 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slti"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rt32_5,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1392:1, end:1392:2))"]
#[derive(Clone, Debug)]
struct sltiu_instructionVar1199 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl sltiu_instructionVar1199 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sltiu"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_rt32_5,
                mic_rs32_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1463:1, end:1463:2))"]
#[derive(Clone, Debug)]
struct sw_instructionVar1200 {
    mic_base0: u8,
    RT5L: TableRT5L,
    EXT_MS16: TableEXT_MS16,
}
impl sw_instructionVar1200 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT5L,
                EXT_MS16,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1479:1, end:1479:2))"]
#[derive(Clone, Debug)]
struct sw16_instructionVar1201 {
    mic_encrt2: u8,
    mic_base4: u8,
    EXT_CODE4E: TableEXT_CODE4E,
}
impl sw16_instructionVar1201 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sw16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_30_display(self.mic_encrt2),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE4E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_25_display(self.mic_base4),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_CODE4E = if let Some((len, table)) =
            TableEXT_CODE4E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_encrt2 = token_76(tokens_current);
        let mic_base4 = token_75(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE4E,
                mic_encrt2,
                mic_base4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1487:1, end:1487:2))"]
#[derive(Clone, Debug)]
struct swc1_instructionVar1202 {
    mic_ft_5: u8,
    mic_base0: u8,
    EXT_MS16: TableEXT_MS16,
}
impl swc1_instructionVar1202 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swc1"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_34_display(self.mic_ft_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_MS16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(self.mic_base0),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_ft_5 = token_69(tokens_current);
        let mic_base0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let EXT_MS16 = if let Some((len, table)) =
            TableEXT_MS16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_MS16,
                mic_ft_5,
                mic_base0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1503:1, end:1503:2))"]
#[derive(Clone, Debug)]
struct swsp_instructionVar1203 {
    EXT_CODE5: TableEXT_CODE5,
    RT5L: TableRT5L,
}
impl swsp_instructionVar1203 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swsp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT5L
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let RT5L = if let Some((len, table)) =
            TableRT5L::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_CODE5 = if let Some((len, table)) =
            TableEXT_CODE5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_CODE5, RT5L }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:1643:1, end:1643:2))"]
#[derive(Clone, Debug)]
struct xori_instructionVar1204 {
    mic_rt32_5: u8,
    mic_rs32_0: u8,
    micb_imm16: u16,
}
impl xori_instructionVar1204 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xori"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_33_display(self.mic_rs32_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.micb_imm16 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let micb_imm16 = token_68(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mic_rt32_5,
                mic_rs32_0,
                micb_imm16,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(jr_instructionVar0),
    Var1(bal_instructionVar1),
    Var2(bal_instructionVar2),
    Var3(jic_instructionVar3),
    Var4(deret_instructionVar4),
    Var5(ehb_instructionVar5),
    Var6(eret_instructionVar6),
    Var7(eretnc_instructionVar7),
    Var8(nop_instructionVar8),
    Var9(pause_instructionVar9),
    Var10(ssnop_instructionVar10),
    Var11(tlbinv_instructionVar11),
    Var12(tlbinvf_instructionVar12),
    Var13(tlbp_instructionVar13),
    Var14(tlbr_instructionVar14),
    Var15(tlbwi_instructionVar15),
    Var16(tlbwr_instructionVar16),
    Var17(deret_instructionVar17),
    Var18(di_instructionVar18),
    Var19(ehb_instructionVar19),
    Var20(ei_instructionVar20),
    Var21(rfe_instructionVar21),
    Var22(eret_instructionVar22),
    Var23(eretnc_instructionVar23),
    Var24(nop_instructionVar24),
    Var25(pause_instructionVar25),
    Var26(ssnop_instructionVar26),
    Var27(tlbinv_instructionVar27),
    Var28(tlbinvf_instructionVar28),
    Var29(tlbp_instructionVar29),
    Var30(tlbr_instructionVar30),
    Var31(tlbwi_instructionVar31),
    Var32(tlbwr_instructionVar32),
    Var33(mfhi_instructionVar33),
    Var34(mflo_instructionVar34),
    Var35(clear_instructionVar35),
    Var36(dvp_instructionVar36),
    Var37(evp_instructionVar37),
    Var38(di_instructionVar38),
    Var39(ei_instructionVar39),
    Var40(rdhwr_instructionVar40),
    Var41(clear_instructionVar41),
    Var42(bitswap_instructionVar42),
    Var43(cfc1_instructionVar43),
    Var44(ctc1_instructionVar44),
    Var45(rddsp_instructionVar45),
    Var46(cfc0_instructionVar46),
    Var47(ctc0_instructionVar47),
    Var48(move_instructionVar48),
    Var49(mthi_instructionVar49),
    Var50(mtlo_instructionVar50),
    Var51(clo_instructionVar51),
    Var52(clz_instructionVar52),
    Var53(mfhi_instructionVar53),
    Var54(mflo_instructionVar54),
    Var55(wrdsp_instructionVar55),
    Var56(mthi_instructionVar56),
    Var57(mthlip_instructionVar57),
    Var58(mtlo_instructionVar58),
    Var59(shilov_instructionVar59),
    Var60(move_instructionVar60),
    Var61(rdpgpr_instructionVar61),
    Var62(seb_instructionVar62),
    Var63(seh_instructionVar63),
    Var64(wrpgpr_instructionVar64),
    Var65(wsbh_instructionVar65),
    Var66(div_instructionVar66),
    Var67(divu_instructionVar67),
    Var68(madd_instructionVar68),
    Var69(maddu_instructionVar69),
    Var70(msubu_instructionVar70),
    Var71(msub_instructionVar71),
    Var72(mult_instructionVar72),
    Var73(multu_instructionVar73),
    Var74(movf_instructionVar74),
    Var75(movt_instructionVar75),
    Var76(clo_instructionVar76),
    Var77(clz_instructionVar77),
    Var78(movn_instructionVar78),
    Var79(movz_instructionVar79),
    Var80(mul_instructionVar80),
    Var81(div_instructionVar81),
    Var82(mod_instructionVar82),
    Var83(divu_instructionVar83),
    Var84(modu_instructionVar84),
    Var85(mul_instructionVar85),
    Var86(muh_instructionVar86),
    Var87(mulu_instructionVar87),
    Var88(muhu_instructionVar88),
    Var89(seleqz_instructionVar89),
    Var90(selnez_instructionVar90),
    Var91(cfc1_instructionVar91),
    Var92(ctc1_instructionVar92),
    Var93(mfc1_instructionVar93),
    Var94(mfhc1_instructionVar94),
    Var95(mtc1_instructionVar95),
    Var96(mthc1_instructionVar96),
    Var97(prefx_instructionVar97),
    Var98(sdxc1_instructionVar98),
    Var99(swxc1_instructionVar99),
    Var100(absq_s_ph_instructionVar100),
    Var101(absq_s_qb_instructionVar101),
    Var102(absq_s_w_instructionVar102),
    Var103(cmp_eq_ph_instructionVar103),
    Var104(cmp_lt_ph_instructionVar104),
    Var105(cmp_le_ph_instructionVar105),
    Var106(cmpu_eq_qb_instructionVar106),
    Var107(cmpu_lt_qb_instructionVar107),
    Var108(cmpu_le_qb_instructionVar108),
    Var109(insv_instructionVar109),
    Var110(shilo_instructionVar110),
    Var111(balign_instructionVar111),
    Var112(bitrev_instructionVar112),
    Var113(dpa_w_ph_instructionVar113),
    Var114(dpaq_s_w_ph_instructionVar114),
    Var115(dpaq_sa_l_w_instructionVar115),
    Var116(dpaqx_s_w_ph_instructionVar116),
    Var117(dpaqx_sa_w_ph_instructionVar117),
    Var118(dpau_h_qbl_instructionVar118),
    Var119(dpau_h_qbr_instructionVar119),
    Var120(dpax_w_ph_instructionVar120),
    Var121(dps_w_ph_instructionVar121),
    Var122(dpsq_s_w_ph_instructionVar122),
    Var123(dpsq_sa_l_w_instructionVar123),
    Var124(dpsqx_s_w_ph_instructionVar124),
    Var125(dpsqx_sa_w_ph_instructionVar125),
    Var126(dpsu_h_qbl_instructionVar126),
    Var127(dpsu_h_qbr_instructionVar127),
    Var128(dpsx_w_ph_instructionVar128),
    Var129(extp_instructionVar129),
    Var130(extpdp_instructionVar130),
    Var131(extpdpv_instructionVar131),
    Var132(extpv_instructionVar132),
    Var133(extr_w_instructionVar133),
    Var134(extr_r_w_instructionVar134),
    Var135(extr_rs_w_instructionVar135),
    Var136(extr_s_h_instructionVar136),
    Var137(extrv_w_instructionVar137),
    Var138(extrv_r_w_instructionVar138),
    Var139(extrv_rs_w_instructionVar139),
    Var140(extrv_s_h_instructionVar140),
    Var141(madd_instructionVar141),
    Var142(maddu_instructionVar142),
    Var143(maq_s_w_phl_instructionVar143),
    Var144(maq_sa_w_phl_instructionVar144),
    Var145(maq_s_w_phr_instructionVar145),
    Var146(maq_sa_w_phr_instructionVar146),
    Var147(msub_instructionVar147),
    Var148(msubu_instructionVar148),
    Var149(mulsa_w_ph_instructionVar149),
    Var150(mulsaq_s_w_ph_instructionVar150),
    Var151(mult_instructionVar151),
    Var152(multu_instructionVar152),
    Var153(preceq_w_phl_instructionVar153),
    Var154(preceq_w_phr_instructionVar154),
    Var155(precequ_ph_qbl_instructionVar155),
    Var156(precequ_ph_qbla_instructionVar156),
    Var157(precequ_ph_qbr_instructionVar157),
    Var158(precequ_ph_qbra_instructionVar158),
    Var159(preceu_ph_qbl_instructionVar159),
    Var160(preceu_ph_qbla_instructionVar160),
    Var161(preceu_ph_qbr_instructionVar161),
    Var162(preceu_ph_qbra_instructionVar162),
    Var163(raddu_w_qb_instructionVar163),
    Var164(replv_ph_instructionVar164),
    Var165(replv_qb_instructionVar165),
    Var166(repl_qb_instructionVar166),
    Var167(shll_ph_instructionVar167),
    Var168(shll_s_ph_instructionVar168),
    Var169(shra_ph_instructionVar169),
    Var170(shra_r_ph_instructionVar170),
    Var171(shrl_ph_instructionVar171),
    Var172(add_instructionVar172),
    Var173(addu_instructionVar173),
    Var174(and_instructionVar174),
    Var175(cvt_s_pl_instructionVar175),
    Var176(cvt_s_pu_instructionVar176),
    Var177(class_S_instructionVar177),
    Var178(class_D_instructionVar178),
    Var179(rint_S_instructionVar179),
    Var180(rint_D_instructionVar180),
    Var181(min_S_instructionVar181),
    Var182(min_D_instructionVar182),
    Var183(max_S_instructionVar183),
    Var184(max_D_instructionVar184),
    Var185(mina_S_instructionVar185),
    Var186(mina_D_instructionVar186),
    Var187(maxa_S_instructionVar187),
    Var188(maxa_D_instructionVar188),
    Var189(maddf_S_instructionVar189),
    Var190(maddf_D_instructionVar190),
    Var191(msubf_S_instructionVar191),
    Var192(msubf_D_instructionVar192),
    Var193(seleqz_S_instructionVar193),
    Var194(seleqz_D_instructionVar194),
    Var195(selnez_S_instructionVar195),
    Var196(selnez_D_instructionVar196),
    Var197(jr_instructionVar197),
    Var198(jr_hb_instructionVar198),
    Var199(mfhi_instructionVar199),
    Var200(mflo_instructionVar200),
    Var201(mthi_instructionVar201),
    Var202(mtlo_instructionVar202),
    Var203(rdhwr_instructionVar203),
    Var204(abs_PS_instructionVar204),
    Var205(div_instructionVar205),
    Var206(divu_instructionVar206),
    Var207(jalr_instructionVar207),
    Var208(jalr_hb_instructionVar208),
    Var209(jalrs_instructionVar209),
    Var210(jalrs_hb_instructionVar210),
    Var211(madd_instructionVar211),
    Var212(maddu_instructionVar212),
    Var213(mov_PS_instructionVar213),
    Var214(msub_instructionVar214),
    Var215(msubu_instructionVar215),
    Var216(mult_instructionVar216),
    Var217(multu_instructionVar217),
    Var218(neg_PS_instructionVar218),
    Var219(rdhwr_instructionVar219),
    Var220(bitswap_instructionVar220),
    Var221(class_S_instructionVar221),
    Var222(class_D_instructionVar222),
    Var223(jalrc_instructionVar223),
    Var224(jalrc_hb_instructionVar224),
    Var225(rint_S_instructionVar225),
    Var226(rint_D_instructionVar226),
    Var227(nal_instructionVar227),
    Var228(sync_instructionVar228),
    Var229(bal_instructionVar229),
    Var230(bc2f_instructionVar230),
    Var231(bc2fl_instructionVar231),
    Var232(bc2t_instructionVar232),
    Var233(bc2tl_instructionVar233),
    Var234(bal_instructionVar234),
    Var235(bad1_instructionVar235),
    Var236(bgezalc_instructionVar236),
    Var237(bgeuc_instructionVar237),
    Var238(bad2_instructionVar238),
    Var239(bltzalc_instructionVar239),
    Var240(bltuc_instructionVar240),
    Var241(beqzalc_instructionVar241),
    Var242(bnezalc_instructionVar242),
    Var243(bad3_instructionVar243),
    Var244(blezc_instructionVar244),
    Var245(bgezc_instructionVar245),
    Var246(bad4_instructionVar246),
    Var247(bgtzc_instructionVar247),
    Var248(bltzc_instructionVar248),
    Var249(sigrie_instructionVar249),
    Var250(ceil_l_S_instructionVar250),
    Var251(ceil_l_D_instructionVar251),
    Var252(ceil_w_S_instructionVar252),
    Var253(ceil_w_D_instructionVar253),
    Var254(cvt_d_S_instructionVar254),
    Var255(cvt_d_W_instructionVar255),
    Var256(cvt_d_L_instructionVar256),
    Var257(cvt_l_S_instructionVar257),
    Var258(cvt_l_D_instructionVar258),
    Var259(cvt_s_D_instructionVar259),
    Var260(cvt_s_W_instructionVar260),
    Var261(cvt_s_L_instructionVar261),
    Var262(cvt_w_S_instructionVar262),
    Var263(cvt_w_D_instructionVar263),
    Var264(floor_l_S_instructionVar264),
    Var265(floor_l_D_instructionVar265),
    Var266(floor_w_S_instructionVar266),
    Var267(floor_w_D_instructionVar267),
    Var268(recip_S_instructionVar268),
    Var269(recip_D_instructionVar269),
    Var270(round_l_S_instructionVar270),
    Var271(round_l_D_instructionVar271),
    Var272(round_w_S_instructionVar272),
    Var273(round_w_D_instructionVar273),
    Var274(rsqrt_S_instructionVar274),
    Var275(rsqrt_D_instructionVar275),
    Var276(sqrt_S_instructionVar276),
    Var277(sqrt_D_instructionVar277),
    Var278(trunc_l_S_instructionVar278),
    Var279(trunc_l_D_instructionVar279),
    Var280(trunc_w_S_instructionVar280),
    Var281(trunc_w_D_instructionVar281),
    Var282(bc1f_instructionVar282),
    Var283(bc1fl_instructionVar283),
    Var284(bc1t_instructionVar284),
    Var285(bc1tl_instructionVar285),
    Var286(di_instructionVar286),
    Var287(ei_instructionVar287),
    Var288(sync_instructionVar288),
    Var289(dvp_instructionVar289),
    Var290(evp_instructionVar290),
    Var291(abs_S_instructionVar291),
    Var292(abs_D_instructionVar292),
    Var293(ceil_l_S_instructionVar293),
    Var294(ceil_l_D_instructionVar294),
    Var295(ceil_w_S_instructionVar295),
    Var296(ceil_w_D_instructionVar296),
    Var297(cfc1_instructionVar297),
    Var298(cfc2_instructionVar298),
    Var299(clo_instructionVar299),
    Var300(clz_instructionVar300),
    Var301(ctc1_instructionVar301),
    Var302(ctc2_instructionVar302),
    Var303(cvt_d_S_instructionVar303),
    Var304(cvt_d_W_instructionVar304),
    Var305(cvt_d_L_instructionVar305),
    Var306(cvt_l_S_instructionVar306),
    Var307(cvt_l_D_instructionVar307),
    Var308(cvt_s_D_instructionVar308),
    Var309(cvt_s_W_instructionVar309),
    Var310(cvt_s_L_instructionVar310),
    Var311(cvt_w_S_instructionVar311),
    Var312(cvt_w_D_instructionVar312),
    Var313(floor_l_S_instructionVar313),
    Var314(floor_l_D_instructionVar314),
    Var315(floor_w_S_instructionVar315),
    Var316(floor_w_D_instructionVar316),
    Var317(mfc1_instructionVar317),
    Var318(mfc2_instructionVar318),
    Var319(mfhc1_instructionVar319),
    Var320(mfhc2_instructionVar320),
    Var321(mov_S_instructionVar321),
    Var322(mov_D_instructionVar322),
    Var323(mtc1_instructionVar323),
    Var324(mtc2_instructionVar324),
    Var325(mthc1_instructionVar325),
    Var326(mthc2_instructionVar326),
    Var327(neg_S_instructionVar327),
    Var328(neg_D_instructionVar328),
    Var329(rdpgpr_instructionVar329),
    Var330(recip_S_instructionVar330),
    Var331(recip_D_instructionVar331),
    Var332(round_l_S_instructionVar332),
    Var333(round_l_D_instructionVar333),
    Var334(round_w_S_instructionVar334),
    Var335(round_w_D_instructionVar335),
    Var336(rsqrt_S_instructionVar336),
    Var337(rsqrt_D_instructionVar337),
    Var338(sdbbp_instructionVar338),
    Var339(seb_instructionVar339),
    Var340(seh_instructionVar340),
    Var341(sqrt_S_instructionVar341),
    Var342(sqrt_D_instructionVar342),
    Var343(syscall_instructionVar343),
    Var344(trunk_l_S_instructionVar344),
    Var345(trunk_l_D_instructionVar345),
    Var346(trunk_w_S_instructionVar346),
    Var347(trunk_w_D_instructionVar347),
    Var348(wait_instructionVar348),
    Var349(wrpgpr_instructionVar349),
    Var350(wsbh_instructionVar350),
    Var351(b_instructionVar351),
    Var352(jr_hb_instructionVar352),
    Var353(jalr_hb_instructionVar353),
    Var354(jr_instructionVar354),
    Var355(jalr_instructionVar355),
    Var356(jalr_hb_instructionVar356),
    Var357(jalr_instructionVar357),
    Var358(bgezal_instructionVar358),
    Var359(bgezall_instructionVar359),
    Var360(bgezl_instructionVar360),
    Var361(bgtzl_instructionVar361),
    Var362(blezl_instructionVar362),
    Var363(bltzal_instructionVar363),
    Var364(bltzall_instructionVar364),
    Var365(bltzl_instructionVar365),
    Var366(teqi_instructionVar366),
    Var367(tgei_instructionVar367),
    Var368(tgeiu_instructionVar368),
    Var369(tlti_instructionVar369),
    Var370(tltiu_instructionVar370),
    Var371(tnei_instructionVar371),
    Var372(aluipc_instructionVar372),
    Var373(auipc_instructionVar373),
    Var374(bposge32_instructionVar374),
    Var375(bposge32c_instructionVar375),
    Var376(bgez_instructionVar376),
    Var377(bgtz_instructionVar377),
    Var378(blez_instructionVar378),
    Var379(bltz_instructionVar379),
    Var380(lbx_instructionVar380),
    Var381(lhux_instructionVar381),
    Var382(nor_instructionVar382),
    Var383(or_instructionVar383),
    Var384(rotrv_instructionVar384),
    Var385(sllv_instructionVar385),
    Var386(slt_instructionVar386),
    Var387(sltu_instructionVar387),
    Var388(srav_instructionVar388),
    Var389(srlv_instructionVar389),
    Var390(sub_instructionVar390),
    Var391(subu_instructionVar391),
    Var392(xor_instructionVar392),
    Var393(dadd_instructionVar393),
    Var394(daddu_instructionVar394),
    Var395(lwle_instructionVar395),
    Var396(lwre_instructionVar396),
    Var397(swle_instructionVar397),
    Var398(swre_instructionVar398),
    Var399(ll_instructionVar399),
    Var400(llx_instructionVar400),
    Var401(llxe_instructionVar401),
    Var402(scx_instructionVar402),
    Var403(scxe_instructionVar403),
    Var404(addq_ph_instructionVar404),
    Var405(addq_s_ph_instructionVar405),
    Var406(addq_s_w_instructionVar406),
    Var407(addqh_ph_instructionVar407),
    Var408(addqh_r_ph_instructionVar408),
    Var409(addqh_w_instructionVar409),
    Var410(addqh_r_w_instructionVar410),
    Var411(addsc_instructionVar411),
    Var412(addu_ph_instructionVar412),
    Var413(addu_s_ph_instructionVar413),
    Var414(addu_qb_instructionVar414),
    Var415(addu_s_qb_instructionVar415),
    Var416(addwc_instructionVar416),
    Var417(adduh_qb_instructionVar417),
    Var418(adduh_r_qb_instructionVar418),
    Var419(append_instructionVar419),
    Var420(cmpgdu_eq_qb_instructionVar420),
    Var421(cmpgdu_lt_qb_instructionVar421),
    Var422(cmpgdu_le_qb_instructionVar422),
    Var423(cmpgu_eq_qb_instructionVar423),
    Var424(cmpgu_lt_qb_instructionVar424),
    Var425(cmpgu_le_qb_instructionVar425),
    Var426(lbux_instructionVar426),
    Var427(lhx_instructionVar427),
    Var428(lwx_instructionVar428),
    Var429(modsub_instructionVar429),
    Var430(mul_ph_instructionVar430),
    Var431(mul_s_ph_instructionVar431),
    Var432(muleq_s_w_phl_instructionVar432),
    Var433(muleq_s_w_phr_instructionVar433),
    Var434(muleu_s_ph_qbl_instructionVar434),
    Var435(muleu_s_ph_qbr_instructionVar435),
    Var436(mulq_rs_ph_instructionVar436),
    Var437(mulq_rs_w_instructionVar437),
    Var438(mulq_s_ph_instructionVar438),
    Var439(mulq_s_w_instructionVar439),
    Var440(packrl_ph_instructionVar440),
    Var441(pick_ph_instructionVar441),
    Var442(pick_qb_instructionVar442),
    Var443(precr_qb_ph_instructionVar443),
    Var444(precr_sra_ph_w_instructionVar444),
    Var445(precr_sra_r_ph_w_instructionVar445),
    Var446(precrq_ph_w_instructionVar446),
    Var447(precrq_qb_ph_instructionVar447),
    Var448(precrqu_s_qb_ph_instructionVar448),
    Var449(precrq_rs_ph_w_instructionVar449),
    Var450(prepend_instructionVar450),
    Var451(rddsp_instructionVar451),
    Var452(repl_ph_instructionVar452),
    Var453(shll_qb_instructionVar453),
    Var454(shllv_ph_instructionVar454),
    Var455(shllv_s_ph_instructionVar455),
    Var456(shllv_qb_instructionVar456),
    Var457(shllv_s_w_instructionVar457),
    Var458(shll_s_w_instructionVar458),
    Var459(shra_qb_instructionVar459),
    Var460(shra_r_qb_instructionVar460),
    Var461(shrav_ph_instructionVar461),
    Var462(shrav_r_ph_instructionVar462),
    Var463(shrav_qb_instructionVar463),
    Var464(shrav_r_qb_instructionVar464),
    Var465(shrav_r_w_instructionVar465),
    Var466(shra_r_w_instructionVar466),
    Var467(shrl_qb_instructionVar467),
    Var468(shrlv_ph_instructionVar468),
    Var469(shrlv_qb_instructionVar469),
    Var470(subq_ph_instructionVar470),
    Var471(subq_s_ph_instructionVar471),
    Var472(subq_s_w_instructionVar472),
    Var473(subqh_ph_instructionVar473),
    Var474(subqh_r_ph_instructionVar474),
    Var475(subqh_w_instructionVar475),
    Var476(subqh_r_w_instructionVar476),
    Var477(subu_ph_instructionVar477),
    Var478(subu_s_ph_instructionVar478),
    Var479(subu_qb_instructionVar479),
    Var480(subu_s_qb_instructionVar480),
    Var481(subuh_qb_instructionVar481),
    Var482(subuh_r_qb_instructionVar482),
    Var483(wrdsp_instructionVar483),
    Var484(cachee_instructionVar484),
    Var485(lbe_instructionVar485),
    Var486(lbue_instructionVar486),
    Var487(lhe_instructionVar487),
    Var488(lhue_instructionVar488),
    Var489(lle_instructionVar489),
    Var490(lwe_instructionVar490),
    Var491(prefe_instructionVar491),
    Var492(rdhwr_instructionVar492),
    Var493(movf_S_instructionVar493),
    Var494(movf_D_instructionVar494),
    Var495(movf_PS_instructionVar495),
    Var496(movt_S_instructionVar496),
    Var497(movt_D_instructionVar497),
    Var498(movt_PS_instructionVar498),
    Var499(pll_ps_instructionVar499),
    Var500(plu_ps_instructionVar500),
    Var501(pul_ps_instructionVar501),
    Var502(puu_ps_instructionVar502),
    Var503(abs_PS_instructionVar503),
    Var504(add_PS_instructionVar504),
    Var505(cvt_PS_S_instructionVar505),
    Var506(mov_PS_instructionVar506),
    Var507(mul_PS_instructionVar507),
    Var508(neg_PS_instructionVar508),
    Var509(sub_PS_instructionVar509),
    Var510(c_f_S_instructionVar510),
    Var511(c_f_D_instructionVar511),
    Var512(c_f_PS_instructionVar512),
    Var513(c_un_S_instructionVar513),
    Var514(c_un_D_instructionVar514),
    Var515(c_un_PS_instructionVar515),
    Var516(c_eq_S_instructionVar516),
    Var517(c_eq_D_instructionVar517),
    Var518(c_eq_PS_instructionVar518),
    Var519(c_ueq_S_instructionVar519),
    Var520(c_ueq_D_instructionVar520),
    Var521(c_ueq_PS_instructionVar521),
    Var522(c_olt_S_instructionVar522),
    Var523(c_olt_D_instructionVar523),
    Var524(c_olt_PS_instructionVar524),
    Var525(c_ult_S_instructionVar525),
    Var526(c_ult_D_instructionVar526),
    Var527(c_ult_PS_instructionVar527),
    Var528(c_ole_S_instructionVar528),
    Var529(c_ole_D_instructionVar529),
    Var530(c_ole_PS_instructionVar530),
    Var531(c_ule_S_instructionVar531),
    Var532(c_ule_D_instructionVar532),
    Var533(c_ule_PS_instructionVar533),
    Var534(c_sf_S_instructionVar534),
    Var535(c_sf_D_instructionVar535),
    Var536(c_sf_PS_instructionVar536),
    Var537(c_ngle_S_instructionVar537),
    Var538(c_ngle_D_instructionVar538),
    Var539(c_ngle_PS_instructionVar539),
    Var540(c_seq_S_instructionVar540),
    Var541(c_seq_D_instructionVar541),
    Var542(c_seq_PS_instructionVar542),
    Var543(c_ngl_S_instructionVar543),
    Var544(c_ngl_D_instructionVar544),
    Var545(c_ngl_PS_instructionVar545),
    Var546(c_lt_S_instructionVar546),
    Var547(c_lt_D_instructionVar547),
    Var548(c_lt_PS_instructionVar548),
    Var549(c_nge_S_instructionVar549),
    Var550(c_nge_D_instructionVar550),
    Var551(c_nge_PS_instructionVar551),
    Var552(c_le_S_instructionVar552),
    Var553(c_le_D_instructionVar553),
    Var554(c_le_PS_instructionVar554),
    Var555(c_ngt_S_instructionVar555),
    Var556(c_ngt_D_instructionVar556),
    Var557(c_ngt_PS_instructionVar557),
    Var558(movn_S_instructionVar558),
    Var559(movn_D_instructionVar559),
    Var560(movn_PS_instructionVar560),
    Var561(movz_S_instructionVar561),
    Var562(movz_D_instructionVar562),
    Var563(movz_PS_instructionVar563),
    Var564(sel_S_instructionVar564),
    Var565(sel_D_instructionVar565),
    Var566(cmp_af_S_instructionVar566),
    Var567(cmp_af_D_instructionVar567),
    Var568(cmp_un_S_instructionVar568),
    Var569(cmp_un_D_instructionVar569),
    Var570(cmp_or_S_instructionVar570),
    Var571(cmp_or_D_instructionVar571),
    Var572(cmp_eq_S_instructionVar572),
    Var573(cmp_eq_D_instructionVar573),
    Var574(cmp_une_S_instructionVar574),
    Var575(cmp_une_D_instructionVar575),
    Var576(cmp_ueq_S_instructionVar576),
    Var577(cmp_ueq_D_instructionVar577),
    Var578(cmp_ne_S_instructionVar578),
    Var579(cmp_ne_D_instructionVar579),
    Var580(cmp_lt_S_instructionVar580),
    Var581(cmp_lt_D_instructionVar581),
    Var582(cmp_ult_S_instructionVar582),
    Var583(cmp_ult_D_instructionVar583),
    Var584(cmp_le_S_instructionVar584),
    Var585(cmp_le_D_instructionVar585),
    Var586(cmp_ule_S_instructionVar586),
    Var587(cmp_ule_D_instructionVar587),
    Var588(cmp_saf_S_instructionVar588),
    Var589(cmp_saf_D_instructionVar589),
    Var590(cmp_sun_S_instructionVar590),
    Var591(cmp_sun_D_instructionVar591),
    Var592(cmp_sor_S_instructionVar592),
    Var593(cmp_sor_D_instructionVar593),
    Var594(cmp_seq_S_instructionVar594),
    Var595(cmp_seq_D_instructionVar595),
    Var596(cmp_sune_S_instructionVar596),
    Var597(cmp_sune_D_instructionVar597),
    Var598(cmp_sueq_S_instructionVar598),
    Var599(cmp_sueq_D_instructionVar599),
    Var600(cmp_sne_S_instructionVar600),
    Var601(cmp_sne_D_instructionVar601),
    Var602(cmp_slt_S_instructionVar602),
    Var603(cmp_slt_D_instructionVar603),
    Var604(cmp_sult_S_instructionVar604),
    Var605(cmp_sult_D_instructionVar605),
    Var606(cmp_sle_S_instructionVar606),
    Var607(cmp_sle_D_instructionVar607),
    Var608(cmp_sule_S_instructionVar608),
    Var609(cmp_sule_D_instructionVar609),
    Var610(rotr_instructionVar610),
    Var611(sbe_instructionVar611),
    Var612(sce_instructionVar612),
    Var613(she_instructionVar613),
    Var614(sll_instructionVar614),
    Var615(sra_instructionVar615),
    Var616(srl_instructionVar616),
    Var617(swe_instructionVar617),
    Var618(abs_S_instructionVar618),
    Var619(abs_D_instructionVar619),
    Var620(add_S_instructionVar620),
    Var621(add_D_instructionVar621),
    Var622(div_S_instructionVar622),
    Var623(div_D_instructionVar623),
    Var624(mov_S_instructionVar624),
    Var625(mov_D_instructionVar625),
    Var626(mul_S_instructionVar626),
    Var627(mul_D_instructionVar627),
    Var628(neg_S_instructionVar628),
    Var629(neg_D_instructionVar629),
    Var630(sub_S_instructionVar630),
    Var631(sub_D_instructionVar631),
    Var632(wait_instructionVar632),
    Var633(align_instructionVar633),
    Var634(lsa_instructionVar634),
    Var635(ldxc1_instructionVar635),
    Var636(luxc1_instructionVar636),
    Var637(lwxc1_instructionVar637),
    Var638(alnv_PS_instructionVar638),
    Var639(madd_S_instructionVar639),
    Var640(madd_D_instructionVar640),
    Var641(madd_PS_instructionVar641),
    Var642(msub_S_instructionVar642),
    Var643(msub_D_instructionVar643),
    Var644(msub_PS_instructionVar644),
    Var645(nmadd_S_instructionVar645),
    Var646(nmadd_D_instructionVar646),
    Var647(nmadd_PS_instructionVar647),
    Var648(nmsub_S_instructionVar648),
    Var649(nmsub_D_instructionVar649),
    Var650(nmsub_PS_instructionVar650),
    Var651(suxc1_instructionVar651),
    Var652(break_instructionVar652),
    Var653(bc2f_instructionVar653),
    Var654(bc2fl_instructionVar654),
    Var655(bc2t_instructionVar655),
    Var656(bc2tl_instructionVar656),
    Var657(bc1f_instructionVar657),
    Var658(bc1fl_instructionVar658),
    Var659(bc1t_instructionVar659),
    Var660(bc1tl_instructionVar660),
    Var661(lui_instructionVar661),
    Var662(lwl_instructionVar662),
    Var663(lwr_instructionVar663),
    Var664(swl_instructionVar664),
    Var665(swr_instructionVar665),
    Var666(addiupc_instructionVar666),
    Var667(bc2eqz_instructionVar667),
    Var668(bc2nez_instructionVar668),
    Var669(blezalc_instructionVar669),
    Var670(bgtzalc_instructionVar670),
    Var671(beqc_instructionVar671),
    Var672(bnec_instructionVar672),
    Var673(jialc_instructionVar673),
    Var674(jic_instructionVar674),
    Var675(ldc2_instructionVar675),
    Var676(lwc2_instructionVar676),
    Var677(lwpc_instructionVar677),
    Var678(bc1eqz_instructionVar678),
    Var679(bc1nez_instructionVar679),
    Var680(lwle_instructionVar680),
    Var681(lwre_instructionVar681),
    Var682(swle_instructionVar682),
    Var683(swre_instructionVar683),
    Var684(cache_instructionVar684),
    Var685(llx_instructionVar685),
    Var686(llxe_instructionVar686),
    Var687(scx_instructionVar687),
    Var688(scxe_instructionVar688),
    Var689(cache_instructionVar689),
    Var690(mfc0_instructionVar690),
    Var691(mtc0_instructionVar691),
    Var692(mthc0_instructionVar692),
    Var693(cfc2_instructionVar693),
    Var694(ctc2_instructionVar694),
    Var695(mfc2_instructionVar695),
    Var696(mfhc2_instructionVar696),
    Var697(li_instructionVar697),
    Var698(mtc2_instructionVar698),
    Var699(mthc2_instructionVar699),
    Var700(cachee_instructionVar700),
    Var701(lbe_instructionVar701),
    Var702(lbue_instructionVar702),
    Var703(lhe_instructionVar703),
    Var704(lhue_instructionVar704),
    Var705(ll_instructionVar705),
    Var706(lle_instructionVar706),
    Var707(lwe_instructionVar707),
    Var708(pref_instructionVar708),
    Var709(prefe_instructionVar709),
    Var710(sbe_instructionVar710),
    Var711(sc_instructionVar711),
    Var712(sce_instructionVar712),
    Var713(she_instructionVar713),
    Var714(swe_instructionVar714),
    Var715(cop2_instructionVar715),
    Var716(ext_instructionVar716),
    Var717(ins_instructionVar717),
    Var718(sdbbp_instructionVar718),
    Var719(synci_instructionVar719),
    Var720(syscall_instructionVar720),
    Var721(teq_instructionVar721),
    Var722(tge_instructionVar722),
    Var723(tgeu_instructionVar723),
    Var724(tlt_instructionVar724),
    Var725(tltu_instructionVar725),
    Var726(tne_instructionVar726),
    Var727(addi_instructionVar727),
    Var728(beql_instructionVar728),
    Var729(bnel_instructionVar729),
    Var730(jalx_instructionVar730),
    Var731(ldc2_instructionVar731),
    Var732(ll_instructionVar732),
    Var733(lwc2_instructionVar733),
    Var734(lwl_instructionVar734),
    Var735(lwr_instructionVar735),
    Var736(sc_instructionVar736),
    Var737(swl_instructionVar737),
    Var738(swr_instructionVar738),
    Var739(daddi_instructionVar739),
    Var740(aui_instructionVar740),
    Var741(balc_instructionVar741),
    Var742(bc_instructionVar742),
    Var743(bovc_instructionVar743),
    Var744(bnvc_instructionVar744),
    Var745(bgec_instructionVar745),
    Var746(bltc_instructionVar746),
    Var747(beqzc_instructionVar747),
    Var748(bnezc_instructionVar748),
    Var749(addiu_instructionVar749),
    Var750(andi_instructionVar750),
    Var751(beq_instructionVar751),
    Var752(bne_instructionVar752),
    Var753(SPECIAL2_instructionVar753),
    Var754(j_instructionVar754),
    Var755(jal_instructionVar755),
    Var756(lb_instructionVar756),
    Var757(lbu_instructionVar757),
    Var758(lh_instructionVar758),
    Var759(lhu_instructionVar759),
    Var760(lw_instructionVar760),
    Var761(ori_instructionVar761),
    Var762(pref_instructionVar762),
    Var763(sb_instructionVar763),
    Var764(sdc2_instructionVar764),
    Var765(sh_instructionVar765),
    Var766(slti_instructionVar766),
    Var767(sltiu_instructionVar767),
    Var768(sw_instructionVar768),
    Var769(swc2_instructionVar769),
    Var770(xori_instructionVar770),
    Var771(daddiu_instructionVar771),
    Var772(ldc1_instructionVar772),
    Var773(sdc1_instructionVar773),
    Var774(lwc1_instructionVar774),
    Var775(swc1_instructionVar775),
    Var776(instructionVar776),
    Var777(instructionVar777),
    Var778(addiu_instructionVar778),
    Var779(addiu_instructionVar779),
    Var780(addu_instructionVar780),
    Var781(subu_instructionVar781),
    Var782(addiu_instructionVar782),
    Var783(addiu_instructionVar783),
    Var784(jr_instructionVar784),
    Var785(jrc_instructionVar785),
    Var786(nop_instructionVar786),
    Var787(jalr_instructionVar787),
    Var788(jalrc_instructionVar788),
    Var789(jr_instructionVar789),
    Var790(jrc_instructionVar790),
    Var791(mfhi_instructionVar791),
    Var792(mflo_instructionVar792),
    Var793(seb_instructionVar793),
    Var794(seh_instructionVar794),
    Var795(zeb_instructionVar795),
    Var796(zeh_instructionVar796),
    Var797(and_instructionVar797),
    Var798(break_instructionVar798),
    Var799(cmp_instructionVar799),
    Var800(div_instructionVar800),
    Var801(divu_instructionVar801),
    Var802(mult_instructionVar802),
    Var803(multu_instructionVar803),
    Var804(neg_instructionVar804),
    Var805(not_instructionVar805),
    Var806(or_instructionVar806),
    Var807(sdbbp_instructionVar807),
    Var808(sllv_instructionVar808),
    Var809(slt_instructionVar809),
    Var810(sltu_instructionVar810),
    Var811(srav_instructionVar811),
    Var812(srlv_instructionVar812),
    Var813(xor_instructionVar813),
    Var814(addiu_instructionVar814),
    Var815(addiu_instructionVar815),
    Var816(addiu_instructionVar816),
    Var817(asmacro_instructionVar817),
    Var818(restore_instructionVar818),
    Var819(save_instructionVar819),
    Var820(bteqz_instructionVar820),
    Var821(btnez_instructionVar821),
    Var822(cmpi_instructionVar822),
    Var823(cmpi_instructionVar823),
    Var824(move_instructionVar824),
    Var825(move_instructionVar825),
    Var826(sll_instructionVar826),
    Var827(sra_instructionVar827),
    Var828(srl_instructionVar828),
    Var829(sw_instructionVar829),
    Var830(addiu_instructionVar830),
    Var831(b_instructionVar831),
    Var832(beqz_instructionVar832),
    Var833(bnez_instructionVar833),
    Var834(jal_instructionVar834),
    Var835(jalx_instructionVar835),
    Var836(lb_instructionVar836),
    Var837(lbu_instructionVar837),
    Var838(lh_instructionVar838),
    Var839(lhu_instructionVar839),
    Var840(li_instructionVar840),
    Var841(lw_instructionVar841),
    Var842(lw_instructionVar842),
    Var843(lw_instructionVar843),
    Var844(sb_instructionVar844),
    Var845(sh_instructionVar845),
    Var846(slti_instructionVar846),
    Var847(sltiu_instructionVar847),
    Var848(sw_instructionVar848),
    Var849(sw_instructionVar849),
    Var850(cvt_s_PL_instructionVar850),
    Var851(cvt_s_PU_instructionVar851),
    Var852(c_f_S_instructionVar852),
    Var853(c_f_D_instructionVar853),
    Var854(c_f_PS_instructionVar854),
    Var855(c_un_S_instructionVar855),
    Var856(c_un_D_instructionVar856),
    Var857(c_un_PS_instructionVar857),
    Var858(c_eq_S_instructionVar858),
    Var859(c_eq_D_instructionVar859),
    Var860(c_eq_PS_instructionVar860),
    Var861(c_ueq_S_instructionVar861),
    Var862(c_ueq_D_instructionVar862),
    Var863(c_ueq_PS_instructionVar863),
    Var864(c_olt_S_instructionVar864),
    Var865(c_olt_D_instructionVar865),
    Var866(c_olt_PS_instructionVar866),
    Var867(c_ult_S_instructionVar867),
    Var868(c_ult_D_instructionVar868),
    Var869(c_ult_PS_instructionVar869),
    Var870(c_ole_S_instructionVar870),
    Var871(c_ole_D_instructionVar871),
    Var872(c_ole_PS_instructionVar872),
    Var873(c_ule_S_instructionVar873),
    Var874(c_ule_D_instructionVar874),
    Var875(c_ule_PS_instructionVar875),
    Var876(c_sf_S_instructionVar876),
    Var877(c_sf_D_instructionVar877),
    Var878(c_sf_PS_instructionVar878),
    Var879(c_ngle_S_instructionVar879),
    Var880(c_ngle_D_instructionVar880),
    Var881(c_ngle_PS_instructionVar881),
    Var882(c_seq_S_instructionVar882),
    Var883(c_seq_D_instructionVar883),
    Var884(c_seq_PS_instructionVar884),
    Var885(c_ngl_S_instructionVar885),
    Var886(c_ngl_D_instructionVar886),
    Var887(c_ngl_PS_instructionVar887),
    Var888(c_lt_S_instructionVar888),
    Var889(c_lt_D_instructionVar889),
    Var890(c_lt_PS_instructionVar890),
    Var891(c_nge_S_instructionVar891),
    Var892(c_nge_D_instructionVar892),
    Var893(c_nge_PS_instructionVar893),
    Var894(c_le_S_instructionVar894),
    Var895(c_le_D_instructionVar895),
    Var896(c_le_PS_instructionVar896),
    Var897(c_ngt_S_instructionVar897),
    Var898(c_ngt_D_instructionVar898),
    Var899(c_ngt_PS_instructionVar899),
    Var900(movf_instructionVar900),
    Var901(movf_S_instructionVar901),
    Var902(movf_D_instructionVar902),
    Var903(movf_PS_instructionVar903),
    Var904(movt_instructionVar904),
    Var905(movt_S_instructionVar905),
    Var906(movt_D_instructionVar906),
    Var907(movt_PS_instructionVar907),
    Var908(rdhwr_instructionVar908),
    Var909(lwxs_instructionVar909),
    Var910(mfc0_instructionVar910),
    Var911(mfhc0_instructionVar911),
    Var912(mtc0_instructionVar912),
    Var913(mthc0_instructionVar913),
    Var914(mul_instructionVar914),
    Var915(teq_instructionVar915),
    Var916(tge_instructionVar916),
    Var917(tgeu_instructionVar917),
    Var918(tlt_instructionVar918),
    Var919(tltu_instructionVar919),
    Var920(tne_instructionVar920),
    Var921(add_PS_instructionVar921),
    Var922(cvt_PS_instructionVar922),
    Var923(lwxc1_instructionVar923),
    Var924(movn_instructionVar924),
    Var925(movn_S_instructionVar925),
    Var926(movn_D_instructionVar926),
    Var927(movn_PS_instructionVar927),
    Var928(movz_instructionVar928),
    Var929(movz_S_instructionVar929),
    Var930(movz_D_instructionVar930),
    Var931(movz_PS_instructionVar931),
    Var932(mul_PS_instructionVar932),
    Var933(pll_PS_instructionVar933),
    Var934(plu_PS_instructionVar934),
    Var935(prefx_instructionVar935),
    Var936(pul_PS_instructionVar936),
    Var937(puu_PS_instructionVar937),
    Var938(sdxc1_instructionVar938),
    Var939(swxc1_instructionVar939),
    Var940(cmp_af_S_instructionVar940),
    Var941(cmp_af_D_instructionVar941),
    Var942(cmp_un_S_instructionVar942),
    Var943(cmp_un_D_instructionVar943),
    Var944(cmp_eq_S_instructionVar944),
    Var945(cmp_eq_D_instructionVar945),
    Var946(cmp_ueq_S_instructionVar946),
    Var947(cmp_ueq_D_instructionVar947),
    Var948(cmp_lt_S_instructionVar948),
    Var949(cmp_lt_D_instructionVar949),
    Var950(cmp_ult_S_instructionVar950),
    Var951(cmp_ult_D_instructionVar951),
    Var952(cmp_le_S_instructionVar952),
    Var953(cmp_le_D_instructionVar953),
    Var954(cmp_ule_S_instructionVar954),
    Var955(cmp_ule_D_instructionVar955),
    Var956(cmp_saf_S_instructionVar956),
    Var957(cmp_saf_D_instructionVar957),
    Var958(cmp_sun_S_instructionVar958),
    Var959(cmp_sun_D_instructionVar959),
    Var960(cmp_seq_S_instructionVar960),
    Var961(cmp_seq_D_instructionVar961),
    Var962(cmp_sueq_S_instructionVar962),
    Var963(cmp_sueq_D_instructionVar963),
    Var964(cmp_slt_S_instructionVar964),
    Var965(cmp_slt_D_instructionVar965),
    Var966(cmp_sult_S_instructionVar966),
    Var967(cmp_sult_D_instructionVar967),
    Var968(cmp_sle_S_instructionVar968),
    Var969(cmp_sle_D_instructionVar969),
    Var970(cmp_sule_S_instructionVar970),
    Var971(cmp_sule_D_instructionVar971),
    Var972(cmp_or_S_instructionVar972),
    Var973(cmp_or_D_instructionVar973),
    Var974(cmp_une_S_instructionVar974),
    Var975(cmp_une_D_instructionVar975),
    Var976(cmp_ne_S_instructionVar976),
    Var977(cmp_ne_D_instructionVar977),
    Var978(cmp_sor_S_instructionVar978),
    Var979(cmp_sor_D_instructionVar979),
    Var980(cmp_sune_S_instructionVar980),
    Var981(cmp_sune_D_instructionVar981),
    Var982(cmp_sne_S_instructionVar982),
    Var983(cmp_sne_D_instructionVar983),
    Var984(div_instructionVar984),
    Var985(divu_instructionVar985),
    Var986(maddf_S_instructionVar986),
    Var987(maddf_D_instructionVar987),
    Var988(max_S_instructionVar988),
    Var989(max_D_instructionVar989),
    Var990(maxa_S_instructionVar990),
    Var991(maxa_D_instructionVar991),
    Var992(min_S_instructionVar992),
    Var993(min_D_instructionVar993),
    Var994(mina_S_instructionVar994),
    Var995(mina_D_instructionVar995),
    Var996(mod_instructionVar996),
    Var997(modu_instructionVar997),
    Var998(msubf_S_instructionVar998),
    Var999(msubf_D_instructionVar999),
    Var1000(muh_instructionVar1000),
    Var1001(mulu_instructionVar1001),
    Var1002(muhu_instructionVar1002),
    Var1003(seleqz_instructionVar1003),
    Var1004(selnez_instructionVar1004),
    Var1005(sel_S_instructionVar1005),
    Var1006(sel_D_instructionVar1006),
    Var1007(seleqz_S_instructionVar1007),
    Var1008(seleqz_D_instructionVar1008),
    Var1009(selnez_S_instructionVar1009),
    Var1010(selnez_D_instructionVar1010),
    Var1011(add_instructionVar1011),
    Var1012(add_S_instructionVar1012),
    Var1013(add_D_instructionVar1013),
    Var1014(b_instructionVar1014),
    Var1015(bal_instructionVar1015),
    Var1016(jr16_instructionVar1016),
    Var1017(jrc_instructionVar1017),
    Var1018(bad1_instructionVar1018),
    Var1019(bad2_instructionVar1019),
    Var1020(beqzalc_instructionVar1020),
    Var1021(bnezalc_instructionVar1021),
    Var1022(bad3_instructionVar1022),
    Var1023(bad4_instructionVar1023),
    Var1024(jrc16_instructionVar1024),
    Var1025(break16_instructionVar1025),
    Var1026(sdbbp16_instructionVar1026),
    Var1027(bc1f_instructionVar1027),
    Var1028(bc1t_instructionVar1028),
    Var1029(bc2f_instructionVar1029),
    Var1030(bc2t_instructionVar1030),
    Var1031(synci_instructionVar1031),
    Var1032(align_instructionVar1032),
    Var1033(lsa_instructionVar1033),
    Var1034(sigrie_instructionVar1034),
    Var1035(alnv_ps_instructionVar1035),
    Var1036(beqzc_instructionVar1036),
    Var1037(bgez_instructionVar1037),
    Var1038(bgezal_instructionVar1038),
    Var1039(bgezals_instructionVar1039),
    Var1040(bgtz_instructionVar1040),
    Var1041(blez_instructionVar1041),
    Var1042(bltz_instructionVar1042),
    Var1043(bltzal_instructionVar1043),
    Var1044(bltzals_instructionVar1044),
    Var1045(bnezc_instructionVar1045),
    Var1046(lwl_instructionVar1046),
    Var1047(lwr_instructionVar1047),
    Var1048(swl_instructionVar1048),
    Var1049(swr_instructionVar1049),
    Var1050(cache_instructionVar1050),
    Var1051(jalr16_instructionVar1051),
    Var1052(jalrs16_instructionVar1052),
    Var1053(jr16_instructionVar1053),
    Var1054(jraddiusp_instructionVar1054),
    Var1055(jrc_instructionVar1055),
    Var1056(lwl_instructionVar1056),
    Var1057(lwr_instructionVar1057),
    Var1058(madd_S_instructionVar1058),
    Var1059(madd_D_instructionVar1059),
    Var1060(madd_PS_instructionVar1060),
    Var1061(mfhi16_instructionVar1061),
    Var1062(mflo16_instructionVar1062),
    Var1063(msub_S_instructionVar1063),
    Var1064(msub_D_instructionVar1064),
    Var1065(msub_PS_instructionVar1065),
    Var1066(swl_instructionVar1066),
    Var1067(swr_instructionVar1067),
    Var1068(teqi_instructionVar1068),
    Var1069(tgei_instructionVar1069),
    Var1070(tgeiu_instructionVar1070),
    Var1071(tlti_instructionVar1071),
    Var1072(tltiu_instructionVar1072),
    Var1073(tnei_instructionVar1073),
    Var1074(aluipc_instructionVar1074),
    Var1075(auipc_instructionVar1075),
    Var1076(bc1eqzc_instructionVar1076),
    Var1077(bc1nezc_instructionVar1077),
    Var1078(bc2eqzc_instructionVar1078),
    Var1079(bc2nezc_instructionVar1079),
    Var1080(blezalc_instructionVar1080),
    Var1081(bgezalc_instructionVar1081),
    Var1082(bgtzalc_instructionVar1082),
    Var1083(bltzalc_instructionVar1083),
    Var1084(beqc_instructionVar1084),
    Var1085(bnec_instructionVar1085),
    Var1086(blezc_instructionVar1086),
    Var1087(bgezc_instructionVar1087),
    Var1088(bgtzc_instructionVar1088),
    Var1089(bltzc_instructionVar1089),
    Var1090(bad6_instructionVar1090),
    Var1091(jalrc16_instructionVar1091),
    Var1092(jialc_instructionVar1092),
    Var1093(jic_instructionVar1093),
    Var1094(jrcaddiusp_instructionVar1094),
    Var1095(jrc16_instructionVar1095),
    Var1096(lwpc_instructionVar1096),
    Var1097(lwupc_instructionVar1097),
    Var1098(addiupc_instructionVar1098),
    Var1099(addiur1sp_instructionVar1099),
    Var1100(addiur2_instructionVar1100),
    Var1101(addiusp_instructionVar1101),
    Var1102(addius5_instructionVar1102),
    Var1103(addu_instructionVar1103),
    Var1104(addu16_instructionVar1104),
    Var1105(and_instructionVar1105),
    Var1106(and16_instructionVar1106),
    Var1107(div_S_instructionVar1107),
    Var1108(div_D_instructionVar1108),
    Var1109(mul_S_instructionVar1109),
    Var1110(mul_D_instructionVar1110),
    Var1111(nor_instructionVar1111),
    Var1112(or_instructionVar1112),
    Var1113(rotr_instructionVar1113),
    Var1114(rotrv_instructionVar1114),
    Var1115(sll_instructionVar1115),
    Var1116(sllv_instructionVar1116),
    Var1117(slt_instructionVar1117),
    Var1118(sltu_instructionVar1118),
    Var1119(sra_instructionVar1119),
    Var1120(srav_instructionVar1120),
    Var1121(srl_instructionVar1121),
    Var1122(srlv_instructionVar1122),
    Var1123(sub_instructionVar1123),
    Var1124(sub_S_instructionVar1124),
    Var1125(sub_D_instructionVar1125),
    Var1126(subu_instructionVar1126),
    Var1127(xor_instructionVar1127),
    Var1128(sub_PS_instructionVar1128),
    Var1129(break_instructionVar1129),
    Var1130(ext_instructionVar1130),
    Var1131(ins_instructionVar1131),
    Var1132(cop2_instructionVar1132),
    Var1133(swc2_instructionVar1133),
    Var1134(ldc2_instructionVar1134),
    Var1135(lui_instructionVar1135),
    Var1136(lwm16_instructionVar1136),
    Var1137(lwm32_instructionVar1137),
    Var1138(lwc2_instructionVar1138),
    Var1139(lwp_instructionVar1139),
    Var1140(movep_instructionVar1140),
    Var1141(not16_instructionVar1141),
    Var1142(or16_instructionVar1142),
    Var1143(sdc2_instructionVar1143),
    Var1144(sll16_instructionVar1144),
    Var1145(srl16_instructionVar1145),
    Var1146(subu16_instructionVar1146),
    Var1147(swp_instructionVar1147),
    Var1148(swm16_instructionVar1148),
    Var1149(swm32_instructionVar1149),
    Var1150(xor16_instructionVar1150),
    Var1151(addi_instructionVar1151),
    Var1152(b16_instructionVar1152),
    Var1153(beq_instructionVar1153),
    Var1154(beqz16_instructionVar1154),
    Var1155(bne_instructionVar1155),
    Var1156(bnez16_instructionVar1156),
    Var1157(j_instructionVar1157),
    Var1158(jal_instructionVar1158),
    Var1159(jals_instructionVar1159),
    Var1160(jalx_instructionVar1160),
    Var1161(aui_instructionVar1161),
    Var1162(balc_instructionVar1162),
    Var1163(bc_instructionVar1163),
    Var1164(bc16_instructionVar1164),
    Var1165(beqzc16_instructionVar1165),
    Var1166(bnezc16_instructionVar1166),
    Var1167(bgeuc_instructionVar1167),
    Var1168(bltuc_instructionVar1168),
    Var1169(bovc_instructionVar1169),
    Var1170(bnvc_instructionVar1170),
    Var1171(bgec_instructionVar1171),
    Var1172(bltc_instructionVar1172),
    Var1173(beqzc_instructionVar1173),
    Var1174(bnezc_instructionVar1174),
    Var1175(addiu_instructionVar1175),
    Var1176(andi_instructionVar1176),
    Var1177(andi16_instructionVar1177),
    Var1178(lb_instructionVar1178),
    Var1179(lbu_instructionVar1179),
    Var1180(lbu16_instructionVar1180),
    Var1181(ldc1_instructionVar1181),
    Var1182(lh_instructionVar1182),
    Var1183(lhu_instructionVar1183),
    Var1184(lhu16_instructionVar1184),
    Var1185(li16_instructionVar1185),
    Var1186(lw_instructionVar1186),
    Var1187(lw16_instructionVar1187),
    Var1188(lwc1_instructionVar1188),
    Var1189(lwgp_instructionVar1189),
    Var1190(lwsp_instructionVar1190),
    Var1191(move16_instructionVar1191),
    Var1192(ori_instructionVar1192),
    Var1193(sb_instructionVar1193),
    Var1194(sb16_instructionVar1194),
    Var1195(sdc1_instructionVar1195),
    Var1196(sh_instructionVar1196),
    Var1197(sh16_instructionVar1197),
    Var1198(slti_instructionVar1198),
    Var1199(sltiu_instructionVar1199),
    Var1200(sw_instructionVar1200),
    Var1201(sw16_instructionVar1201),
    Var1202(swc1_instructionVar1202),
    Var1203(swsp_instructionVar1203),
    Var1204(xori_instructionVar1204),
}
impl Tableinstruction {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var35(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var36(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var37(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var38(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var39(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var40(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var41(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var42(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var43(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var44(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var45(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var46(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var47(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var48(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var49(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var50(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var51(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var52(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var53(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var54(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var55(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var56(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var57(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var58(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var59(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var60(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var61(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var62(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var63(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var64(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var65(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var66(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var67(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var68(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var69(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var70(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var71(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var72(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var73(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var74(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var75(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var76(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var77(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var78(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var79(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var80(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var81(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var82(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var83(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var84(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var85(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var86(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var87(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var88(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var89(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var90(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var91(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var92(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var93(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var94(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var95(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var96(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var97(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var98(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var99(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var100(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var101(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var102(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var103(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var104(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var105(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var106(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var107(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var108(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var109(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var110(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var111(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var112(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var113(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var114(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var115(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var116(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var117(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var118(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var119(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var120(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var121(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var122(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var123(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var124(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var125(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var126(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var127(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var128(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var129(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var130(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var131(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var132(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var133(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var134(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var135(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var136(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var137(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var138(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var139(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var140(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var141(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var142(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var143(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var144(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var145(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var146(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var147(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var148(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var149(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var150(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var151(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var152(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var153(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var154(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var155(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var156(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var157(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var158(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var159(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var160(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var161(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var162(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var163(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var164(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var165(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var166(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var167(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var168(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var169(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var170(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var171(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var172(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var173(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var174(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var175(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var176(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var177(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var178(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var179(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var180(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var181(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var182(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var183(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var184(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var185(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var186(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var187(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var188(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var189(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var190(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var191(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var192(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var193(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var194(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var195(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var196(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var197(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var198(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var199(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var200(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var201(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var202(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var203(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var204(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var205(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var206(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var207(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var208(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var209(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var210(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var211(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var212(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var213(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var214(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var215(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var216(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var217(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var218(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var219(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var220(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var221(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var222(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var223(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var224(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var225(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var226(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var227(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var228(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var229(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var230(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var231(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var232(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var233(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var234(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var235(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var236(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var237(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var238(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var239(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var240(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var241(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var242(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var243(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var244(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var245(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var246(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var247(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var248(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var249(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var250(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var251(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var252(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var253(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var254(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var255(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var256(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var257(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var258(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var259(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var260(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var261(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var262(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var263(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var264(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var265(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var266(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var267(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var268(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var269(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var270(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var271(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var272(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var273(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var274(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var275(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var276(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var277(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var278(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var279(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var280(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var281(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var282(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var283(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var284(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var285(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var286(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var287(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var288(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var289(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var290(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var291(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var292(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var293(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var294(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var295(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var296(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var297(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var298(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var299(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var300(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var301(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var302(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var303(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var304(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var305(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var306(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var307(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var308(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var309(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var310(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var311(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var312(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var313(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var314(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var315(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var316(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var317(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var318(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var319(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var320(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var321(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var322(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var323(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var324(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var325(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var326(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var327(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var328(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var329(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var330(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var331(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var332(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var333(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var334(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var335(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var336(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var337(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var338(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var339(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var340(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var341(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var342(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var343(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var344(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var345(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var346(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var347(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var348(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var349(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var350(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var351(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var352(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var353(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var354(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var355(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var356(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var357(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var358(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var359(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var360(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var361(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var362(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var363(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var364(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var365(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var366(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var367(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var368(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var369(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var370(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var371(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var372(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var373(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var374(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var375(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var376(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var377(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var378(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var379(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var380(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var381(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var382(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var383(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var384(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var385(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var386(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var387(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var388(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var389(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var390(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var391(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var392(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var393(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var394(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var395(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var396(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var397(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var398(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var399(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var400(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var401(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var402(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var403(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var404(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var405(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var406(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var407(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var408(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var409(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var410(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var411(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var412(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var413(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var414(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var415(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var416(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var417(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var418(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var419(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var420(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var421(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var422(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var423(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var424(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var425(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var426(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var427(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var428(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var429(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var430(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var431(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var432(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var433(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var434(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var435(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var436(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var437(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var438(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var439(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var440(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var441(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var442(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var443(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var444(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var445(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var446(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var447(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var448(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var449(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var450(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var451(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var452(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var453(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var454(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var455(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var456(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var457(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var458(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var459(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var460(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var461(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var462(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var463(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var464(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var465(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var466(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var467(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var468(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var469(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var470(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var471(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var472(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var473(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var474(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var475(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var476(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var477(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var478(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var479(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var480(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var481(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var482(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var483(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var484(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var485(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var486(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var487(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var488(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var489(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var490(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var491(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var492(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var493(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var494(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var495(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var496(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var497(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var498(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var499(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var500(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var501(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var502(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var503(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var504(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var505(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var506(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var507(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var508(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var509(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var510(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var511(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var512(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var513(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var514(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var515(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var516(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var517(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var518(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var519(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var520(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var521(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var522(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var523(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var524(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var525(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var526(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var527(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var528(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var529(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var530(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var531(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var532(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var533(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var534(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var535(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var536(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var537(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var538(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var539(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var540(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var541(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var542(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var543(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var544(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var545(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var546(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var547(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var548(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var549(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var550(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var551(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var552(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var553(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var554(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var555(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var556(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var557(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var558(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var559(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var560(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var561(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var562(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var563(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var564(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var565(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var566(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var567(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var568(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var569(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var570(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var571(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var572(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var573(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var574(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var575(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var576(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var577(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var578(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var579(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var580(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var581(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var582(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var583(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var584(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var585(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var586(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var587(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var588(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var589(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var590(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var591(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var592(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var593(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var594(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var595(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var596(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var597(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var598(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var599(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var600(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var601(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var602(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var603(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var604(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var605(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var606(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var607(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var608(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var609(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var610(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var611(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var612(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var613(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var614(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var615(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var616(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var617(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var618(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var619(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var620(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var621(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var622(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var623(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var624(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var625(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var626(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var627(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var628(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var629(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var630(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var631(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var632(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var633(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var634(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var635(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var636(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var637(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var638(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var639(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var640(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var641(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var642(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var643(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var644(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var645(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var646(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var647(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var648(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var649(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var650(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var651(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var652(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var653(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var654(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var655(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var656(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var657(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var658(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var659(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var660(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var661(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var662(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var663(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var664(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var665(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var666(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var667(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var668(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var669(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var670(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var671(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var672(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var673(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var674(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var675(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var676(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var677(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var678(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var679(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var680(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var681(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var682(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var683(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var684(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var685(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var686(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var687(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var688(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var689(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var690(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var691(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var692(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var693(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var694(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var695(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var696(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var697(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var698(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var699(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var700(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var701(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var702(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var703(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var704(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var705(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var706(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var707(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var708(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var709(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var710(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var711(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var712(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var713(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var714(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var715(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var716(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var717(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var718(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var719(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var720(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var721(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var722(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var723(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var724(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var725(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var726(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var727(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var728(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var729(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var730(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var731(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var732(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var733(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var734(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var735(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var736(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var737(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var738(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var739(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var740(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var741(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var742(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var743(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var744(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var745(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var746(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var747(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var748(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var749(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var750(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var751(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var752(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var753(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var754(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var755(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var756(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var757(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var758(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var759(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var760(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var761(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var762(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var763(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var764(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var765(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var766(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var767(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var768(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var769(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var770(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var771(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var772(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var773(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var774(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var775(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var776(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var777(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var778(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var779(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var780(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var781(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var782(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var783(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var784(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var785(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var786(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var787(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var788(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var789(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var790(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var791(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var792(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var793(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var794(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var795(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var796(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var797(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var798(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var799(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var800(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var801(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var802(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var803(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var804(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var805(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var806(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var807(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var808(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var809(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var810(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var811(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var812(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var813(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var814(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var815(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var816(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var817(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var818(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var819(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var820(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var821(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var822(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var823(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var824(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var825(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var826(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var827(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var828(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var829(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var830(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var831(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var832(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var833(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var834(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var835(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var836(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var837(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var838(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var839(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var840(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var841(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var842(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var843(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var844(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var845(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var846(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var847(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var848(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var849(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var850(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var851(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var852(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var853(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var854(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var855(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var856(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var857(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var858(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var859(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var860(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var861(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var862(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var863(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var864(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var865(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var866(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var867(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var868(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var869(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var870(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var871(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var872(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var873(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var874(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var875(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var876(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var877(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var878(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var879(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var880(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var881(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var882(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var883(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var884(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var885(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var886(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var887(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var888(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var889(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var890(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var891(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var892(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var893(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var894(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var895(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var896(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var897(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var898(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var899(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var900(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var901(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var902(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var903(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var904(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var905(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var906(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var907(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var908(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var909(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var910(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var911(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var912(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var913(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var914(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var915(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var916(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var917(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var918(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var919(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var920(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var921(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var922(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var923(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var924(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var925(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var926(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var927(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var928(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var929(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var930(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var931(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var932(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var933(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var934(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var935(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var936(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var937(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var938(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var939(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var940(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var941(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var942(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var943(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var944(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var945(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var946(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var947(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var948(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var949(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var950(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var951(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var952(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var953(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var954(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var955(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var956(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var957(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var958(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var959(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var960(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var961(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var962(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var963(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var964(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var965(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var966(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var967(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var968(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var969(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var970(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var971(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var972(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var973(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var974(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var975(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var976(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var977(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var978(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var979(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var980(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var981(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var982(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var983(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var984(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var985(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var986(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var987(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var988(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var989(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var990(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var991(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var992(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var993(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var994(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var995(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var996(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var997(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var998(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var999(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1000(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1001(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1002(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1003(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1004(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1005(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1006(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1007(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1008(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1009(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1010(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1011(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1012(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1013(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1014(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1015(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1016(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1017(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1018(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1019(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1020(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1021(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1022(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1023(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1024(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1025(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1026(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1027(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1028(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1029(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1030(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1031(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1032(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1033(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1034(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1035(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1036(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1037(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1038(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1039(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1040(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1041(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1042(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1043(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1044(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1045(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1046(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1047(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1048(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1049(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1050(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1051(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1052(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1053(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1054(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1055(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1056(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1057(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1058(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1059(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1060(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1061(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1062(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1063(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1064(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1065(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1066(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1067(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1068(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1069(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1070(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1071(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1072(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1073(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1074(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1075(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1076(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1077(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1078(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1079(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1080(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1081(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1082(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1083(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1084(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1085(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1086(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1087(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1088(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1089(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1090(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1091(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1092(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1093(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1094(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1095(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1096(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1097(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1098(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1099(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1100(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1101(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1102(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1103(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1104(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1105(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1106(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1107(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1108(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1109(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1110(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1111(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1112(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1113(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1114(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1115(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1116(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1117(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1118(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1119(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1120(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1121(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1122(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1123(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1124(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1125(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1126(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1127(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1128(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1129(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1130(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1131(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1132(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1133(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1134(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1135(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1136(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1137(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1138(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1139(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1140(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1141(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1142(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1143(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1144(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1145(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1146(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1147(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1148(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1149(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1150(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1151(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1152(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1153(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1154(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1155(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1156(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1157(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1158(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1159(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1160(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1161(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1162(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1163(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1164(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1165(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1166(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1167(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1168(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1169(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1170(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1171(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1172(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1173(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1174(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1175(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1176(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1177(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1178(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1179(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1180(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1181(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1182(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1183(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1184(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1185(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1186(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1187(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1188(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1189(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1190(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1191(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1192(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1193(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1194(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1195(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1196(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1197(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1198(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1199(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1200(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1201(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1202(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1203(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1204(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 254) == 8
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 224
            && (tokens_param[3] & 255) == 3
        {
            if let Some((inst_len, parsed)) =
                jr_instructionVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 17
            && (tokens_param[3] & 255) == 4
        {
            if let Some((inst_len, parsed)) =
                bal_instructionVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 17
            && (tokens_param[3] & 255) == 4
        {
            if let Some((inst_len, parsed)) =
                bal_instructionVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 31
            && (tokens_param[3] & 255) == 216
        {
            if let Some((inst_len, parsed)) =
                jic_instructionVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 227
        {
            if let Some((inst_len, parsed)) =
                deret_instructionVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 24
        {
            if let Some((inst_len, parsed)) =
                ehb_instructionVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 243
        {
            if let Some((inst_len, parsed)) =
                eret_instructionVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 243
        {
            if let Some((inst_len, parsed)) =
                eretnc_instructionVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                nop_instructionVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 40
        {
            if let Some((inst_len, parsed)) =
                pause_instructionVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 8
        {
            if let Some((inst_len, parsed)) =
                ssnop_instructionVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 67
        {
            if let Some((inst_len, parsed)) =
                tlbinv_instructionVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 83
        {
            if let Some((inst_len, parsed)) =
                tlbinvf_instructionVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 3
        {
            if let Some((inst_len, parsed)) =
                tlbp_instructionVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 19
        {
            if let Some((inst_len, parsed)) =
                tlbr_instructionVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 35
        {
            if let Some((inst_len, parsed)) =
                tlbwi_instructionVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 51
        {
            if let Some((inst_len, parsed)) =
                tlbwr_instructionVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 31
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                deret_instructionVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 96
            && (tokens_param[2] & 255) == 96
            && (tokens_param[3] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                di_instructionVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 192
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                ehb_instructionVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 255) == 96
            && (tokens_param[2] & 255) == 96
            && (tokens_param[3] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                ei_instructionVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                rfe_instructionVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                eret_instructionVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 88
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                eretnc_instructionVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                nop_instructionVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pause_instructionVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                ssnop_instructionVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 3
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                tlbinv_instructionVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                tlbinvf_instructionVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                tlbp_instructionVar29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                tlbr_instructionVar30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                tlbwi_instructionVar31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                tlbwr_instructionVar32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                mfhi_instructionVar33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 18
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                mflo_instructionVar34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                clear_instructionVar35::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var35(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 36
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 96
            && (tokens_param[3] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                dvp_instructionVar36::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var36(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 96
            && (tokens_param[3] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                evp_instructionVar37::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var37(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 96
            && (tokens_param[2] & 224) == 96
            && (tokens_param[3] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                di_instructionVar38::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var38(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 255) == 96
            && (tokens_param[2] & 224) == 96
            && (tokens_param[3] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                ei_instructionVar39::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var39(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 59
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                rdhwr_instructionVar40::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var40(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 45
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                clear_instructionVar41::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var41(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                bitswap_instructionVar42::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var42(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 255) == 68
        {
            if let Some((inst_len, parsed)) =
                cfc1_instructionVar43::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var43(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 68
        {
            if let Some((inst_len, parsed)) =
                ctc1_instructionVar44::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var44(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 184
            && (tokens_param[1] & 7) == 4
            && (tokens_param[2] & 255) == 31
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                rddsp_instructionVar45::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var45(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                cfc0_instructionVar46::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var46(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                ctc0_instructionVar47::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var47(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                move_instructionVar48::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var48(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                mthi_instructionVar49::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var49(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 19
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                mtlo_instructionVar50::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var50(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                clo_instructionVar51::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var51(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                clz_instructionVar52::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var52(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 159) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                mfhi_instructionVar53::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var53(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 18
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 159) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                mflo_instructionVar54::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var54(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 248
            && (tokens_param[1] & 255) == 252
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                wrdsp_instructionVar55::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var55(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 231) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                mthi_instructionVar56::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var56(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 248
            && (tokens_param[1] & 231) == 7
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mthlip_instructionVar57::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var57(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 19
            && (tokens_param[1] & 231) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                mtlo_instructionVar58::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var58(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 248
            && (tokens_param[1] & 231) == 6
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shilov_instructionVar59::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var59(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                move_instructionVar60::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var60(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                rdpgpr_instructionVar61::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var61(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 7) == 4
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                seb_instructionVar62::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var62(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                seh_instructionVar63::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var63(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                wrpgpr_instructionVar64::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var64(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 160
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                wsbh_instructionVar65::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var65(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 26
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                div_instructionVar66::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var66(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 27
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                divu_instructionVar67::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var67(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                madd_instructionVar68::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var68(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                maddu_instructionVar69::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var69(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 5
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                msubu_instructionVar70::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var70(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                msub_instructionVar71::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var71(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                mult_instructionVar72::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var72(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 25
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                multu_instructionVar73::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var73(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 3) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                movf_instructionVar74::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var74(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 3) == 1
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                movt_instructionVar75::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var75(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                clo_instructionVar76::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var76(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                clz_instructionVar77::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var77(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 11
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                movn_instructionVar78::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var78(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                movz_instructionVar79::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var79(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                mul_instructionVar80::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var80(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 154
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                div_instructionVar81::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var81(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 218
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                mod_instructionVar82::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var82(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 155
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                divu_instructionVar83::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var83(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 219
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                modu_instructionVar84::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var84(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 152
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                mul_instructionVar85::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var85(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 216
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                muh_instructionVar86::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var86(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 153
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                mulu_instructionVar87::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var87(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 217
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                muhu_instructionVar88::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var88(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 53
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                seleqz_instructionVar89::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var89(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 255) == 55
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                selnez_instructionVar90::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var90(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 255) == 68
        {
            if let Some((inst_len, parsed)) =
                cfc1_instructionVar91::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var91(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 68
        {
            if let Some((inst_len, parsed)) =
                ctc1_instructionVar92::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var92(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 68
        {
            if let Some((inst_len, parsed)) =
                mfc1_instructionVar93::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var93(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 96
            && (tokens_param[3] & 255) == 68
        {
            if let Some((inst_len, parsed)) =
                mfhc1_instructionVar94::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var94(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 68
        {
            if let Some((inst_len, parsed)) =
                mtc1_instructionVar95::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var95(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 224
            && (tokens_param[3] & 255) == 68
        {
            if let Some((inst_len, parsed)) =
                mthc1_instructionVar96::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var96(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 15
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                prefx_instructionVar97::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var97(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 9
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                sdxc1_instructionVar98::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var98(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                swxc1_instructionVar99::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var99(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 82
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                absq_s_ph_instructionVar100::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var100(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 82
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                absq_s_qb_instructionVar101::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var101(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 82
            && (tokens_param[1] & 7) == 4
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                absq_s_w_instructionVar102::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var102(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 255) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cmp_eq_ph_instructionVar103::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var103(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 255) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cmp_lt_ph_instructionVar104::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var104(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 145
            && (tokens_param[1] & 255) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cmp_le_ph_instructionVar105::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var105(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cmpu_eq_qb_instructionVar106::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var106(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cmpu_lt_qb_instructionVar107::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var107(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 145
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cmpu_le_qb_instructionVar108::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var108(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                insv_instructionVar109::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var109(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 184
            && (tokens_param[1] & 231) == 6
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shilo_instructionVar110::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var110(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 49
            && (tokens_param[1] & 231) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                balign_instructionVar111::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var111(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 210
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                bitrev_instructionVar112::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var112(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                dpa_w_ph_instructionVar113::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var113(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 231) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                dpaq_s_w_ph_instructionVar114::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var114(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 231) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                dpaq_sa_l_w_instructionVar115::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var115(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 231) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = dpaqx_s_w_ph_instructionVar116::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var116(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 176
            && (tokens_param[1] & 231) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = dpaqx_sa_w_ph_instructionVar117::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var117(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                dpau_h_qbl_instructionVar118::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var118(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 231) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                dpau_h_qbr_instructionVar119::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var119(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 231) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                dpax_w_ph_instructionVar120::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var120(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 112
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                dps_w_ph_instructionVar121::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var121(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 112
            && (tokens_param[1] & 231) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                dpsq_s_w_ph_instructionVar122::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var122(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 112
            && (tokens_param[1] & 231) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                dpsq_sa_l_w_instructionVar123::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var123(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 112
            && (tokens_param[1] & 231) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = dpsqx_s_w_ph_instructionVar124::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var124(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 231) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = dpsqx_sa_w_ph_instructionVar125::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var125(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 231) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                dpsu_h_qbl_instructionVar126::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var126(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 231) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                dpsu_h_qbr_instructionVar127::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var127(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 112
            && (tokens_param[1] & 231) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                dpsx_w_ph_instructionVar128::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var128(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 184
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extp_instructionVar129::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var129(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 184
            && (tokens_param[1] & 231) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extpdp_instructionVar130::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var130(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 248
            && (tokens_param[1] & 231) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extpdpv_instructionVar131::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var131(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 248
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extpv_instructionVar132::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var132(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 56
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extr_w_instructionVar133::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var133(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 56
            && (tokens_param[1] & 231) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extr_r_w_instructionVar134::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var134(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 184
            && (tokens_param[1] & 231) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extr_rs_w_instructionVar135::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var135(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 184
            && (tokens_param[1] & 231) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extr_s_h_instructionVar136::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var136(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 120
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extrv_w_instructionVar137::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var137(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 120
            && (tokens_param[1] & 231) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extrv_r_w_instructionVar138::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var138(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 248
            && (tokens_param[1] & 231) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extrv_rs_w_instructionVar139::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var139(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 248
            && (tokens_param[1] & 231) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extrv_s_h_instructionVar140::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var140(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                madd_instructionVar141::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var141(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                maddu_instructionVar142::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var142(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 231) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                maq_s_w_phl_instructionVar143::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var143(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 231) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = maq_sa_w_phl_instructionVar144::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var144(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 176
            && (tokens_param[1] & 231) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                maq_s_w_phr_instructionVar145::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var145(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 176
            && (tokens_param[1] & 231) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = maq_sa_w_phr_instructionVar146::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var146(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                msub_instructionVar147::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var147(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 5
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                msubu_instructionVar148::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var148(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 176
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulsa_w_ph_instructionVar149::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var149(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 176
            && (tokens_param[1] & 231) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = mulsaq_s_w_ph_instructionVar150::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var150(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                mult_instructionVar151::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var151(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 25
            && (tokens_param[1] & 231) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                multu_instructionVar152::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var152(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 18
            && (tokens_param[1] & 7) == 3
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) = preceq_w_phl_instructionVar153::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var153(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 82
            && (tokens_param[1] & 7) == 3
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) = preceq_w_phr_instructionVar154::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var154(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 18
            && (tokens_param[1] & 7) == 1
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) = precequ_ph_qbl_instructionVar155::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var155(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 146
            && (tokens_param[1] & 7) == 1
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) = precequ_ph_qbla_instructionVar156::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var156(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 82
            && (tokens_param[1] & 7) == 1
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) = precequ_ph_qbr_instructionVar157::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var157(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 210
            && (tokens_param[1] & 7) == 1
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) = precequ_ph_qbra_instructionVar158::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var158(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 18
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) = preceu_ph_qbl_instructionVar159::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var159(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 146
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) = preceu_ph_qbla_instructionVar160::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var160(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 82
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) = preceu_ph_qbr_instructionVar161::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var161(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 210
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) = preceu_ph_qbra_instructionVar162::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var162(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 5
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                raddu_w_qb_instructionVar163::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var163(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 210
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                replv_ph_instructionVar164::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var164(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 210
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                replv_qb_instructionVar165::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var165(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 146
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                repl_qb_instructionVar166::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var166(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 19
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 254) == 124
        {
            if let Some((inst_len, parsed)) =
                shll_ph_instructionVar167::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var167(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 19
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 254) == 124
        {
            if let Some((inst_len, parsed)) =
                shll_s_ph_instructionVar168::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var168(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 83
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 254) == 124
        {
            if let Some((inst_len, parsed)) =
                shra_ph_instructionVar169::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var169(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 83
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 254) == 124
        {
            if let Some((inst_len, parsed)) =
                shra_r_ph_instructionVar170::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var170(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 83
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 254) == 124
        {
            if let Some((inst_len, parsed)) =
                shrl_ph_instructionVar171::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var171(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar172::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var172(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                addu_instructionVar173::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var173(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 36
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar174::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var174(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 40
            && (tokens_param[2] & 255) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_s_pl_instructionVar175::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var175(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 32
            && (tokens_param[2] & 255) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_s_pu_instructionVar176::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var176(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 27
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                class_S_instructionVar177::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var177(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 27
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                class_D_instructionVar178::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var178(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 26
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                rint_S_instructionVar179::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var179(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 26
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                rint_D_instructionVar180::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var180(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 28
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                min_S_instructionVar181::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var181(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 28
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                min_D_instructionVar182::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var182(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 29
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                max_S_instructionVar183::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var183(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 29
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                max_D_instructionVar184::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var184(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 30
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                mina_S_instructionVar185::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var185(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 30
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                mina_D_instructionVar186::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var186(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 31
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                maxa_S_instructionVar187::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var187(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 31
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                maxa_D_instructionVar188::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var188(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 24
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                maddf_S_instructionVar189::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var189(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 24
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                maddf_D_instructionVar190::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var190(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 25
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                msubf_S_instructionVar191::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var191(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 25
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                msubf_D_instructionVar192::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var192(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 20
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                seleqz_S_instructionVar193::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var193(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 20
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                seleqz_D_instructionVar194::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var194(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 23
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                selnez_S_instructionVar195::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var195(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 23
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                selnez_D_instructionVar196::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var196(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 15
        {
            if let Some((inst_len, parsed)) =
                jr_instructionVar197::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var197(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 31
        {
            if let Some((inst_len, parsed)) =
                jr_hb_instructionVar198::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var198(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 13
        {
            if let Some((inst_len, parsed)) =
                mfhi_instructionVar199::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var199(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 29
        {
            if let Some((inst_len, parsed)) =
                mflo_instructionVar200::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var200(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 45
        {
            if let Some((inst_len, parsed)) =
                mthi_instructionVar201::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var201(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 61
        {
            if let Some((inst_len, parsed)) =
                mtlo_instructionVar202::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var202(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 192
            && (tokens_param[3] & 255) == 1
        {
            if let Some((inst_len, parsed)) =
                rdhwr_instructionVar203::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var203(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 67
        {
            if let Some((inst_len, parsed)) =
                abs_PS_instructionVar204::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var204(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 171
        {
            if let Some((inst_len, parsed)) =
                div_instructionVar205::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var205(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 187
        {
            if let Some((inst_len, parsed)) =
                divu_instructionVar206::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var206(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 15
        {
            if let Some((inst_len, parsed)) =
                jalr_instructionVar207::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var207(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 31
        {
            if let Some((inst_len, parsed)) =
                jalr_hb_instructionVar208::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var208(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 79
        {
            if let Some((inst_len, parsed)) =
                jalrs_instructionVar209::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var209(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 95
        {
            if let Some((inst_len, parsed)) =
                jalrs_hb_instructionVar210::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var210(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 203
        {
            if let Some((inst_len, parsed)) =
                madd_instructionVar211::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var211(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 219
        {
            if let Some((inst_len, parsed)) =
                maddu_instructionVar212::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var212(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                mov_PS_instructionVar213::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var213(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 235
        {
            if let Some((inst_len, parsed)) =
                msub_instructionVar214::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var214(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 251
        {
            if let Some((inst_len, parsed)) =
                msubu_instructionVar215::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var215(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 139
        {
            if let Some((inst_len, parsed)) =
                mult_instructionVar216::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var216(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 155
        {
            if let Some((inst_len, parsed)) =
                multu_instructionVar217::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var217(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 75
        {
            if let Some((inst_len, parsed)) =
                neg_PS_instructionVar218::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var218(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 107
        {
            if let Some((inst_len, parsed)) =
                rdhwr_instructionVar219::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var219(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 11
        {
            if let Some((inst_len, parsed)) =
                bitswap_instructionVar220::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var220(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 96
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                class_S_instructionVar221::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var221(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 96
            && (tokens_param[3] & 255) == 2
        {
            if let Some((inst_len, parsed)) =
                class_D_instructionVar222::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var222(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 15
        {
            if let Some((inst_len, parsed)) =
                jalrc_instructionVar223::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var223(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 31
        {
            if let Some((inst_len, parsed)) =
                jalrc_hb_instructionVar224::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var224(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                rint_S_instructionVar225::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var225(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 2
        {
            if let Some((inst_len, parsed)) =
                rint_D_instructionVar226::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var226(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 255) == 16
            && (tokens_param[3] & 255) == 4
        {
            if let Some((inst_len, parsed)) =
                nal_instructionVar227::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var227(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 15
            && (tokens_param[1] & 248) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                sync_instructionVar228::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var228(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 255) == 17
            && (tokens_param[3] & 255) == 4
        {
            if let Some((inst_len, parsed)) =
                bal_instructionVar229::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var229(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                bc2f_instructionVar230::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var230(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 255) == 2
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                bc2fl_instructionVar231::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var231(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 255) == 1
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                bc2t_instructionVar232::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var232(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 255) == 3
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                bc2tl_instructionVar233::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var233(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 255) == 17
            && (tokens_param[3] & 255) == 4
        {
            if let Some((inst_len, parsed)) =
                bal_instructionVar234::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var234(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 24
        {
            if let Some((inst_len, parsed)) =
                bad1_instructionVar235::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var235(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 24
        {
            if let Some((inst_len, parsed)) =
                bgezalc_instructionVar236::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var236(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 24
        {
            if let Some((inst_len, parsed)) =
                bgeuc_instructionVar237::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var237(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 28
        {
            if let Some((inst_len, parsed)) =
                bad2_instructionVar238::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var238(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 28
        {
            if let Some((inst_len, parsed)) =
                bltzalc_instructionVar239::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var239(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 28
        {
            if let Some((inst_len, parsed)) =
                bltuc_instructionVar240::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var240(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 32
        {
            if let Some((inst_len, parsed)) =
                beqzalc_instructionVar241::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var241(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 96
        {
            if let Some((inst_len, parsed)) =
                bnezalc_instructionVar242::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var242(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 88
        {
            if let Some((inst_len, parsed)) =
                bad3_instructionVar243::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var243(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 88
        {
            if let Some((inst_len, parsed)) =
                blezc_instructionVar244::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var244(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 88
        {
            if let Some((inst_len, parsed)) =
                bgezc_instructionVar245::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var245(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 92
        {
            if let Some((inst_len, parsed)) =
                bad4_instructionVar246::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var246(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 92
        {
            if let Some((inst_len, parsed)) =
                bgtzc_instructionVar247::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var247(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 92
        {
            if let Some((inst_len, parsed)) =
                bltzc_instructionVar248::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var248(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 255) == 23
            && (tokens_param[3] & 255) == 4
        {
            if let Some((inst_len, parsed)) =
                sigrie_instructionVar249::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var249(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 10
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                ceil_l_S_instructionVar250::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var250(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 10
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                ceil_l_D_instructionVar251::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var251(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 14
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                ceil_w_S_instructionVar252::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var252(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 14
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                ceil_w_D_instructionVar253::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var253(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 33
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_d_S_instructionVar254::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var254(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 33
            && (tokens_param[2] & 255) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_d_W_instructionVar255::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var255(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 33
            && (tokens_param[2] & 255) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_d_L_instructionVar256::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var256(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 37
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_l_S_instructionVar257::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var257(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 37
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_l_D_instructionVar258::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var258(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 32
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_s_D_instructionVar259::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var259(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 32
            && (tokens_param[2] & 255) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_s_W_instructionVar260::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var260(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 32
            && (tokens_param[2] & 255) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_s_L_instructionVar261::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var261(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 36
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_w_S_instructionVar262::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var262(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 36
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_w_D_instructionVar263::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var263(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 11
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                floor_l_S_instructionVar264::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var264(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 11
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                floor_l_D_instructionVar265::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var265(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 15
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                floor_w_S_instructionVar266::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var266(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 15
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                floor_w_D_instructionVar267::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var267(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 21
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                recip_S_instructionVar268::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var268(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 21
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                recip_D_instructionVar269::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var269(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 8
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                round_l_S_instructionVar270::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var270(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 8
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                round_l_D_instructionVar271::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var271(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 12
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                round_w_S_instructionVar272::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var272(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 12
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                round_w_D_instructionVar273::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var273(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 22
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                rsqrt_S_instructionVar274::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var274(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 22
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                rsqrt_D_instructionVar275::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var275(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 4
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                sqrt_S_instructionVar276::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var276(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 4
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                sqrt_D_instructionVar277::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var277(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 9
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                trunc_l_S_instructionVar278::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var278(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 9
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                trunc_l_D_instructionVar279::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var279(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 13
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                trunc_w_S_instructionVar280::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var280(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 13
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                trunc_w_D_instructionVar281::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var281(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                bc1f_instructionVar282::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var282(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 255) == 2
            && (tokens_param[3] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                bc1fl_instructionVar283::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var283(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 255) == 1
            && (tokens_param[3] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                bc1t_instructionVar284::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var284(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 255) == 3
            && (tokens_param[3] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                bc1tl_instructionVar285::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var285(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 71
        {
            if let Some((inst_len, parsed)) =
                di_instructionVar286::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var286(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 87
        {
            if let Some((inst_len, parsed)) =
                ei_instructionVar287::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var287(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 107
        {
            if let Some((inst_len, parsed)) =
                sync_instructionVar288::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var288(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 25
        {
            if let Some((inst_len, parsed)) =
                dvp_instructionVar289::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var289(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 57
        {
            if let Some((inst_len, parsed)) =
                evp_instructionVar290::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var290(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 3
        {
            if let Some((inst_len, parsed)) =
                abs_S_instructionVar291::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var291(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 35
        {
            if let Some((inst_len, parsed)) =
                abs_D_instructionVar292::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var292(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 19
        {
            if let Some((inst_len, parsed)) =
                ceil_l_S_instructionVar293::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var293(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 83
        {
            if let Some((inst_len, parsed)) =
                ceil_l_D_instructionVar294::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var294(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 27
        {
            if let Some((inst_len, parsed)) =
                ceil_w_S_instructionVar295::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var295(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 91
        {
            if let Some((inst_len, parsed)) =
                ceil_w_D_instructionVar296::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var296(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                cfc1_instructionVar297::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var297(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 205
        {
            if let Some((inst_len, parsed)) =
                cfc2_instructionVar298::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var298(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 75
        {
            if let Some((inst_len, parsed)) =
                clo_instructionVar299::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var299(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 91
        {
            if let Some((inst_len, parsed)) =
                clz_instructionVar300::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var300(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 24
        {
            if let Some((inst_len, parsed)) =
                ctc1_instructionVar301::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var301(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 221
        {
            if let Some((inst_len, parsed)) =
                ctc2_instructionVar302::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var302(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 19
        {
            if let Some((inst_len, parsed)) =
                cvt_d_S_instructionVar303::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var303(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 51
        {
            if let Some((inst_len, parsed)) =
                cvt_d_W_instructionVar304::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var304(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 83
        {
            if let Some((inst_len, parsed)) =
                cvt_d_L_instructionVar305::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var305(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 1
        {
            if let Some((inst_len, parsed)) =
                cvt_l_S_instructionVar306::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var306(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                cvt_l_D_instructionVar307::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var307(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 27
        {
            if let Some((inst_len, parsed)) =
                cvt_s_D_instructionVar308::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var308(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 59
        {
            if let Some((inst_len, parsed)) =
                cvt_s_W_instructionVar309::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var309(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 91
        {
            if let Some((inst_len, parsed)) =
                cvt_s_L_instructionVar310::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var310(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 9
        {
            if let Some((inst_len, parsed)) =
                cvt_w_S_instructionVar311::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var311(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                cvt_w_D_instructionVar312::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var312(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 3
        {
            if let Some((inst_len, parsed)) =
                floor_l_S_instructionVar313::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var313(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 67
        {
            if let Some((inst_len, parsed)) =
                floor_l_D_instructionVar314::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var314(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 11
        {
            if let Some((inst_len, parsed)) =
                floor_w_S_instructionVar315::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var315(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 75
        {
            if let Some((inst_len, parsed)) =
                floor_w_D_instructionVar316::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var316(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 32
        {
            if let Some((inst_len, parsed)) =
                mfc1_instructionVar317::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var317(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 77
        {
            if let Some((inst_len, parsed)) =
                mfc2_instructionVar318::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var318(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mfhc1_instructionVar319::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var319(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 141
        {
            if let Some((inst_len, parsed)) =
                mfhc2_instructionVar320::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var320(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                mov_S_instructionVar321::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var321(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 32
        {
            if let Some((inst_len, parsed)) =
                mov_D_instructionVar322::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var322(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 40
        {
            if let Some((inst_len, parsed)) =
                mtc1_instructionVar323::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var323(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 93
        {
            if let Some((inst_len, parsed)) =
                mtc2_instructionVar324::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var324(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 56
        {
            if let Some((inst_len, parsed)) =
                mthc1_instructionVar325::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var325(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 157
        {
            if let Some((inst_len, parsed)) =
                mthc2_instructionVar326::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var326(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 11
        {
            if let Some((inst_len, parsed)) =
                neg_S_instructionVar327::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var327(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 255) == 43
        {
            if let Some((inst_len, parsed)) =
                neg_D_instructionVar328::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var328(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 225
        {
            if let Some((inst_len, parsed)) =
                rdpgpr_instructionVar329::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var329(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 18
        {
            if let Some((inst_len, parsed)) =
                recip_S_instructionVar330::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var330(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 82
        {
            if let Some((inst_len, parsed)) =
                recip_D_instructionVar331::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var331(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 51
        {
            if let Some((inst_len, parsed)) =
                round_l_S_instructionVar332::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var332(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 115
        {
            if let Some((inst_len, parsed)) =
                round_l_D_instructionVar333::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var333(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 59
        {
            if let Some((inst_len, parsed)) =
                round_w_S_instructionVar334::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var334(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 123
        {
            if let Some((inst_len, parsed)) =
                round_w_D_instructionVar335::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var335(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 2
        {
            if let Some((inst_len, parsed)) =
                rsqrt_S_instructionVar336::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var336(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                rsqrt_D_instructionVar337::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var337(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 219
        {
            if let Some((inst_len, parsed)) =
                sdbbp_instructionVar338::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var338(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 43
        {
            if let Some((inst_len, parsed)) =
                seb_instructionVar339::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var339(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 59
        {
            if let Some((inst_len, parsed)) =
                seh_instructionVar340::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var340(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 10
        {
            if let Some((inst_len, parsed)) =
                sqrt_S_instructionVar341::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var341(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 74
        {
            if let Some((inst_len, parsed)) =
                sqrt_D_instructionVar342::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var342(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 139
        {
            if let Some((inst_len, parsed)) =
                syscall_instructionVar343::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var343(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 35
        {
            if let Some((inst_len, parsed)) =
                trunk_l_S_instructionVar344::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var344(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 99
        {
            if let Some((inst_len, parsed)) =
                trunk_l_D_instructionVar345::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var345(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 43
        {
            if let Some((inst_len, parsed)) =
                trunk_w_S_instructionVar346::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var346(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 255) == 107
        {
            if let Some((inst_len, parsed)) =
                trunk_w_D_instructionVar347::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var347(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 147
        {
            if let Some((inst_len, parsed)) =
                wait_instructionVar348::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var348(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 255) == 241
        {
            if let Some((inst_len, parsed)) =
                wrpgpr_instructionVar349::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var349(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 255) == 123
        {
            if let Some((inst_len, parsed)) =
                wsbh_instructionVar350::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var350(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar351::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var351(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 62) == 8
            && (tokens_param[1] & 252) == 4
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                jr_hb_instructionVar352::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var352(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 9
            && (tokens_param[1] & 252) == 252
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                jalr_hb_instructionVar353::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var353(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 62) == 8
            && (tokens_param[1] & 248) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                jr_instructionVar354::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var354(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 9
            && (tokens_param[1] & 248) == 248
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                jalr_instructionVar355::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var355(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 9
            && (tokens_param[1] & 4) == 4
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                jalr_hb_instructionVar356::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var356(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 9
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                jalr_instructionVar357::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var357(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 17
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                bgezal_instructionVar358::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var358(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 19
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                bgezall_instructionVar359::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var359(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 3
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                bgezl_instructionVar360::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var360(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 92
        {
            if let Some((inst_len, parsed)) =
                bgtzl_instructionVar361::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var361(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 88
        {
            if let Some((inst_len, parsed)) =
                blezl_instructionVar362::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var362(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 16
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                bltzal_instructionVar363::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var363(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 18
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                bltzall_instructionVar364::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var364(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 2
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                bltzl_instructionVar365::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var365(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 12
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                teqi_instructionVar366::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var366(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 8
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                tgei_instructionVar367::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var367(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 9
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                tgeiu_instructionVar368::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var368(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 10
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                tlti_instructionVar369::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var369(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 11
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                tltiu_instructionVar370::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var370(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 31) == 14
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                tnei_instructionVar371::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var371(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 31) == 31
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                aluipc_instructionVar372::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var372(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 31) == 30
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                auipc_instructionVar373::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var373(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 255) == 28
            && (tokens_param[3] & 255) == 4
        {
            if let Some((inst_len, parsed)) =
                bposge32_instructionVar374::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var374(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 255) == 26
            && (tokens_param[3] & 255) == 4
        {
            if let Some((inst_len, parsed)) =
                bposge32c_instructionVar375::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var375(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 31) == 1
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                bgez_instructionVar376::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var376(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 28
        {
            if let Some((inst_len, parsed)) =
                bgtz_instructionVar377::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var377(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 24
        {
            if let Some((inst_len, parsed)) =
                blez_instructionVar378::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var378(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                bltz_instructionVar379::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var379(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 138
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lbx_instructionVar380::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var380(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lhux_instructionVar381::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var381(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 39
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                nor_instructionVar382::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var382(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 37
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                or_instructionVar383::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var383(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                rotrv_instructionVar384::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var384(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                sllv_instructionVar385::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var385(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 42
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                slt_instructionVar386::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var386(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 43
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                sltu_instructionVar387::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var387(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 7
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                srav_instructionVar388::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var388(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                srlv_instructionVar389::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var389(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 34
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar390::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var390(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 35
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                subu_instructionVar391::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var391(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 38
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                xor_instructionVar392::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var392(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 44
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                dadd_instructionVar393::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var393(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 45
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                daddu_instructionVar394::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var394(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 127) == 25
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lwle_instructionVar395::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var395(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 127) == 26
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lwre_instructionVar396::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var396(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 127) == 33
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                swle_instructionVar397::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var397(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 127) == 34
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                swre_instructionVar398::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var398(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 127) == 54
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                ll_instructionVar399::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var399(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 127) == 118
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                llx_instructionVar400::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var400(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 127) == 103
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                llxe_instructionVar401::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var401(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 127) == 102
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                scx_instructionVar402::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var402(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 127) == 94
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                scxe_instructionVar403::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var403(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 144
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addq_ph_instructionVar404::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var404(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 144
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addq_s_ph_instructionVar405::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var405(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 144
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addq_s_w_instructionVar406::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var406(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addqh_ph_instructionVar407::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var407(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 152
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addqh_r_ph_instructionVar408::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var408(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addqh_w_instructionVar409::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var409(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 152
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addqh_r_w_instructionVar410::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var410(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addsc_instructionVar411::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var411(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addu_ph_instructionVar412::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var412(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addu_s_ph_instructionVar413::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var413(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addu_qb_instructionVar414::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var414(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addu_s_qb_instructionVar415::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var415(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addwc_instructionVar416::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var416(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                adduh_qb_instructionVar417::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var417(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 152
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                adduh_r_qb_instructionVar418::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var418(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 49
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                append_instructionVar419::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var419(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = cmpgdu_eq_qb_instructionVar420::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var420(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = cmpgdu_lt_qb_instructionVar421::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var421(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 145
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = cmpgdu_le_qb_instructionVar422::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var422(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cmpgu_eq_qb_instructionVar423::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var423(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cmpgu_lt_qb_instructionVar424::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var424(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 145
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cmpgu_le_qb_instructionVar425::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var425(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 138
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lbux_instructionVar426::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var426(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lhx_instructionVar427::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var427(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lwx_instructionVar428::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var428(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 144
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                modsub_instructionVar429::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var429(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mul_ph_instructionVar430::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var430(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 152
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mul_s_ph_instructionVar431::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var431(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = muleq_s_w_phl_instructionVar432::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var432(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = muleq_s_w_phr_instructionVar433::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var433(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 144
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = muleu_s_ph_qbl_instructionVar434::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var434(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 208
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = muleu_s_ph_qbr_instructionVar435::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var435(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 208
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulq_rs_ph_instructionVar436::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var436(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 216
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulq_rs_w_instructionVar437::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var437(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 144
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulq_s_ph_instructionVar438::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var438(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 152
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulq_s_w_instructionVar439::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var439(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 145
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                packrl_ph_instructionVar440::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var440(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 209
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                pick_ph_instructionVar441::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var441(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 209
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                pick_qb_instructionVar442::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var442(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                precr_qb_ph_instructionVar443::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var443(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 145
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = precr_sra_ph_w_instructionVar444::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var444(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 209
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = precr_sra_r_ph_w_instructionVar445::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var445(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                precrq_ph_w_instructionVar446::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var446(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = precrq_qb_ph_instructionVar447::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var447(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 209
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = precrqu_s_qb_ph_instructionVar448::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var448(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) = precrq_rs_ph_w_instructionVar449::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var449(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 113
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                prepend_instructionVar450::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var450(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 184
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                rddsp_instructionVar451::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var451(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 146
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                repl_ph_instructionVar452::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var452(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 19
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shll_qb_instructionVar453::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var453(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 147
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shllv_ph_instructionVar454::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var454(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 147
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shllv_s_ph_instructionVar455::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var455(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 147
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shllv_qb_instructionVar456::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var456(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 147
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shllv_s_w_instructionVar457::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var457(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 19
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shll_s_w_instructionVar458::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var458(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 19
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shra_qb_instructionVar459::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var459(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 83
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shra_r_qb_instructionVar460::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var460(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 211
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shrav_ph_instructionVar461::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var461(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 211
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shrav_r_ph_instructionVar462::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var462(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 147
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shrav_qb_instructionVar463::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var463(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 211
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shrav_r_qb_instructionVar464::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var464(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 211
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shrav_r_w_instructionVar465::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var465(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 83
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shra_r_w_instructionVar466::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var466(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 83
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shrl_qb_instructionVar467::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var467(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 211
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shrlv_ph_instructionVar468::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var468(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 211
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                shrlv_qb_instructionVar469::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var469(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 208
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subq_ph_instructionVar470::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var470(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 208
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subq_s_ph_instructionVar471::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var471(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 208
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subq_s_w_instructionVar472::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var472(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 88
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subqh_ph_instructionVar473::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var473(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 216
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subqh_r_ph_instructionVar474::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var474(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 88
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subqh_w_instructionVar475::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var475(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 216
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subqh_r_w_instructionVar476::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var476(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subu_ph_instructionVar477::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var477(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subu_s_ph_instructionVar478::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var478(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subu_qb_instructionVar479::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var479(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subu_s_qb_instructionVar480::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var480(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 88
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subuh_qb_instructionVar481::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var481(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 216
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subuh_r_qb_instructionVar482::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var482(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 255) == 248
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                wrdsp_instructionVar483::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var483(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 127) == 27
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cachee_instructionVar484::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var484(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 127) == 44
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lbe_instructionVar485::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var485(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 127) == 40
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lbue_instructionVar486::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var486(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 127) == 45
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lhe_instructionVar487::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var487(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 127) == 41
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lhue_instructionVar488::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var488(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 127) == 46
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lle_instructionVar489::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var489(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 127) == 47
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lwe_instructionVar490::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var490(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 127) == 35
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                prefe_instructionVar491::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var491(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 59
            && (tokens_param[1] & 254) == 32
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                rdhwr_instructionVar492::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var492(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 17
            && (tokens_param[2] & 227) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                movf_S_instructionVar493::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var493(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 17
            && (tokens_param[2] & 227) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                movf_D_instructionVar494::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var494(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 17
            && (tokens_param[2] & 227) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                movf_PS_instructionVar495::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var495(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 17
            && (tokens_param[2] & 227) == 1
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                movt_S_instructionVar496::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var496(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 17
            && (tokens_param[2] & 227) == 33
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                movt_D_instructionVar497::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var497(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 17
            && (tokens_param[2] & 227) == 193
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                movt_PS_instructionVar498::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var498(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 44
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                pll_ps_instructionVar499::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var499(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 45
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                plu_ps_instructionVar500::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var500(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 46
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                pul_ps_instructionVar501::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var501(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 47
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                puu_ps_instructionVar502::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var502(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 5
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                abs_PS_instructionVar503::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var503(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 0
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                add_PS_instructionVar504::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var504(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 38
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cvt_PS_S_instructionVar505::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var505(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 6
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                mov_PS_instructionVar506::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var506(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 2
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                mul_PS_instructionVar507::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var507(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 7
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                neg_PS_instructionVar508::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var508(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 1
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                sub_PS_instructionVar509::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var509(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 48
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_f_S_instructionVar510::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var510(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 48
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_f_D_instructionVar511::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var511(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 48
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_f_PS_instructionVar512::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var512(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 49
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_un_S_instructionVar513::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var513(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 49
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_un_D_instructionVar514::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var514(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 49
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_un_PS_instructionVar515::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var515(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 50
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_eq_S_instructionVar516::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var516(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 50
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_eq_D_instructionVar517::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var517(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 50
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_eq_PS_instructionVar518::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var518(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 51
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ueq_S_instructionVar519::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var519(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 51
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ueq_D_instructionVar520::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var520(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 51
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ueq_PS_instructionVar521::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var521(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 52
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_olt_S_instructionVar522::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var522(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 52
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_olt_D_instructionVar523::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var523(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 52
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_olt_PS_instructionVar524::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var524(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 53
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ult_S_instructionVar525::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var525(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 53
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ult_D_instructionVar526::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var526(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 53
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ult_PS_instructionVar527::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var527(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 54
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ole_S_instructionVar528::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var528(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 54
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ole_D_instructionVar529::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var529(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 54
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ole_PS_instructionVar530::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var530(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 55
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ule_S_instructionVar531::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var531(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 55
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ule_D_instructionVar532::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var532(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 55
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ule_PS_instructionVar533::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var533(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 56
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_sf_S_instructionVar534::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var534(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 56
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_sf_D_instructionVar535::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var535(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 56
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_sf_PS_instructionVar536::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var536(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 57
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ngle_S_instructionVar537::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var537(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 57
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ngle_D_instructionVar538::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var538(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 57
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ngle_PS_instructionVar539::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var539(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 58
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_seq_S_instructionVar540::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var540(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 58
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_seq_D_instructionVar541::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var541(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 58
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_seq_PS_instructionVar542::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var542(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 59
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ngl_S_instructionVar543::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var543(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 59
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ngl_D_instructionVar544::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var544(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 59
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ngl_PS_instructionVar545::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var545(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 60
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_lt_S_instructionVar546::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var546(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 60
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_lt_D_instructionVar547::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var547(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 60
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_lt_PS_instructionVar548::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var548(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 61
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_nge_S_instructionVar549::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var549(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 61
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_nge_D_instructionVar550::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var550(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 61
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_nge_PS_instructionVar551::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var551(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 62
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_le_S_instructionVar552::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var552(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 62
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_le_D_instructionVar553::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var553(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 62
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_le_PS_instructionVar554::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var554(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 63
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ngt_S_instructionVar555::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var555(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 63
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ngt_D_instructionVar556::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var556(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 63
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                c_ngt_PS_instructionVar557::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var557(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 19
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                movn_S_instructionVar558::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var558(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 19
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                movn_D_instructionVar559::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var559(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 19
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                movn_PS_instructionVar560::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var560(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 18
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                movz_S_instructionVar561::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var561(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 18
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                movz_D_instructionVar562::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var562(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 18
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                movz_PS_instructionVar563::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var563(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 16
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                sel_S_instructionVar564::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var564(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 16
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                sel_D_instructionVar565::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var565(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 0
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_af_S_instructionVar566::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var566(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 0
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_af_D_instructionVar567::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var567(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 1
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_un_S_instructionVar568::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var568(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 1
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_un_D_instructionVar569::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var569(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 17
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_or_S_instructionVar570::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var570(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 17
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_or_D_instructionVar571::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var571(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 2
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_eq_S_instructionVar572::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var572(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 2
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_eq_D_instructionVar573::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var573(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 18
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_une_S_instructionVar574::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var574(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 18
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_une_D_instructionVar575::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var575(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 3
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_ueq_S_instructionVar576::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var576(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 3
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_ueq_D_instructionVar577::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var577(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 19
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_ne_S_instructionVar578::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var578(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 19
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_ne_D_instructionVar579::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var579(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 4
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_lt_S_instructionVar580::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var580(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 4
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_lt_D_instructionVar581::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var581(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 5
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_ult_S_instructionVar582::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var582(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 5
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_ult_D_instructionVar583::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var583(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 6
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_le_S_instructionVar584::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var584(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 6
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_le_D_instructionVar585::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var585(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 7
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_ule_S_instructionVar586::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var586(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 7
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_ule_D_instructionVar587::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var587(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 8
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_saf_S_instructionVar588::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var588(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 8
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_saf_D_instructionVar589::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var589(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 9
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sun_S_instructionVar590::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var590(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 9
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sun_D_instructionVar591::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var591(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 25
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sor_S_instructionVar592::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var592(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 25
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sor_D_instructionVar593::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var593(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 10
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_seq_S_instructionVar594::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var594(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 10
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_seq_D_instructionVar595::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var595(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 26
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sune_S_instructionVar596::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var596(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 26
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sune_D_instructionVar597::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var597(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 11
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sueq_S_instructionVar598::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var598(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 11
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sueq_D_instructionVar599::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var599(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 27
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sne_S_instructionVar600::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var600(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 27
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sne_D_instructionVar601::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var601(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 12
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_slt_S_instructionVar602::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var602(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 12
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_slt_D_instructionVar603::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var603(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 13
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sult_S_instructionVar604::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var604(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 13
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sult_D_instructionVar605::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var605(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 14
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sle_S_instructionVar606::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var606(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 14
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sle_D_instructionVar607::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var607(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 15
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sule_S_instructionVar608::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var608(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 15
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                cmp_sule_D_instructionVar609::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var609(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 2
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                rotr_instructionVar610::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var610(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 127) == 28
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                sbe_instructionVar611::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var611(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 127) == 30
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                sce_instructionVar612::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var612(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 127) == 29
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                she_instructionVar613::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var613(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                sll_instructionVar614::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var614(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 3
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                sra_instructionVar615::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var615(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 2
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                srl_instructionVar616::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var616(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 127) == 31
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                swe_instructionVar617::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var617(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 5
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                abs_S_instructionVar618::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var618(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 5
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                abs_D_instructionVar619::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var619(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                add_S_instructionVar620::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var620(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 0
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                add_D_instructionVar621::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var621(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 3
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                div_S_instructionVar622::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var622(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 3
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                div_D_instructionVar623::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var623(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 6
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                mov_S_instructionVar624::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var624(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 6
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                mov_D_instructionVar625::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var625(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 2
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                mul_S_instructionVar626::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var626(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 2
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                mul_D_instructionVar627::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var627(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 7
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                neg_S_instructionVar628::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var628(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 7
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                neg_D_instructionVar629::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var629(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 1
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                sub_S_instructionVar630::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var630(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 1
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                sub_D_instructionVar631::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var631(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 32
            && (tokens_param[3] & 254) == 66
        {
            if let Some((inst_len, parsed)) =
                wait_instructionVar632::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var632(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 32
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                align_instructionVar633::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var633(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[0] & 63) == 5
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                lsa_instructionVar634::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var634(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 1
            && (tokens_param[1] & 248) == 0
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                ldxc1_instructionVar635::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var635(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 5
            && (tokens_param[1] & 248) == 0
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                luxc1_instructionVar636::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var636(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 0
            && (tokens_param[1] & 248) == 0
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                lwxc1_instructionVar637::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var637(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 30
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                alnv_PS_instructionVar638::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var638(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 32
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                madd_S_instructionVar639::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var639(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 33
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                madd_D_instructionVar640::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var640(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 38
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                madd_PS_instructionVar641::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var641(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 40
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                msub_S_instructionVar642::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var642(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 41
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                msub_D_instructionVar643::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var643(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 46
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                msub_PS_instructionVar644::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var644(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 48
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                nmadd_S_instructionVar645::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var645(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 49
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                nmadd_D_instructionVar646::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var646(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 54
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                nmadd_PS_instructionVar647::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var647(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 56
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                nmsub_S_instructionVar648::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var648(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 57
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                nmsub_D_instructionVar649::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var649(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 62
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                nmsub_PS_instructionVar650::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var650(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[0] & 63) == 13
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                suxc1_instructionVar651::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var651(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 13
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                break_instructionVar652::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var652(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 227) == 0
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                bc2f_instructionVar653::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var653(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 227) == 2
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                bc2fl_instructionVar654::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var654(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 227) == 1
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                bc2t_instructionVar655::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var655(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 227) == 3
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                bc2tl_instructionVar656::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var656(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 227) == 0
            && (tokens_param[3] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                bc1f_instructionVar657::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var657(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 227) == 2
            && (tokens_param[3] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                bc1fl_instructionVar658::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var658(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 227) == 1
            && (tokens_param[3] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                bc1t_instructionVar659::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var659(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 227) == 3
            && (tokens_param[3] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                bc1tl_instructionVar660::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var660(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 60
        {
            if let Some((inst_len, parsed)) =
                lui_instructionVar661::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var661(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870915 == 1
            && (tokens_param[3] & 252) == 136
        {
            if let Some((inst_len, parsed)) =
                lwl_instructionVar662::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var662(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870915 == 1
            && (tokens_param[3] & 252) == 152
        {
            if let Some((inst_len, parsed)) =
                lwr_instructionVar663::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var663(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870915 == 1
            && (tokens_param[3] & 252) == 168
        {
            if let Some((inst_len, parsed)) =
                swl_instructionVar664::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var664(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870915 == 1
            && (tokens_param[3] & 252) == 184
        {
            if let Some((inst_len, parsed)) =
                swr_instructionVar665::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var665(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 24) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                addiupc_instructionVar666::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var666(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                bc2eqz_instructionVar667::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var667(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                bc2nez_instructionVar668::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var668(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 24
        {
            if let Some((inst_len, parsed)) =
                blezalc_instructionVar669::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var669(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 28
        {
            if let Some((inst_len, parsed)) =
                bgtzalc_instructionVar670::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var670(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 32
        {
            if let Some((inst_len, parsed)) =
                beqc_instructionVar671::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var671(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 96
        {
            if let Some((inst_len, parsed)) =
                bnec_instructionVar672::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var672(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 248
        {
            if let Some((inst_len, parsed)) =
                jialc_instructionVar673::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var673(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 216
        {
            if let Some((inst_len, parsed)) =
                jic_instructionVar674::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var674(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                ldc2_instructionVar675::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var675(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 255) == 73
        {
            if let Some((inst_len, parsed)) =
                lwc2_instructionVar676::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var676(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 24) == 8
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                lwpc_instructionVar677::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var677(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                bc1eqz_instructionVar678::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var678(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[2] & 224) == 160
            && (tokens_param[3] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                bc1nez_instructionVar679::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var679(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 100
        {
            if let Some((inst_len, parsed)) =
                lwle_instructionVar680::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var680(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 102
        {
            if let Some((inst_len, parsed)) =
                lwre_instructionVar681::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var681(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 160
        {
            if let Some((inst_len, parsed)) =
                swle_instructionVar682::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var682(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 162
        {
            if let Some((inst_len, parsed)) =
                swre_instructionVar683::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var683(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 32
            && (tokens_param[3] & 254) == 96
        {
            if let Some((inst_len, parsed)) =
                cache_instructionVar684::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var684(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 16
        {
            if let Some((inst_len, parsed)) =
                llx_instructionVar685::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var685(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 100
        {
            if let Some((inst_len, parsed)) =
                llxe_instructionVar686::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var686(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 144
        {
            if let Some((inst_len, parsed)) =
                scx_instructionVar687::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var687(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 160
        {
            if let Some((inst_len, parsed)) =
                scxe_instructionVar688::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var688(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 60) == 60 {
            if let Some((inst_len, parsed)) =
                cache_instructionVar689::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var689(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 248) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                mfc0_instructionVar690::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var690(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 248) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                mtc0_instructionVar691::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var691(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 248) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                mthc0_instructionVar692::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var692(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 255) == 72
        {
            if let Some((inst_len, parsed)) =
                cfc2_instructionVar693::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var693(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 255) == 72
        {
            if let Some((inst_len, parsed)) =
                ctc2_instructionVar694::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var694(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 72
        {
            if let Some((inst_len, parsed)) =
                mfc2_instructionVar695::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var695(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 224) == 96
            && (tokens_param[3] & 255) == 72
        {
            if let Some((inst_len, parsed)) =
                mfhc2_instructionVar696::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var696(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 36
        {
            if let Some((inst_len, parsed)) =
                li_instructionVar697::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var697(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 224) == 128
            && (tokens_param[3] & 255) == 72
        {
            if let Some((inst_len, parsed)) =
                mtc2_instructionVar698::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var698(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 224) == 224
            && (tokens_param[3] & 255) == 72
        {
            if let Some((inst_len, parsed)) =
                mthc2_instructionVar699::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var699(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 166
        {
            if let Some((inst_len, parsed)) =
                cachee_instructionVar700::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var700(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 104
        {
            if let Some((inst_len, parsed)) =
                lbe_instructionVar701::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var701(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 96
        {
            if let Some((inst_len, parsed)) =
                lbue_instructionVar702::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var702(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 106
        {
            if let Some((inst_len, parsed)) =
                lhe_instructionVar703::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var703(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 98
        {
            if let Some((inst_len, parsed)) =
                lhue_instructionVar704::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var704(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 48
        {
            if let Some((inst_len, parsed)) =
                ll_instructionVar705::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var705(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 108
        {
            if let Some((inst_len, parsed)) =
                lle_instructionVar706::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var706(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 110
        {
            if let Some((inst_len, parsed)) =
                lwe_instructionVar707::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var707(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 64
        {
            if let Some((inst_len, parsed)) =
                pref_instructionVar708::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var708(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 164
        {
            if let Some((inst_len, parsed)) =
                prefe_instructionVar709::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var709(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 168
        {
            if let Some((inst_len, parsed)) =
                sbe_instructionVar710::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var710(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 176
        {
            if let Some((inst_len, parsed)) =
                sc_instructionVar711::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var711(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 172
        {
            if let Some((inst_len, parsed)) =
                sce_instructionVar712::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var712(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 170
        {
            if let Some((inst_len, parsed)) =
                she_instructionVar713::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var713(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 254) == 174
        {
            if let Some((inst_len, parsed)) =
                swe_instructionVar714::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var714(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 254) == 74 {
            if let Some((inst_len, parsed)) =
                cop2_instructionVar715::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var715(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                ext_instructionVar716::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var716(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                ins_instructionVar717::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var717(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 63
            && (tokens_param[3] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                sdbbp_instructionVar718::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var718(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[2] & 31) == 31
            && (tokens_param[3] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                synci_instructionVar719::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var719(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 12
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                syscall_instructionVar720::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var720(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 52
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar721::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var721(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 48
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                tge_instructionVar722::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var722(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 49
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                tgeu_instructionVar723::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var723(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 50
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                tlt_instructionVar724::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var724(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 51
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                tltu_instructionVar725::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var725(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 2 == 0
            && (tokens_param[0] & 63) == 54
            && (tokens_param[3] & 252) == 0
        {
            if let Some((inst_len, parsed)) =
                tne_instructionVar726::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var726(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 32
        {
            if let Some((inst_len, parsed)) =
                addi_instructionVar727::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var727(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 80
        {
            if let Some((inst_len, parsed)) =
                beql_instructionVar728::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var728(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 84
        {
            if let Some((inst_len, parsed)) =
                bnel_instructionVar729::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var729(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 116
        {
            if let Some((inst_len, parsed)) =
                jalx_instructionVar730::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var730(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 216
        {
            if let Some((inst_len, parsed)) =
                ldc2_instructionVar731::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var731(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 192
        {
            if let Some((inst_len, parsed)) =
                ll_instructionVar732::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var732(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 200
        {
            if let Some((inst_len, parsed)) =
                lwc2_instructionVar733::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var733(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 136
        {
            if let Some((inst_len, parsed)) =
                lwl_instructionVar734::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var734(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 152
        {
            if let Some((inst_len, parsed)) =
                lwr_instructionVar735::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var735(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 224
        {
            if let Some((inst_len, parsed)) =
                sc_instructionVar736::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var736(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 168
        {
            if let Some((inst_len, parsed)) =
                swl_instructionVar737::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var737(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 184
        {
            if let Some((inst_len, parsed)) =
                swr_instructionVar738::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var738(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 0
            && (tokens_param[3] & 252) == 96
        {
            if let Some((inst_len, parsed)) =
                daddi_instructionVar739::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var739(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 60
        {
            if let Some((inst_len, parsed)) =
                aui_instructionVar740::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var740(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 232
        {
            if let Some((inst_len, parsed)) =
                balc_instructionVar741::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var741(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 200
        {
            if let Some((inst_len, parsed)) =
                bc_instructionVar742::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var742(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 32
        {
            if let Some((inst_len, parsed)) =
                bovc_instructionVar743::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var743(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 96
        {
            if let Some((inst_len, parsed)) =
                bnvc_instructionVar744::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var744(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 88
        {
            if let Some((inst_len, parsed)) =
                bgec_instructionVar745::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var745(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 92
        {
            if let Some((inst_len, parsed)) =
                bltc_instructionVar746::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var746(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 216
        {
            if let Some((inst_len, parsed)) =
                beqzc_instructionVar747::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var747(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 536870914 == 536870912
            && (tokens_param[3] & 252) == 248
        {
            if let Some((inst_len, parsed)) =
                bnezc_instructionVar748::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var748(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 36 {
            if let Some((inst_len, parsed)) =
                addiu_instructionVar749::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var749(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 48 {
            if let Some((inst_len, parsed)) =
                andi_instructionVar750::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var750(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 16 {
            if let Some((inst_len, parsed)) =
                beq_instructionVar751::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var751(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 20 {
            if let Some((inst_len, parsed)) =
                bne_instructionVar752::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var752(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 112 {
            if let Some((inst_len, parsed)) =
                SPECIAL2_instructionVar753::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var753(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 8 {
            if let Some((inst_len, parsed)) =
                j_instructionVar754::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var754(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 12 {
            if let Some((inst_len, parsed)) =
                jal_instructionVar755::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var755(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 128 {
            if let Some((inst_len, parsed)) =
                lb_instructionVar756::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var756(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 144 {
            if let Some((inst_len, parsed)) =
                lbu_instructionVar757::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var757(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 132 {
            if let Some((inst_len, parsed)) =
                lh_instructionVar758::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var758(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 148 {
            if let Some((inst_len, parsed)) =
                lhu_instructionVar759::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var759(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 140 {
            if let Some((inst_len, parsed)) =
                lw_instructionVar760::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var760(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 52 {
            if let Some((inst_len, parsed)) =
                ori_instructionVar761::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var761(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 204 {
            if let Some((inst_len, parsed)) =
                pref_instructionVar762::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var762(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 160 {
            if let Some((inst_len, parsed)) =
                sb_instructionVar763::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var763(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 248 {
            if let Some((inst_len, parsed)) =
                sdc2_instructionVar764::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var764(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 164 {
            if let Some((inst_len, parsed)) =
                sh_instructionVar765::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var765(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 40 {
            if let Some((inst_len, parsed)) =
                slti_instructionVar766::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var766(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 44 {
            if let Some((inst_len, parsed)) =
                sltiu_instructionVar767::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var767(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 172 {
            if let Some((inst_len, parsed)) =
                sw_instructionVar768::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var768(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 232 {
            if let Some((inst_len, parsed)) =
                swc2_instructionVar769::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var769(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 56 {
            if let Some((inst_len, parsed)) =
                xori_instructionVar770::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var770(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 100 {
            if let Some((inst_len, parsed)) =
                daddiu_instructionVar771::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var771(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 212 {
            if let Some((inst_len, parsed)) =
                ldc1_instructionVar772::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var772(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 244 {
            if let Some((inst_len, parsed)) =
                sdc1_instructionVar773::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var773(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 196 {
            if let Some((inst_len, parsed)) =
                lwc1_instructionVar774::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var774(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2 == 0 && (tokens_param[3] & 252) == 228 {
            if let Some((inst_len, parsed)) =
                swc1_instructionVar775::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var775(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 301989894 == 268435458
            && (tokens_param[1] & 248) == 240
        {
            if let Some((inst_len, parsed)) =
                instructionVar776::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var776(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 301989894 == 268435458
            && (tokens_param[1] & 248) == 24
        {
            if let Some((inst_len, parsed)) =
                instructionVar777::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var777(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268451846 == 268435458
            && (tokens_param[1] & 255) == 99
        {
            if let Some((inst_len, parsed)) =
                addiu_instructionVar778::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var778(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268451846 == 268451842
            && (tokens_param[1] & 255) == 99
        {
            if let Some((inst_len, parsed)) =
                addiu_instructionVar779::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var779(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268451846 == 268435458
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 248) == 224
        {
            if let Some((inst_len, parsed)) =
                addu_instructionVar780::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var780(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268451846 == 268435458
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 248) == 224
        {
            if let Some((inst_len, parsed)) =
                subu_instructionVar781::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var781(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268451846 == 268435458
            && (tokens_param[1] & 248) == 8
        {
            if let Some((inst_len, parsed)) =
                addiu_instructionVar782::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var782(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268451846 == 268451842
            && (tokens_param[1] & 248) == 8
        {
            if let Some((inst_len, parsed)) =
                addiu_instructionVar783::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var783(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 255) == 232
        {
            if let Some((inst_len, parsed)) =
                jr_instructionVar784::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var784(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 160
            && (tokens_param[1] & 255) == 232
        {
            if let Some((inst_len, parsed)) =
                jrc_instructionVar785::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var785(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 101
        {
            if let Some((inst_len, parsed)) =
                nop_instructionVar786::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var786(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                jalr_instructionVar787::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var787(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 192
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                jalrc_instructionVar788::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var788(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                jr_instructionVar789::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var789(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 128
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                jrc_instructionVar790::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var790(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                mfhi_instructionVar791::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var791(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 18
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                mflo_instructionVar792::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var792(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 145
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                seb_instructionVar793::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var793(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 177
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                seh_instructionVar794::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var794(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                zeb_instructionVar795::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var795(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 255) == 49
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                zeh_instructionVar796::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var796(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 12
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar797::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var797(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 5
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                break_instructionVar798::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var798(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 10
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar799::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var799(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 26
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                div_instructionVar800::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var800(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 27
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                divu_instructionVar801::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var801(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 24
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                mult_instructionVar802::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var802(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 25
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                multu_instructionVar803::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var803(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 11
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                neg_instructionVar804::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var804(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 15
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                not_instructionVar805::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var805(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 13
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                or_instructionVar806::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var806(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 1
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                sdbbp_instructionVar807::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var807(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 4
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                sllv_instructionVar808::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var808(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 2
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                slt_instructionVar809::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var809(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 3
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                sltu_instructionVar810::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var810(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 7
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                srav_instructionVar811::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var811(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 6
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                srlv_instructionVar812::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var812(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 31) == 14
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                xor_instructionVar813::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var813(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 16) == 0
            && (tokens_param[1] & 248) == 64
        {
            if let Some((inst_len, parsed)) =
                addiu_instructionVar814::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var814(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268451846 == 268435458
            && (tokens_param[1] & 248) == 0
        {
            if let Some((inst_len, parsed)) =
                addiu_instructionVar815::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var815(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268451846 == 268451842
            && (tokens_param[1] & 248) == 0
        {
            if let Some((inst_len, parsed)) =
                addiu_instructionVar816::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var816(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268451846 == 268451842
            && (tokens_param[1] & 248) == 224
        {
            if let Some((inst_len, parsed)) =
                asmacro_instructionVar817::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var817(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 128) == 0
            && (tokens_param[1] & 255) == 100
        {
            if let Some((inst_len, parsed)) =
                restore_instructionVar818::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var818(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 128) == 128
            && (tokens_param[1] & 255) == 100
        {
            if let Some((inst_len, parsed)) =
                save_instructionVar819::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var819(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 255) == 96
        {
            if let Some((inst_len, parsed)) =
                bteqz_instructionVar820::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var820(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 255) == 97
        {
            if let Some((inst_len, parsed)) =
                btnez_instructionVar821::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var821(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268451846 == 268435458
            && (tokens_param[1] & 248) == 112
        {
            if let Some((inst_len, parsed)) =
                cmpi_instructionVar822::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var822(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268451846 == 268451842
            && (tokens_param[1] & 248) == 112
        {
            if let Some((inst_len, parsed)) =
                cmpi_instructionVar823::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var823(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 255) == 101
        {
            if let Some((inst_len, parsed)) =
                move_instructionVar824::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var824(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 255) == 103
        {
            if let Some((inst_len, parsed)) =
                move_instructionVar825::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var825(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 248) == 48
        {
            if let Some((inst_len, parsed)) =
                sll_instructionVar826::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var826(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 248) == 48
        {
            if let Some((inst_len, parsed)) =
                sra_instructionVar827::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var827(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 248) == 48
        {
            if let Some((inst_len, parsed)) =
                srl_instructionVar828::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var828(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 255) == 98
        {
            if let Some((inst_len, parsed)) =
                sw_instructionVar829::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var829(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 72
        {
            if let Some((inst_len, parsed)) =
                addiu_instructionVar830::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var830(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 16
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar831::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var831(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 32
        {
            if let Some((inst_len, parsed)) =
                beqz_instructionVar832::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var832(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 40
        {
            if let Some((inst_len, parsed)) =
                bnez_instructionVar833::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var833(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 268443654 == 268435462 {
            if let Some((inst_len, parsed)) =
                jal_instructionVar834::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var834(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 268443654 == 268443654 {
            if let Some((inst_len, parsed)) =
                jalx_instructionVar835::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var835(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                lb_instructionVar836::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var836(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 160
        {
            if let Some((inst_len, parsed)) =
                lbu_instructionVar837::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var837(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                lh_instructionVar838::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var838(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 168
        {
            if let Some((inst_len, parsed)) =
                lhu_instructionVar839::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var839(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 104
        {
            if let Some((inst_len, parsed)) =
                li_instructionVar840::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var840(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                lw_instructionVar841::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var841(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 176
        {
            if let Some((inst_len, parsed)) =
                lw_instructionVar842::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var842(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                lw_instructionVar843::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var843(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                sb_instructionVar844::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var844(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 200
        {
            if let Some((inst_len, parsed)) =
                sh_instructionVar845::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var845(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 80
        {
            if let Some((inst_len, parsed)) =
                slti_instructionVar846::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var846(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 88
        {
            if let Some((inst_len, parsed)) =
                sltiu_instructionVar847::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var847(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 216
        {
            if let Some((inst_len, parsed)) =
                sw_instructionVar848::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var848(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435462 == 268435458
            && (tokens_param[1] & 248) == 208
        {
            if let Some((inst_len, parsed)) =
                sw_instructionVar849::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var849(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 191) == 33
        {
            if let Some((inst_len, parsed)) =
                cvt_s_PL_instructionVar850::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var850(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 59
            && (tokens_param[3] & 191) == 41
        {
            if let Some((inst_len, parsed)) =
                cvt_s_PU_instructionVar851::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var851(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 31) == 0
        {
            if let Some((inst_len, parsed)) =
                c_f_S_instructionVar852::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var852(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 31) == 4
        {
            if let Some((inst_len, parsed)) =
                c_f_D_instructionVar853::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var853(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 31) == 8
        {
            if let Some((inst_len, parsed)) =
                c_f_PS_instructionVar854::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var854(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 31) == 0
        {
            if let Some((inst_len, parsed)) =
                c_un_S_instructionVar855::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var855(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 31) == 4
        {
            if let Some((inst_len, parsed)) =
                c_un_D_instructionVar856::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var856(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 31) == 8
        {
            if let Some((inst_len, parsed)) =
                c_un_PS_instructionVar857::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var857(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 188
            && (tokens_param[3] & 31) == 0
        {
            if let Some((inst_len, parsed)) =
                c_eq_S_instructionVar858::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var858(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 188
            && (tokens_param[3] & 31) == 4
        {
            if let Some((inst_len, parsed)) =
                c_eq_D_instructionVar859::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var859(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 188
            && (tokens_param[3] & 31) == 8
        {
            if let Some((inst_len, parsed)) =
                c_eq_PS_instructionVar860::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var860(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 31) == 0
        {
            if let Some((inst_len, parsed)) =
                c_ueq_S_instructionVar861::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var861(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 31) == 4
        {
            if let Some((inst_len, parsed)) =
                c_ueq_D_instructionVar862::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var862(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 31) == 8
        {
            if let Some((inst_len, parsed)) =
                c_ueq_PS_instructionVar863::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var863(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 31) == 1
        {
            if let Some((inst_len, parsed)) =
                c_olt_S_instructionVar864::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var864(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 31) == 5
        {
            if let Some((inst_len, parsed)) =
                c_olt_D_instructionVar865::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var865(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 31) == 9
        {
            if let Some((inst_len, parsed)) =
                c_olt_PS_instructionVar866::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var866(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 31) == 1
        {
            if let Some((inst_len, parsed)) =
                c_ult_S_instructionVar867::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var867(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 31) == 5
        {
            if let Some((inst_len, parsed)) =
                c_ult_D_instructionVar868::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var868(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 31) == 9
        {
            if let Some((inst_len, parsed)) =
                c_ult_PS_instructionVar869::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var869(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 188
            && (tokens_param[3] & 31) == 1
        {
            if let Some((inst_len, parsed)) =
                c_ole_S_instructionVar870::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var870(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 188
            && (tokens_param[3] & 31) == 5
        {
            if let Some((inst_len, parsed)) =
                c_ole_D_instructionVar871::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var871(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 188
            && (tokens_param[3] & 31) == 9
        {
            if let Some((inst_len, parsed)) =
                c_ole_PS_instructionVar872::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var872(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 31) == 1
        {
            if let Some((inst_len, parsed)) =
                c_ule_S_instructionVar873::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var873(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 31) == 5
        {
            if let Some((inst_len, parsed)) =
                c_ule_D_instructionVar874::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var874(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 31) == 9
        {
            if let Some((inst_len, parsed)) =
                c_ule_PS_instructionVar875::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var875(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 31) == 2
        {
            if let Some((inst_len, parsed)) =
                c_sf_S_instructionVar876::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var876(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 31) == 6
        {
            if let Some((inst_len, parsed)) =
                c_sf_D_instructionVar877::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var877(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 31) == 10
        {
            if let Some((inst_len, parsed)) =
                c_sf_PS_instructionVar878::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var878(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 31) == 2
        {
            if let Some((inst_len, parsed)) =
                c_ngle_S_instructionVar879::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var879(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 31) == 6
        {
            if let Some((inst_len, parsed)) =
                c_ngle_D_instructionVar880::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var880(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 31) == 10
        {
            if let Some((inst_len, parsed)) =
                c_ngle_PS_instructionVar881::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var881(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 188
            && (tokens_param[3] & 31) == 2
        {
            if let Some((inst_len, parsed)) =
                c_seq_S_instructionVar882::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var882(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 188
            && (tokens_param[3] & 31) == 6
        {
            if let Some((inst_len, parsed)) =
                c_seq_D_instructionVar883::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var883(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 188
            && (tokens_param[3] & 31) == 10
        {
            if let Some((inst_len, parsed)) =
                c_seq_PS_instructionVar884::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var884(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 31) == 2
        {
            if let Some((inst_len, parsed)) =
                c_ngl_S_instructionVar885::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var885(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 31) == 6
        {
            if let Some((inst_len, parsed)) =
                c_ngl_D_instructionVar886::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var886(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 31) == 10
        {
            if let Some((inst_len, parsed)) =
                c_ngl_PS_instructionVar887::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var887(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 31) == 3
        {
            if let Some((inst_len, parsed)) =
                c_lt_S_instructionVar888::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var888(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 31) == 7
        {
            if let Some((inst_len, parsed)) =
                c_lt_D_instructionVar889::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var889(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 31) == 11
        {
            if let Some((inst_len, parsed)) =
                c_lt_PS_instructionVar890::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var890(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 31) == 3
        {
            if let Some((inst_len, parsed)) =
                c_nge_S_instructionVar891::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var891(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 31) == 7
        {
            if let Some((inst_len, parsed)) =
                c_nge_D_instructionVar892::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var892(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 124
            && (tokens_param[3] & 31) == 11
        {
            if let Some((inst_len, parsed)) =
                c_nge_PS_instructionVar893::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var893(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 188
            && (tokens_param[3] & 31) == 3
        {
            if let Some((inst_len, parsed)) =
                c_le_S_instructionVar894::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var894(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 188
            && (tokens_param[3] & 31) == 7
        {
            if let Some((inst_len, parsed)) =
                c_le_D_instructionVar895::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var895(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 188
            && (tokens_param[3] & 31) == 11
        {
            if let Some((inst_len, parsed)) =
                c_le_PS_instructionVar896::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var896(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 31) == 3
        {
            if let Some((inst_len, parsed)) =
                c_ngt_S_instructionVar897::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var897(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 31) == 7
        {
            if let Some((inst_len, parsed)) =
                c_ngt_D_instructionVar898::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var898(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 31) == 11
        {
            if let Some((inst_len, parsed)) =
                c_ngt_PS_instructionVar899::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var899(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 31) == 1
        {
            if let Some((inst_len, parsed)) =
                movf_instructionVar900::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var900(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 31) == 0
        {
            if let Some((inst_len, parsed)) =
                movf_S_instructionVar901::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var901(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 31) == 2
        {
            if let Some((inst_len, parsed)) =
                movf_D_instructionVar902::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var902(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 31) == 4
        {
            if let Some((inst_len, parsed)) =
                movf_PS_instructionVar903::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var903(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 123
            && (tokens_param[3] & 31) == 9
        {
            if let Some((inst_len, parsed)) =
                movt_instructionVar904::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var904(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 96
            && (tokens_param[3] & 31) == 0
        {
            if let Some((inst_len, parsed)) =
                movt_S_instructionVar905::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var905(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 96
            && (tokens_param[3] & 31) == 2
        {
            if let Some((inst_len, parsed)) =
                movt_D_instructionVar906::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var906(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 96
            && (tokens_param[3] & 31) == 4
        {
            if let Some((inst_len, parsed)) =
                movt_PS_instructionVar907::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var907(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 31) == 4
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 192
            && (tokens_param[3] & 199) == 1
        {
            if let Some((inst_len, parsed)) =
                rdhwr_instructionVar908::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var908(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 231) == 0
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                lwxs_instructionVar909::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var909(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 199) == 0
        {
            if let Some((inst_len, parsed)) =
                mfc0_instructionVar910::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var910(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 244
            && (tokens_param[3] & 199) == 0
        {
            if let Some((inst_len, parsed)) =
                mfhc0_instructionVar911::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var911(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 252
            && (tokens_param[3] & 199) == 2
        {
            if let Some((inst_len, parsed)) =
                mtc0_instructionVar912::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var912(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 244
            && (tokens_param[3] & 199) == 2
        {
            if let Some((inst_len, parsed)) =
                mthc0_instructionVar913::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var913(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 247) == 16
            && (tokens_param[3] & 5) == 0
        {
            if let Some((inst_len, parsed)) =
                mul_instructionVar914::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var914(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar915::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var915(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 15) == 2
        {
            if let Some((inst_len, parsed)) =
                tge_instructionVar916::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var916(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 15) == 4
        {
            if let Some((inst_len, parsed)) =
                tgeu_instructionVar917::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var917(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 15) == 8
        {
            if let Some((inst_len, parsed)) =
                tlt_instructionVar918::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var918(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 15) == 10
        {
            if let Some((inst_len, parsed)) =
                tltu_instructionVar919::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var919(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 60
            && (tokens_param[3] & 15) == 12
        {
            if let Some((inst_len, parsed)) =
                tne_instructionVar920::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var920(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 48
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                add_PS_instructionVar921::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var921(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 128
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                cvt_PS_instructionVar922::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var922(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 72
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                lwxc1_instructionVar923::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var923(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 24
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                movn_instructionVar924::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var924(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 56
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                movn_S_instructionVar925::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var925(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 56
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                movn_D_instructionVar926::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var926(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 56
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                movn_PS_instructionVar927::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var927(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 88
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                movz_instructionVar928::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var928(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 120
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                movz_S_instructionVar929::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var929(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 120
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                movz_D_instructionVar930::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var930(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 120
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                movz_PS_instructionVar931::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var931(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 176
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                mul_PS_instructionVar932::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var932(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 128
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                pll_PS_instructionVar933::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var933(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 192
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                plu_PS_instructionVar934::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var934(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 160
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                prefx_instructionVar935::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var935(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                pul_PS_instructionVar936::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var936(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 64
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                puu_PS_instructionVar937::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var937(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 8
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                sdxc1_instructionVar938::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var938(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 136
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                swxc1_instructionVar939::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var939(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 5
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_af_S_instructionVar940::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var940(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 21
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_af_D_instructionVar941::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var941(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 69
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_un_S_instructionVar942::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var942(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 85
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_un_D_instructionVar943::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var943(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 133
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_eq_S_instructionVar944::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var944(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 149
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_eq_D_instructionVar945::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var945(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 197
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_ueq_S_instructionVar946::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var946(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 213
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_ueq_D_instructionVar947::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var947(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 5
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                cmp_lt_S_instructionVar948::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var948(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 21
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                cmp_lt_D_instructionVar949::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var949(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 69
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                cmp_ult_S_instructionVar950::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var950(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 85
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                cmp_ult_D_instructionVar951::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var951(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 133
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                cmp_le_S_instructionVar952::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var952(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 149
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                cmp_le_D_instructionVar953::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var953(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 197
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                cmp_ule_S_instructionVar954::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var954(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 213
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                cmp_ule_D_instructionVar955::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var955(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 5
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                cmp_saf_S_instructionVar956::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var956(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 21
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                cmp_saf_D_instructionVar957::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var957(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 69
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                cmp_sun_S_instructionVar958::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var958(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 85
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                cmp_sun_D_instructionVar959::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var959(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 133
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                cmp_seq_S_instructionVar960::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var960(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 149
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                cmp_seq_D_instructionVar961::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var961(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 197
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                cmp_sueq_S_instructionVar962::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var962(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 213
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                cmp_sueq_D_instructionVar963::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var963(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 5
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                cmp_slt_S_instructionVar964::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var964(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 21
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                cmp_slt_D_instructionVar965::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var965(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 69
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                cmp_sult_S_instructionVar966::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var966(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 85
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                cmp_sult_D_instructionVar967::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var967(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 133
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                cmp_sle_S_instructionVar968::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var968(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 149
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                cmp_sle_D_instructionVar969::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var969(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 197
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                cmp_sule_S_instructionVar970::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var970(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 213
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                cmp_sule_D_instructionVar971::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var971(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 69
            && (tokens_param[3] & 7) == 4
        {
            if let Some((inst_len, parsed)) =
                cmp_or_S_instructionVar972::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var972(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 85
            && (tokens_param[3] & 7) == 4
        {
            if let Some((inst_len, parsed)) =
                cmp_or_D_instructionVar973::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var973(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 133
            && (tokens_param[3] & 7) == 4
        {
            if let Some((inst_len, parsed)) =
                cmp_une_S_instructionVar974::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var974(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 149
            && (tokens_param[3] & 7) == 4
        {
            if let Some((inst_len, parsed)) =
                cmp_une_D_instructionVar975::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var975(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 197
            && (tokens_param[3] & 7) == 4
        {
            if let Some((inst_len, parsed)) =
                cmp_ne_S_instructionVar976::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var976(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 213
            && (tokens_param[3] & 7) == 4
        {
            if let Some((inst_len, parsed)) =
                cmp_ne_D_instructionVar977::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var977(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 69
            && (tokens_param[3] & 7) == 6
        {
            if let Some((inst_len, parsed)) =
                cmp_sor_S_instructionVar978::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var978(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 85
            && (tokens_param[3] & 7) == 6
        {
            if let Some((inst_len, parsed)) =
                cmp_sor_D_instructionVar979::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var979(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 133
            && (tokens_param[3] & 7) == 6
        {
            if let Some((inst_len, parsed)) =
                cmp_sune_S_instructionVar980::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var980(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 149
            && (tokens_param[3] & 7) == 6
        {
            if let Some((inst_len, parsed)) =
                cmp_sune_D_instructionVar981::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var981(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 197
            && (tokens_param[3] & 7) == 6
        {
            if let Some((inst_len, parsed)) =
                cmp_sne_S_instructionVar982::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var982(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 213
            && (tokens_param[3] & 7) == 6
        {
            if let Some((inst_len, parsed)) =
                cmp_sne_D_instructionVar983::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var983(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 24
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                div_instructionVar984::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var984(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 152
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                divu_instructionVar985::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var985(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 184
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                maddf_S_instructionVar986::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var986(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 184
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                maddf_D_instructionVar987::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var987(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 11
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                max_S_instructionVar988::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var988(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 11
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                max_D_instructionVar989::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var989(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 43
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                maxa_S_instructionVar990::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var990(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 43
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                maxa_D_instructionVar991::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var991(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 3
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                min_S_instructionVar992::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var992(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 3
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                min_D_instructionVar993::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var993(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 35
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                mina_S_instructionVar994::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var994(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 35
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                mina_D_instructionVar995::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var995(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 88
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                mod_instructionVar996::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var996(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 216
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                modu_instructionVar997::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var997(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 248
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                msubf_S_instructionVar998::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var998(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 248
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                msubf_D_instructionVar999::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var999(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 88
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                muh_instructionVar1000::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1000(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 152
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                mulu_instructionVar1001::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1001(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 216
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                muhu_instructionVar1002::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1002(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 64
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                seleqz_instructionVar1003::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1003(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 128
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                selnez_instructionVar1004::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1004(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 184
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                sel_S_instructionVar1005::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1005(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 184
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                sel_D_instructionVar1006::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1006(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 56
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                seleqz_S_instructionVar1007::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1007(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 56
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                seleqz_D_instructionVar1008::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1008(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 120
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                selnez_S_instructionVar1009::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1009(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 120
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                selnez_D_instructionVar1010::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1010(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 16
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar1011::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1011(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 48
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                add_S_instructionVar1012::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1012(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 48
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                add_D_instructionVar1013::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1013(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar1014::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1014(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 255) == 96
            && (tokens_param[1] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                bal_instructionVar1015::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1015(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 255) == 159
            && (tokens_param[1] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                jr16_instructionVar1016::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1016(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 255) == 191
            && (tokens_param[1] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                jrc_instructionVar1017::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1017(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 192
        {
            if let Some((inst_len, parsed)) =
                bad1_instructionVar1018::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1018(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 224
        {
            if let Some((inst_len, parsed)) =
                bad2_instructionVar1019::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1019(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 31) == 0
            && (tokens_param[1] & 252) == 116
        {
            if let Some((inst_len, parsed)) =
                beqzalc_instructionVar1020::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1020(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 31) == 0
            && (tokens_param[1] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                bnezalc_instructionVar1021::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1021(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 228
        {
            if let Some((inst_len, parsed)) =
                bad3_instructionVar1022::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1022(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 196
        {
            if let Some((inst_len, parsed)) =
                bad4_instructionVar1023::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1023(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 255) == 236
            && (tokens_param[1] & 255) == 71
        {
            if let Some((inst_len, parsed)) =
                jrc16_instructionVar1024::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1024(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 32) == 0
            && (tokens_param[1] & 252) == 68
        {
            if let Some((inst_len, parsed)) =
                break16_instructionVar1025::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1025(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 136
        {
            if let Some((inst_len, parsed)) =
                sdbbp16_instructionVar1026::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1026(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 227) == 128
            && (tokens_param[1] & 255) == 67
        {
            if let Some((inst_len, parsed)) =
                bc1f_instructionVar1027::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1027(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 227) == 160
            && (tokens_param[1] & 255) == 67
        {
            if let Some((inst_len, parsed)) =
                bc1t_instructionVar1028::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1028(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 227) == 128
            && (tokens_param[1] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                bc2f_instructionVar1029::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1029(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 227) == 160
            && (tokens_param[1] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                bc2t_instructionVar1030::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1030(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 96) == 0
            && (tokens_param[1] & 252) == 64
        {
            if let Some((inst_len, parsed)) =
                synci_instructionVar1031::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1031(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 31
            && (tokens_param[3] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                align_instructionVar1032::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1032(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 15
            && (tokens_param[3] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                lsa_instructionVar1033::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1033(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 192) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 63) == 63
        {
            if let Some((inst_len, parsed)) =
                sigrie_instructionVar1034::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1034(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 63) == 25
        {
            if let Some((inst_len, parsed)) =
                alnv_ps_instructionVar1035::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1035(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 224
            && (tokens_param[1] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                beqzc_instructionVar1036::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1036(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 64
            && (tokens_param[1] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                bgez_instructionVar1037::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1037(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 96
            && (tokens_param[1] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                bgezal_instructionVar1038::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1038(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 96
            && (tokens_param[1] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                bgezals_instructionVar1039::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1039(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 192
            && (tokens_param[1] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                bgtz_instructionVar1040::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1040(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 128
            && (tokens_param[1] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                blez_instructionVar1041::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1041(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                bltz_instructionVar1042::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1042(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 32
            && (tokens_param[1] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                bltzal_instructionVar1043::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1043(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 32
            && (tokens_param[1] & 255) == 66
        {
            if let Some((inst_len, parsed)) =
                bltzals_instructionVar1044::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1044(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 160
            && (tokens_param[1] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                bnezc_instructionVar1045::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1045(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306371 == 3
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                lwl_instructionVar1046::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1046(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306371 == 3
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                lwr_instructionVar1047::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1047(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306371 == 3
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 240) == 128
        {
            if let Some((inst_len, parsed)) =
                swl_instructionVar1048::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1048(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306371 == 3
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                swr_instructionVar1049::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1049(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 32
            && (tokens_param[3] & 240) == 96
        {
            if let Some((inst_len, parsed)) =
                cache_instructionVar1050::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1050(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 192
            && (tokens_param[1] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                jalr16_instructionVar1051::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1051(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 224
            && (tokens_param[1] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                jalrs16_instructionVar1052::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1052(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 128
            && (tokens_param[1] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                jr16_instructionVar1053::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1053(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 71
        {
            if let Some((inst_len, parsed)) =
                jraddiusp_instructionVar1054::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1054(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 160
            && (tokens_param[1] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                jrc_instructionVar1055::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1055(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                lwl_instructionVar1056::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1056(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                lwr_instructionVar1057::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1057(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 63) == 1
        {
            if let Some((inst_len, parsed)) =
                madd_S_instructionVar1058::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1058(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 63) == 9
        {
            if let Some((inst_len, parsed)) =
                madd_D_instructionVar1059::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1059(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 63) == 17
        {
            if let Some((inst_len, parsed)) =
                madd_PS_instructionVar1060::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1060(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                mfhi16_instructionVar1061::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1061(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 64
            && (tokens_param[1] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                mflo16_instructionVar1062::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1062(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 63) == 33
        {
            if let Some((inst_len, parsed)) =
                msub_S_instructionVar1063::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1063(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 63) == 41
        {
            if let Some((inst_len, parsed)) =
                msub_D_instructionVar1064::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1064(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 63) == 49
        {
            if let Some((inst_len, parsed)) =
                msub_PS_instructionVar1065::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1065(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 240) == 128
        {
            if let Some((inst_len, parsed)) =
                swl_instructionVar1066::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1066(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                swr_instructionVar1067::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1067(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 192
            && (tokens_param[1] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                teqi_instructionVar1068::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1068(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 32
            && (tokens_param[1] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                tgei_instructionVar1069::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1069(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 96
            && (tokens_param[1] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                tgeiu_instructionVar1070::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1070(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                tlti_instructionVar1071::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1071(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 64
            && (tokens_param[1] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                tltiu_instructionVar1072::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1072(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[0] & 224) == 128
            && (tokens_param[1] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                tnei_instructionVar1073::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1073(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 31) == 31
            && (tokens_param[1] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                aluipc_instructionVar1074::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1074(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 31) == 30
            && (tokens_param[1] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                auipc_instructionVar1075::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1075(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                bc1eqzc_instructionVar1076::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1076(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 224) == 32
            && (tokens_param[1] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                bc1nezc_instructionVar1077::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1077(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 224) == 64
            && (tokens_param[1] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                bc2eqzc_instructionVar1078::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1078(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 224) == 96
            && (tokens_param[1] & 255) == 65
        {
            if let Some((inst_len, parsed)) =
                bc2nezc_instructionVar1079::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1079(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 31) == 0
            && (tokens_param[1] & 252) == 192
        {
            if let Some((inst_len, parsed)) =
                blezalc_instructionVar1080::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1080(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 192
        {
            if let Some((inst_len, parsed)) =
                bgezalc_instructionVar1081::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1081(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 31) == 0
            && (tokens_param[1] & 252) == 224
        {
            if let Some((inst_len, parsed)) =
                bgtzalc_instructionVar1082::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1082(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 224
        {
            if let Some((inst_len, parsed)) =
                bltzalc_instructionVar1083::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1083(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 116
        {
            if let Some((inst_len, parsed)) =
                beqc_instructionVar1084::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1084(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                bnec_instructionVar1085::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1085(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 31) == 0
            && (tokens_param[1] & 252) == 228
        {
            if let Some((inst_len, parsed)) =
                blezc_instructionVar1086::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1086(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 228
        {
            if let Some((inst_len, parsed)) =
                bgezc_instructionVar1087::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1087(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 31) == 0
            && (tokens_param[1] & 252) == 196
        {
            if let Some((inst_len, parsed)) =
                bgtzc_instructionVar1088::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1088(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 196
        {
            if let Some((inst_len, parsed)) =
                bltzc_instructionVar1089::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1089(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                bad6_instructionVar1090::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1090(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 31) == 14
            && (tokens_param[1] & 252) == 68
        {
            if let Some((inst_len, parsed)) =
                jalrc16_instructionVar1091::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1091(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 160
        {
            if let Some((inst_len, parsed)) =
                jialc_instructionVar1092::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1092(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 255) == 128
        {
            if let Some((inst_len, parsed)) =
                jic_instructionVar1093::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1093(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 31) == 19
            && (tokens_param[1] & 252) == 68
        {
            if let Some((inst_len, parsed)) =
                jrcaddiusp_instructionVar1094::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1094(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 31) == 12
            && (tokens_param[1] & 252) == 68
        {
            if let Some((inst_len, parsed)) =
                jrc16_instructionVar1095::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1095(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 24) == 8
            && (tokens_param[1] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                lwpc_instructionVar1096::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1096(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[0] & 24) == 16
            && (tokens_param[1] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                lwupc_instructionVar1097::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1097(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                addiupc_instructionVar1098::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1098(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 1) == 1
            && (tokens_param[1] & 252) == 108
        {
            if let Some((inst_len, parsed)) =
                addiur1sp_instructionVar1099::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1099(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 1) == 0
            && (tokens_param[1] & 252) == 108
        {
            if let Some((inst_len, parsed)) =
                addiur2_instructionVar1100::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1100(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 1) == 1
            && (tokens_param[1] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                addiusp_instructionVar1101::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1101(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 1) == 0
            && (tokens_param[1] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                addius5_instructionVar1102::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1102(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 80
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                addu_instructionVar1103::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1103(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 1) == 0
            && (tokens_param[1] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                addu16_instructionVar1104::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1104(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 80
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar1105::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1105(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 68
        {
            if let Some((inst_len, parsed)) =
                and16_instructionVar1106::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1106(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 240
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                div_S_instructionVar1107::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1107(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 240
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                div_D_instructionVar1108::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1108(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 176
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                mul_S_instructionVar1109::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1109(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 176
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                mul_D_instructionVar1110::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1110(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 208
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                nor_instructionVar1111::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1111(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 144
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                or_instructionVar1112::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1112(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 192
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                rotr_instructionVar1113::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1113(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 208
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                rotrv_instructionVar1114::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1114(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                sll_instructionVar1115::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1115(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 16
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                sllv_instructionVar1116::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1116(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 80
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                slt_instructionVar1117::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1117(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 144
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                sltu_instructionVar1118::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1118(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 128
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                sra_instructionVar1119::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1119(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 144
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                srav_instructionVar1120::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1120(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 64
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                srl_instructionVar1121::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1121(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 80
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                srlv_instructionVar1122::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1122(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 144
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar1123::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1123(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 112
            && (tokens_param[3] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                sub_S_instructionVar1124::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1124(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 112
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                sub_D_instructionVar1125::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1125(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 208
            && (tokens_param[3] & 7) == 1
        {
            if let Some((inst_len, parsed)) =
                subu_instructionVar1126::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1126(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 255) == 16
            && (tokens_param[3] & 7) == 3
        {
            if let Some((inst_len, parsed)) =
                xor_instructionVar1127::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1127(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 84
            && (tokens_param[2] & 255) == 112
            && (tokens_param[3] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                sub_PS_instructionVar1128::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1128(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 63) == 7
        {
            if let Some((inst_len, parsed)) =
                break_instructionVar1129::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1129(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 63) == 44
        {
            if let Some((inst_len, parsed)) =
                ext_instructionVar1130::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1130(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 63) == 12
        {
            if let Some((inst_len, parsed)) =
                ins_instructionVar1131::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1131(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 0
            && (tokens_param[2] & 7) == 2
        {
            if let Some((inst_len, parsed)) =
                cop2_instructionVar1132::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1132(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 32
            && (tokens_param[3] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                swc2_instructionVar1133::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1133(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 32
            && (tokens_param[3] & 240) == 32
        {
            if let Some((inst_len, parsed)) =
                ldc2_instructionVar1134::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1134(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 172) == 0
        {
            if let Some((inst_len, parsed)) =
                lui_instructionVar1135::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1135(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 68
        {
            if let Some((inst_len, parsed)) =
                lwm16_instructionVar1136::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1136(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 32
            && (tokens_param[3] & 240) == 80
        {
            if let Some((inst_len, parsed)) =
                lwm32_instructionVar1137::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1137(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 32
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                lwc2_instructionVar1138::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1138(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 32
            && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                lwp_instructionVar1139::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1139(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 1) == 0
            && (tokens_param[1] & 252) == 132
        {
            if let Some((inst_len, parsed)) =
                movep_instructionVar1140::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1140(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 68
        {
            if let Some((inst_len, parsed)) =
                not16_instructionVar1141::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1141(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 68
        {
            if let Some((inst_len, parsed)) =
                or16_instructionVar1142::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1142(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 96
            && (tokens_param[3] & 240) == 160
        {
            if let Some((inst_len, parsed)) =
                sdc2_instructionVar1143::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1143(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 1) == 0
            && (tokens_param[1] & 252) == 36
        {
            if let Some((inst_len, parsed)) =
                sll16_instructionVar1144::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1144(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 1) == 1
            && (tokens_param[1] & 252) == 36
        {
            if let Some((inst_len, parsed)) =
                srl16_instructionVar1145::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1145(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[0] & 1) == 1
            && (tokens_param[1] & 252) == 4
        {
            if let Some((inst_len, parsed)) =
                subu16_instructionVar1146::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1146(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 32
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                swp_instructionVar1147::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1147(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 68
        {
            if let Some((inst_len, parsed)) =
                swm16_instructionVar1148::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1148(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 32
            && (tokens_param[3] & 240) == 208
        {
            if let Some((inst_len, parsed)) =
                swm32_instructionVar1149::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1149(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 68
        {
            if let Some((inst_len, parsed)) =
                xor16_instructionVar1150::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1150(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                addi_instructionVar1151::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1151(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 204
        {
            if let Some((inst_len, parsed)) =
                b16_instructionVar1152::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1152(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 148
        {
            if let Some((inst_len, parsed)) =
                beq_instructionVar1153::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1153(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 140
        {
            if let Some((inst_len, parsed)) =
                beqz16_instructionVar1154::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1154(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 180
        {
            if let Some((inst_len, parsed)) =
                bne_instructionVar1155::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1155(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 172
        {
            if let Some((inst_len, parsed)) =
                bnez16_instructionVar1156::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1156(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 212
        {
            if let Some((inst_len, parsed)) =
                j_instructionVar1157::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1157(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 244
        {
            if let Some((inst_len, parsed)) =
                jal_instructionVar1158::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1158(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 116
        {
            if let Some((inst_len, parsed)) =
                jals_instructionVar1159::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1159(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 2
            && (tokens_param[1] & 252) == 240
        {
            if let Some((inst_len, parsed)) =
                jalx_instructionVar1160::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1160(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                aui_instructionVar1161::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1161(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 180
        {
            if let Some((inst_len, parsed)) =
                balc_instructionVar1162::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1162(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 148
        {
            if let Some((inst_len, parsed)) =
                bc_instructionVar1163::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1163(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 204
        {
            if let Some((inst_len, parsed)) =
                bc16_instructionVar1164::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1164(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 140
        {
            if let Some((inst_len, parsed)) =
                beqzc16_instructionVar1165::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1165(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 172
        {
            if let Some((inst_len, parsed)) =
                bnezc16_instructionVar1166::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1166(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 192
        {
            if let Some((inst_len, parsed)) =
                bgeuc_instructionVar1167::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1167(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 224
        {
            if let Some((inst_len, parsed)) =
                bltuc_instructionVar1168::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1168(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 116
        {
            if let Some((inst_len, parsed)) =
                bovc_instructionVar1169::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1169(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                bnvc_instructionVar1170::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1170(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 228
        {
            if let Some((inst_len, parsed)) =
                bgec_instructionVar1171::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1171(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 196
        {
            if let Some((inst_len, parsed)) =
                bltc_instructionVar1172::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1172(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 128
        {
            if let Some((inst_len, parsed)) =
                beqzc_instructionVar1173::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1173(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 805306370 == 536870914
            && (tokens_param[1] & 252) == 80
        {
            if let Some((inst_len, parsed)) =
                bnezc_instructionVar1174::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1174(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 48
        {
            if let Some((inst_len, parsed)) =
                addiu_instructionVar1175::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1175(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 208
        {
            if let Some((inst_len, parsed)) =
                andi_instructionVar1176::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1176(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 44
        {
            if let Some((inst_len, parsed)) =
                andi16_instructionVar1177::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1177(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 28
        {
            if let Some((inst_len, parsed)) =
                lb_instructionVar1178::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1178(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 20
        {
            if let Some((inst_len, parsed)) =
                lbu_instructionVar1179::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1179(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 8
        {
            if let Some((inst_len, parsed)) =
                lbu16_instructionVar1180::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1180(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 188
        {
            if let Some((inst_len, parsed)) =
                ldc1_instructionVar1181::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1181(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 60
        {
            if let Some((inst_len, parsed)) =
                lh_instructionVar1182::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1182(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 52
        {
            if let Some((inst_len, parsed)) =
                lhu_instructionVar1183::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1183(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 40
        {
            if let Some((inst_len, parsed)) =
                lhu16_instructionVar1184::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1184(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                li16_instructionVar1185::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1185(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                lw_instructionVar1186::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1186(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 104
        {
            if let Some((inst_len, parsed)) =
                lw16_instructionVar1187::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1187(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 156
        {
            if let Some((inst_len, parsed)) =
                lwc1_instructionVar1188::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1188(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 100
        {
            if let Some((inst_len, parsed)) =
                lwgp_instructionVar1189::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1189(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 72
        {
            if let Some((inst_len, parsed)) =
                lwsp_instructionVar1190::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1190(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 12
        {
            if let Some((inst_len, parsed)) =
                move16_instructionVar1191::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1191(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 80
        {
            if let Some((inst_len, parsed)) =
                ori_instructionVar1192::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1192(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 24
        {
            if let Some((inst_len, parsed)) =
                sb_instructionVar1193::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1193(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 136
        {
            if let Some((inst_len, parsed)) =
                sb16_instructionVar1194::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1194(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 184
        {
            if let Some((inst_len, parsed)) =
                sdc1_instructionVar1195::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1195(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 56
        {
            if let Some((inst_len, parsed)) =
                sh_instructionVar1196::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1196(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 168
        {
            if let Some((inst_len, parsed)) =
                sh16_instructionVar1197::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1197(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 144
        {
            if let Some((inst_len, parsed)) =
                slti_instructionVar1198::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1198(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 176
        {
            if let Some((inst_len, parsed)) =
                sltiu_instructionVar1199::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1199(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 248
        {
            if let Some((inst_len, parsed)) =
                sw_instructionVar1200::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1200(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 232
        {
            if let Some((inst_len, parsed)) =
                sw16_instructionVar1201::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1201(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 152
        {
            if let Some((inst_len, parsed)) =
                swc1_instructionVar1202::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1202(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 200
        {
            if let Some((inst_len, parsed)) =
                swsp_instructionVar1203::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1203(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 268435458 == 2
            && (tokens_param[1] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                xori_instructionVar1204::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1204(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:817:1, end:817:4))"]
#[derive(Clone, Debug)]
struct RD0Var0 {
    rd0_0: u8,
}
impl RD0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_6_display(self.rd0_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd0_0 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd0_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:818:1, end:818:4))"]
#[derive(Clone, Debug)]
struct RD0Var1 {
    rd0_1: u8,
}
impl RD0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_7_display(self.rd0_1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd0_1 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd0_1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:819:1, end:819:4))"]
#[derive(Clone, Debug)]
struct RD0Var2 {
    rd0_2: u8,
}
impl RD0Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_8_display(self.rd0_2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd0_2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd0_2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:820:1, end:820:4))"]
#[derive(Clone, Debug)]
struct RD0Var3 {
    rd0_3: u8,
}
impl RD0Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_9_display(self.rd0_3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd0_3 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd0_3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:821:1, end:821:4))"]
#[derive(Clone, Debug)]
struct RD0Var4 {
    rd0_4: u8,
}
impl RD0Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_10_display(self.rd0_4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd0_4 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd0_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:822:1, end:822:4))"]
#[derive(Clone, Debug)]
struct RD0Var5 {
    rd0_5: u8,
}
impl RD0Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_11_display(self.rd0_5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd0_5 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd0_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:823:1, end:823:4))"]
#[derive(Clone, Debug)]
struct RD0Var6 {
    rd0_6: u8,
}
impl RD0Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_12_display(self.rd0_6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd0_6 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd0_6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:824:1, end:824:4))"]
#[derive(Clone, Debug)]
struct RD0Var7 {
    rd0_7: u8,
}
impl RD0Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_13_display(self.rd0_7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd0_7 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd0_7 }))
    }
}
#[derive(Clone, Debug)]
enum TableRD0 {
    Var0(RD0Var0),
    Var1(RD0Var1),
    Var2(RD0Var2),
    Var3(RD0Var3),
    Var4(RD0Var4),
    Var5(RD0Var5),
    Var6(RD0Var6),
    Var7(RD0Var7),
}
impl TableRD0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 7) == 0 {
            if let Some((inst_len, parsed)) =
                RD0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 7) == 1 {
            if let Some((inst_len, parsed)) =
                RD0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 7) == 2 {
            if let Some((inst_len, parsed)) =
                RD0Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 7) == 3 {
            if let Some((inst_len, parsed)) =
                RD0Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 7) == 4 {
            if let Some((inst_len, parsed)) =
                RD0Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 7) == 5 {
            if let Some((inst_len, parsed)) =
                RD0Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 7) == 6 {
            if let Some((inst_len, parsed)) =
                RD0Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 7) == 7 {
            if let Some((inst_len, parsed)) =
                RD0Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:826:1, end:826:3))"]
#[derive(Clone, Debug)]
struct RDVar0 {
    rd: u8,
}
impl RDVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd }))
    }
}
#[derive(Clone, Debug)]
enum TableRD {
    Var0(RDVar0),
}
impl TableRD {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RDVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:828:1, end:828:6))"]
#[derive(Clone, Debug)]
struct RDsrcVar0 {
    rd: u8,
}
impl RDsrcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:827:1, end:827:6))"]
#[derive(Clone, Debug)]
struct RDsrcVar1 {
    rd: u8,
}
impl RDsrcVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd }))
    }
}
#[derive(Clone, Debug)]
enum TableRDsrc {
    Var0(RDsrcVar0),
    Var1(RDsrcVar1),
}
impl TableRDsrc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 248) == 0 {
            if let Some((inst_len, parsed)) =
                RDsrcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RDsrcVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:830:1, end:830:3))"]
#[derive(Clone, Debug)]
struct RSVar0 {
    rs: u8,
}
impl RSVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rs)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs }))
    }
}
#[derive(Clone, Debug)]
enum TableRS {
    Var0(RSVar0),
}
impl TableRS {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RSVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:832:1, end:832:6))"]
#[derive(Clone, Debug)]
struct RSsrcVar0 {
    rs: u8,
}
impl RSsrcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rs)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:831:1, end:831:6))"]
#[derive(Clone, Debug)]
struct RSsrcVar1 {
    rs: u8,
}
impl RSsrcVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rs)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs }))
    }
}
#[derive(Clone, Debug)]
enum TableRSsrc {
    Var0(RSsrcVar0),
    Var1(RSsrcVar1),
}
impl TableRSsrc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 && (tokens_param[3] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                RSsrcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RSsrcVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:834:1, end:834:3))"]
#[derive(Clone, Debug)]
struct RTVar0 {
    rt: u8,
}
impl RTVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rt)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rt = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rt }))
    }
}
#[derive(Clone, Debug)]
enum TableRT {
    Var0(RTVar0),
}
impl TableRT {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RTVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:836:1, end:836:6))"]
#[derive(Clone, Debug)]
struct RTsrcVar0 {
    rt: u8,
}
impl RTsrcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rt)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rt = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:835:1, end:835:6))"]
#[derive(Clone, Debug)]
struct RTsrcVar1 {
    rt: u8,
}
impl RTsrcVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rt)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rt = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rt }))
    }
}
#[derive(Clone, Debug)]
enum TableRTsrc {
    Var0(RTsrcVar0),
    Var1(RTsrcVar1),
}
impl TableRTsrc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                RTsrcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RTsrcVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:838:1, end:838:5))"]
#[derive(Clone, Debug)]
struct RD32Var0 {
    rd: u8,
}
impl RD32Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd32 = token_28(tokens_current);
        let rd = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd }))
    }
}
#[derive(Clone, Debug)]
enum TableRD32 {
    Var0(RD32Var0),
}
impl TableRD32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RD32Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:840:1, end:840:8))"]
#[derive(Clone, Debug)]
struct RS32srcVar0 {
    rs: u8,
}
impl RS32srcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rs)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:839:1, end:839:8))"]
#[derive(Clone, Debug)]
struct RS32srcVar1 {
    rs: u8,
}
impl RS32srcVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rs)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = token_6(tokens_current);
        let rs32 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs }))
    }
}
#[derive(Clone, Debug)]
enum TableRS32src {
    Var0(RS32srcVar0),
    Var1(RS32srcVar1),
}
impl TableRS32src {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 && (tokens_param[3] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                RS32srcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RS32srcVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:841:1, end:841:5))"]
#[derive(Clone, Debug)]
struct RT32Var0 {
    rt: u8,
}
impl RT32Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rt)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rt = token_20(tokens_current);
        let rt32 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rt }))
    }
}
#[derive(Clone, Debug)]
enum TableRT32 {
    Var0(RT32Var0),
}
impl TableRT32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RT32Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:843:1, end:843:8))"]
#[derive(Clone, Debug)]
struct RT32srcVar0 {
    rt: u8,
}
impl RT32srcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rt)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rt = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:842:1, end:842:8))"]
#[derive(Clone, Debug)]
struct RT32srcVar1 {
    rt: u8,
}
impl RT32srcVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rt)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rt = token_20(tokens_current);
        let rt32 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rt }))
    }
}
#[derive(Clone, Debug)]
enum TableRT32src {
    Var0(RT32srcVar0),
    Var1(RT32srcVar1),
}
impl TableRT32src {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                RT32srcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RT32srcVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:867:1, end:867:9))"]
#[derive(Clone, Debug)]
struct OFF_BASEVar0 {
    simmed: u16,
    base: u8,
}
impl OFF_BASEVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal("("),
            meaning_0_display(self.base),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let base = token_6(tokens_current);
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simmed, base }))
    }
}
#[derive(Clone, Debug)]
enum TableOFF_BASE {
    Var0(OFF_BASEVar0),
}
impl TableOFF_BASE {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                OFF_BASEVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:868:1, end:868:11))"]
#[derive(Clone, Debug)]
struct INDEX_BASEVar0 {
    index: u8,
    base: u8,
}
impl INDEX_BASEVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            meaning_0_display(self.index),
            <DisplayElement>::Literal("("),
            meaning_0_display(self.base),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let index = token_20(tokens_current);
        let base = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { index, base }))
    }
}
#[derive(Clone, Debug)]
enum TableINDEX_BASE {
    Var0(INDEX_BASEVar0),
}
impl TableINDEX_BASE {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                INDEX_BASEVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:870:1, end:870:11))"]
#[derive(Clone, Debug)]
struct OFF_BASER6Var0 {
    simmed: u16,
    base: u8,
}
impl OFF_BASER6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Number(
                true,
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .is_negative(),
                (if self.simmed & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simmed as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal("("),
            meaning_0_display(self.base),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let base = token_6(tokens_current);
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simmed, base }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:871:1, end:871:11))"]
#[derive(Clone, Debug)]
struct OFF_BASER6Var1 {
    simmed9: u16,
    base: u8,
}
impl OFF_BASER6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Number(true, false, self.simmed9 as u64),
            <DisplayElement>::Literal("("),
            meaning_0_display(self.base),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let base = token_6(tokens_current);
        let simmed9 = token_34(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simmed9, base }))
    }
}
#[derive(Clone, Debug)]
enum TableOFF_BASER6 {
    Var0(OFF_BASER6Var0),
    Var1(OFF_BASER6Var1),
}
impl TableOFF_BASER6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                OFF_BASER6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                OFF_BASER6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:873:1, end:873:6))"]
#[derive(Clone, Debug)]
struct S18L3Var0 {
    simmed18: u32,
}
impl S18L3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(3i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.simmed18 & 131072 != 0 {
                        -1 & !131071
                    } else {
                        0
                    } | self.simmed18 as i32),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 4;
        calc_val = u32::try_from(3i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_51(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let simmed18 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simmed18 }))
    }
}
#[derive(Clone, Debug)]
enum TableS18L3 {
    Var0(S18L3Var0),
}
impl TableS18L3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                S18L3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:874:1, end:874:6))"]
#[derive(Clone, Debug)]
struct S19L2Var0 {
    simmed19: u32,
}
impl S19L2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.simmed19 & 262144 != 0 {
                        -1 & !262143
                    } else {
                        0
                    } | self.simmed19 as i32),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 4;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_50(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let simmed19 = token_50(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simmed19 }))
    }
}
#[derive(Clone, Debug)]
enum TableS19L2 {
    Var0(S19L2Var0),
}
impl TableS19L2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                S19L2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:875:1, end:875:7))"]
#[derive(Clone, Debug)]
struct S16L16Var0 {
    simmed: u16,
}
impl S16L16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(16i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.simmed & 32768 != 0 {
                        -1 & !32767
                    } else {
                        0
                    } | self.simmed as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 4;
        calc_val = u32::try_from(16i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simmed }))
    }
}
#[derive(Clone, Debug)]
enum TableS16L16 {
    Var0(S16L16Var0),
}
impl TableS16L16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                S16L16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:876:1, end:876:7))"]
#[derive(Clone, Debug)]
struct S16L32Var0 {
    simmed: u16,
}
impl S16L32Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(32i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.simmed & 32768 != 0 {
                        -1 & !32767
                    } else {
                        0
                    } | self.simmed as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 4;
        calc_val = u32::try_from(32i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simmed }))
    }
}
#[derive(Clone, Debug)]
enum TableS16L32 {
    Var0(S16L32Var0),
}
impl TableS16L32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                S16L32Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:877:1, end:877:7))"]
#[derive(Clone, Debug)]
struct S16L48Var0 {
    simmed: u16,
}
impl S16L48Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(48i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.simmed & 32768 != 0 {
                        -1 & !32767
                    } else {
                        0
                    } | self.simmed as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 4;
        calc_val = u32::try_from(48i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let simmed = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simmed }))
    }
}
#[derive(Clone, Debug)]
enum TableS16L48 {
    Var0(S16L48Var0),
}
impl TableS16L48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                S16L48Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:878:1, end:878:4))"]
#[derive(Clone, Debug)]
struct SAVVar0 {
    sa2: u8,
}
impl SAVVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(self.sa2).unwrap().wrapping_add(1i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 4;
        calc_val = i128::try_from(token_39(tokens_current))
            .unwrap()
            .wrapping_add(1i128);
        let sa2 = token_39(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sa2 }))
    }
}
#[derive(Clone, Debug)]
enum TableSAV {
    Var0(SAVVar0),
}
impl TableSAV {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                SAVVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:880:1, end:880:6))"]
#[derive(Clone, Debug)]
struct Rel16Var0 {
    off16: u16,
}
impl Rel16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    i128::try_from(
                        (if self.off16 & 32768 != 0 {
                            -1 & !32767
                        } else {
                            0
                        } | self.off16 as i16),
                    )
                    .unwrap(),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(4i128.wrapping_mul(i128::try_from(token_14(tokens_current)).unwrap()));
        let off16 = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { off16 }))
    }
}
#[derive(Clone, Debug)]
enum TableRel16 {
    Var0(Rel16Var0),
}
impl TableRel16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                Rel16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:881:1, end:881:6))"]
#[derive(Clone, Debug)]
struct Rel21Var0 {
    off21: u32,
}
impl Rel21Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    i128::try_from(
                        (if self.off21 & 1048576 != 0 {
                            -1 & !1048575
                        } else {
                            0
                        } | self.off21 as i32),
                    )
                    .unwrap(),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(4i128.wrapping_mul(i128::try_from(token_13(tokens_current)).unwrap()));
        let off21 = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { off21 }))
    }
}
#[derive(Clone, Debug)]
enum TableRel21 {
    Var0(Rel21Var0),
}
impl TableRel21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                Rel21Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:882:1, end:882:6))"]
#[derive(Clone, Debug)]
struct Rel26Var0 {
    off26: u32,
}
impl Rel26Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    i128::try_from(
                        (if self.off26 & 33554432 != 0 {
                            -1 & !33554431
                        } else {
                            0
                        } | self.off26 as i32),
                    )
                    .unwrap(),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(4i128.wrapping_mul(i128::try_from(token_10(tokens_current)).unwrap()));
        let off26 = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { off26 }))
    }
}
#[derive(Clone, Debug)]
enum TableRel26 {
    Var0(Rel26Var0),
}
impl TableRel26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                Rel26Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:883:1, end:883:6))"]
#[derive(Clone, Debug)]
struct Abs26Var0 {
    ind26: u32,
}
impl Abs26Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = ((i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 18446744073441116160i128)
            | 4i128)
            .wrapping_mul(i128::try_from(self.ind26).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = ((i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 18446744073441116160i128)
            | 4i128)
            .wrapping_mul(i128::try_from(token_10(tokens_current)).unwrap());
        let ind26 = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ind26 }))
    }
}
#[derive(Clone, Debug)]
enum TableAbs26 {
    Var0(Abs26Var0),
}
impl TableAbs26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                Abs26Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:885:1, end:885:8))"]
#[derive(Clone, Debug)]
struct InsSizeVar0 {
    msbd: u8,
    lsb: u8,
}
impl InsSizeVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_mysize: i128 = 0;
        calc_mysize = i128::try_from(self.msbd)
            .unwrap()
            .wrapping_sub(i128::try_from(self.lsb).unwrap())
            .wrapping_add(1i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_mysize.is_negative(),
            calc_mysize.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_mysize: i128 = 0;
        let mut block_0_len = 4;
        calc_mysize = i128::try_from(token_28(tokens_current))
            .unwrap()
            .wrapping_sub(i128::try_from(token_37(tokens_current)).unwrap())
            .wrapping_add(1i128);
        let lsb = token_37(tokens_current);
        let msbd = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { msbd, lsb }))
    }
}
#[derive(Clone, Debug)]
enum TableInsSize {
    Var0(InsSizeVar0),
}
impl TableInsSize {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                InsSizeVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:886:1, end:886:8))"]
#[derive(Clone, Debug)]
struct ExtSizeVar0 {
    msbd: u8,
}
impl ExtSizeVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_mysize: i128 = 0;
        calc_mysize = i128::try_from(self.msbd).unwrap().wrapping_add(1i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_mysize.is_negative(),
            calc_mysize.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_mysize: i128 = 0;
        let mut block_0_len = 4;
        calc_mysize = i128::try_from(token_28(tokens_current))
            .unwrap()
            .wrapping_add(1i128);
        let msbd = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { msbd }))
    }
}
#[derive(Clone, Debug)]
enum TableExtSize {
    Var0(ExtSizeVar0),
}
impl TableExtSize {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                ExtSizeVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:912:1, end:912:5))"]
#[derive(Clone, Debug)]
struct fmt1Var0 {}
impl fmt1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("S")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:913:1, end:913:5))"]
#[derive(Clone, Debug)]
struct fmt1Var1 {}
impl fmt1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("D")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:914:1, end:914:5))"]
#[derive(Clone, Debug)]
struct fmt1Var2 {}
impl fmt1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("PS")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefmt1 {
    Var0(fmt1Var0),
    Var1(fmt1Var1),
    Var2(fmt1Var2),
}
impl Tablefmt1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:916:1, end:916:5))"]
#[derive(Clone, Debug)]
struct fmt2Var0 {}
impl fmt2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("S")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:917:1, end:917:5))"]
#[derive(Clone, Debug)]
struct fmt2Var1 {}
impl fmt2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("D")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefmt2 {
    Var0(fmt2Var0),
    Var1(fmt2Var1),
}
impl Tablefmt2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:919:1, end:919:5))"]
#[derive(Clone, Debug)]
struct fmt3Var0 {}
impl fmt3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("S")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:920:1, end:920:5))"]
#[derive(Clone, Debug)]
struct fmt3Var1 {}
impl fmt3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("W")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:921:1, end:921:5))"]
#[derive(Clone, Debug)]
struct fmt3Var2 {}
impl fmt3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefmt3 {
    Var0(fmt3Var0),
    Var1(fmt3Var1),
    Var2(fmt3Var2),
}
impl Tablefmt3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:923:1, end:923:5))"]
#[derive(Clone, Debug)]
struct fmt4Var0 {}
impl fmt4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("D")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:924:1, end:924:5))"]
#[derive(Clone, Debug)]
struct fmt4Var1 {}
impl fmt4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("W")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:925:1, end:925:5))"]
#[derive(Clone, Debug)]
struct fmt4Var2 {}
impl fmt4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefmt4 {
    Var0(fmt4Var0),
    Var1(fmt4Var1),
    Var2(fmt4Var2),
}
impl Tablefmt4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:927:1, end:927:5))"]
#[derive(Clone, Debug)]
struct fmt5Var0 {}
impl fmt5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("S")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:928:1, end:928:5))"]
#[derive(Clone, Debug)]
struct fmt5Var1 {}
impl fmt5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("D")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:929:1, end:929:5))"]
#[derive(Clone, Debug)]
struct fmt5Var2 {}
impl fmt5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("PS")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefmt5 {
    Var0(fmt5Var0),
    Var1(fmt5Var1),
    Var2(fmt5Var2),
}
impl Tablefmt5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 7) == 0 {
            if let Some((inst_len, parsed)) =
                fmt5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 7) == 1 {
            if let Some((inst_len, parsed)) =
                fmt5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 7) == 6 {
            if let Some((inst_len, parsed)) =
                fmt5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:932:1, end:932:5))"]
#[derive(Clone, Debug)]
struct fmt6Var0 {}
impl fmt6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("S")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips.sinc, start:933:1, end:933:5))"]
#[derive(Clone, Debug)]
struct fmt6Var1 {}
impl fmt6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("D")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefmt6 {
    Var0(fmt6Var0),
    Var1(fmt6Var1),
}
impl Tablefmt6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                fmt6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:101:1, end:101:3))"]
#[derive(Clone, Debug)]
struct RZVar0 {}
impl RZVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableRZ {
    Var0(RZVar0),
}
impl TableRZ {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                RZVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:105:1, end:105:3))"]
#[derive(Clone, Debug)]
struct RXVar0 {
    m16_rx: u8,
}
impl RXVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_21_display(self.m16_rx)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx }))
    }
}
#[derive(Clone, Debug)]
enum TableRX {
    Var0(RXVar0),
}
impl TableRX {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RXVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:106:1, end:106:5))"]
#[derive(Clone, Debug)]
struct RX32Var0 {
    m16_rx: u8,
}
impl RX32Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_21_display(self.m16_rx)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rx = token_54(tokens_current);
        let m16_rxa = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rx }))
    }
}
#[derive(Clone, Debug)]
enum TableRX32 {
    Var0(RX32Var0),
}
impl TableRX32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RX32Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:107:1, end:107:5))"]
#[derive(Clone, Debug)]
struct RY32Var0 {
    m16_ry: u8,
}
impl RY32Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_21_display(self.m16_ry)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_ry = token_55(tokens_current);
        let m16_rya = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_ry }))
    }
}
#[derive(Clone, Debug)]
enum TableRY32 {
    Var0(RY32Var0),
}
impl TableRY32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RY32Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:108:1, end:108:5))"]
#[derive(Clone, Debug)]
struct RZ32Var0 {
    m16_rz: u8,
}
impl RZ32Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_21_display(self.m16_rz)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rza = token_59(tokens_current);
        let m16_rz = token_59(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rz }))
    }
}
#[derive(Clone, Debug)]
enum TableRZ32 {
    Var0(RZ32Var0),
}
impl TableRZ32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RZ32Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:122:1, end:122:10))"]
#[derive(Clone, Debug)]
struct Abs26_m16Var0 {
    m16_tgt_1500: u16,
}
impl Abs26_m16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 18446744073441116160i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    ((i128::try_from(self.m16_tgt_1500).unwrap()
                        | u32::try_from(16i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(context.read_ext_tgt_2016())
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0))
                        | u32::try_from(21i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(context.read_ext_tgt_2521())
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0)),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 18446744073441116160i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    ((i128::try_from(token_68(tokens_current)).unwrap()
                        | u32::try_from(16i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(context_instance.read_ext_tgt_2016())
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0))
                        | u32::try_from(21i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(context_instance.read_ext_tgt_2521())
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0)),
                ),
            );
        let m16_tgt_1500 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_tgt_1500 }))
    }
}
#[derive(Clone, Debug)]
enum TableAbs26_m16 {
    Var0(Abs26_m16Var0),
}
impl TableAbs26_m16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Abs26_m16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:123:1, end:123:10))"]
#[derive(Clone, Debug)]
struct Rel16_m16Var0 {
    m16_b_imm: u8,
}
impl Rel16_m16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    ((u32::try_from(11i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(context.read_ext_value_1511s())
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)
                        | u32::try_from(5i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(context.read_ext_value_1005())
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0))
                        | i128::try_from(self.m16_b_imm).unwrap()),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    ((u32::try_from(11i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(context_instance.read_ext_value_1511s())
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)
                        | u32::try_from(5i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(context_instance.read_ext_value_1005())
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0))
                        | i128::try_from(token_53(tokens_current)).unwrap()),
                ),
            );
        let m16_b_imm = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_b_imm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:124:1, end:124:10))"]
#[derive(Clone, Debug)]
struct Rel16_m16Var1 {
    m16_b_off: u16,
}
impl Rel16_m16Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    i128::try_from(
                        (if self.m16_b_off & 1024 != 0 {
                            -1 & !1023
                        } else {
                            0
                        } | self.m16_b_off as i16),
                    )
                    .unwrap(),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(2i128.wrapping_mul(i128::try_from(token_67(tokens_current)).unwrap()));
        let m16_b_off = token_67(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_b_off }))
    }
}
#[derive(Clone, Debug)]
enum TableRel16_m16 {
    Var0(Rel16_m16Var0),
    Var1(Rel16_m16Var1),
}
impl TableRel16_m16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 7) == 0
        {
            if let Some((inst_len, parsed)) =
                Rel16_m16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                Rel16_m16Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:126:1, end:126:11))"]
#[derive(Clone, Debug)]
struct CRel16_m16Var0 {
    m16_b_imm: u8,
}
impl CRel16_m16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    ((u32::try_from(11i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(context.read_ext_value_1511s())
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)
                        | u32::try_from(5i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(context.read_ext_value_1005())
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0))
                        | i128::try_from(self.m16_b_imm).unwrap()),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    ((u32::try_from(11i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(context_instance.read_ext_value_1511s())
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)
                        | u32::try_from(5i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(context_instance.read_ext_value_1005())
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0))
                        | i128::try_from(token_53(tokens_current)).unwrap()),
                ),
            );
        let m16_b_imm = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_b_imm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:127:1, end:127:11))"]
#[derive(Clone, Debug)]
struct CRel16_m16Var1 {
    m16_cb_off: u8,
}
impl CRel16_m16Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    i128::try_from(
                        (if self.m16_cb_off & 128 != 0 {
                            -1 & !127
                        } else {
                            0
                        } | self.m16_cb_off as i8),
                    )
                    .unwrap(),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(2i128.wrapping_mul(i128::try_from(token_63(tokens_current)).unwrap()));
        let m16_cb_off = token_63(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_cb_off }))
    }
}
#[derive(Clone, Debug)]
enum TableCRel16_m16 {
    Var0(CRel16_m16Var0),
    Var1(CRel16_m16Var1),
}
impl TableCRel16_m16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                CRel16_m16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                CRel16_m16Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:132:1, end:132:6))"]
#[derive(Clone, Debug)]
struct EXT_IVar0 {
    m16_i_imm: u8,
}
impl EXT_IVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| i128::try_from(self.m16_i_imm).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_53(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let m16_i_imm = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_i_imm }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_I {
    Var0(EXT_IVar0),
}
impl TableEXT_I {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_IVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:133:1, end:133:8))"]
#[derive(Clone, Debug)]
struct EXT_IS0Var0 {
    m16_i_imm: u8,
}
impl EXT_IS0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| i128::try_from(self.m16_i_imm).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_53(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let m16_i_imm = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_i_imm }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_IS0 {
    Var0(EXT_IS0Var0),
}
impl TableEXT_IS0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_IS0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:134:1, end:134:8))"]
#[derive(Clone, Debug)]
struct EXT_IS1Var0 {
    m16_i_imm: u8,
}
impl EXT_IS1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(1i128)
            .ok()
            .and_then(|shl| i128::try_from(self.m16_i_imm).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(1i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_53(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let m16_i_imm = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_i_imm }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_IS1 {
    Var0(EXT_IS1Var0),
}
impl TableEXT_IS1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_IS1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:135:1, end:135:7))"]
#[derive(Clone, Debug)]
struct EXT_RIVar0 {
    m16_ri_imm: u8,
}
impl EXT_RIVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = ((u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_value_1511())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(5i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(context.read_ext_value_1005())
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0))
            | i128::try_from(self.m16_ri_imm).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = ((u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_value_1511())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(5i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(context_instance.read_ext_value_1005())
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0))
            | i128::try_from(token_53(tokens_current)).unwrap());
        let m16_ri_imm = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_ri_imm }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_RI {
    Var0(EXT_RIVar0),
}
impl TableEXT_RI {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_RIVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:136:1, end:136:9))"]
#[derive(Clone, Debug)]
struct EXT_RRIAVar0 {
    m16_rria_imm: u8,
}
impl EXT_RRIAVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = ((u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_value_1411s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(4i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(context.read_ext_value_1004())
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0))
            | i128::try_from(self.m16_rria_imm).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = ((u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_value_1411s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(4i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(context_instance.read_ext_value_1004())
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0))
            | i128::try_from(token_62(tokens_current)).unwrap());
        let m16_rria_imm = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rria_imm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:137:1, end:137:9))"]
#[derive(Clone, Debug)]
struct EXT_RRIAVar1 {
    m16_rria_simm: u8,
}
impl EXT_RRIAVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Number(
            true,
            (if self.m16_rria_simm & 8 != 0 {
                -1 & !7
            } else {
                0
            } | self.m16_rria_simm as i8)
                .is_negative(),
            (if self.m16_rria_simm & 8 != 0 {
                -1 & !7
            } else {
                0
            } | self.m16_rria_simm as i8)
                .abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_rria_simm = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_rria_simm }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_RRIA {
    Var0(EXT_RRIAVar0),
    Var1(EXT_RRIAVar1),
}
impl TableEXT_RRIA {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 {
            if let Some((inst_len, parsed)) =
                EXT_RRIAVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                EXT_RRIAVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:139:1, end:139:8))"]
#[derive(Clone, Debug)]
struct EXT_IS8Var0 {
    m16_i8_imm: u8,
}
impl EXT_IS8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = ((u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_value_1511s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(5i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(context.read_ext_value_1005())
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0))
            | i128::try_from(self.m16_i8_imm).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = ((u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_value_1511s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(5i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(context_instance.read_ext_value_1005())
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0))
            | i128::try_from(token_53(tokens_current)).unwrap());
        let m16_i8_imm = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_i8_imm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:140:1, end:140:8))"]
#[derive(Clone, Debug)]
struct EXT_IS8Var1 {
    m16_is8_imm: u8,
}
impl EXT_IS8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Number(
            true,
            (if self.m16_is8_imm & 128 != 0 {
                -1 & !127
            } else {
                0
            } | self.m16_is8_imm as i8)
                .is_negative(),
            (if self.m16_is8_imm & 128 != 0 {
                -1 & !127
            } else {
                0
            } | self.m16_is8_imm as i8)
                .abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_is8_imm = token_63(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_is8_imm }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_IS8 {
    Var0(EXT_IS8Var0),
    Var1(EXT_IS8Var1),
}
impl TableEXT_IS8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 {
            if let Some((inst_len, parsed)) =
                EXT_IS8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                EXT_IS8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:141:1, end:141:10))"]
#[derive(Clone, Debug)]
struct EXT_IS8L3Var0 {
    m16_is8_imm: u8,
}
impl EXT_IS8L3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(3i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.m16_is8_imm & 128 != 0 {
                        -1 & !127
                    } else {
                        0
                    } | self.m16_is8_imm as i8),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(3i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_63(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let m16_is8_imm = token_63(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_is8_imm }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_IS8L3 {
    Var0(EXT_IS8L3Var0),
}
impl TableEXT_IS8L3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                EXT_IS8L3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:143:1, end:143:8))"]
#[derive(Clone, Debug)]
struct EXT_IU8Var0 {
    m16_i8_imm: u8,
}
impl EXT_IU8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = ((u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_value_1511())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(5i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(context.read_ext_value_1005())
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0))
            | i128::try_from(self.m16_i8_imm).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = ((u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_value_1511())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(5i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(context_instance.read_ext_value_1005())
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0))
            | i128::try_from(token_53(tokens_current)).unwrap());
        let m16_i8_imm = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_i8_imm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:144:1, end:144:8))"]
#[derive(Clone, Debug)]
struct EXT_IU8Var1 {
    m16_iu8_imm: u8,
}
impl EXT_IU8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| i128::try_from(self.m16_iu8_imm).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_63(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let m16_iu8_imm = token_63(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_iu8_imm }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_IU8 {
    Var0(EXT_IU8Var0),
    Var1(EXT_IU8Var1),
}
impl TableEXT_IU8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 {
            if let Some((inst_len, parsed)) =
                EXT_IU8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                EXT_IU8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:146:1, end:146:9))"]
#[derive(Clone, Debug)]
struct EXT_LIU8Var0 {
    m16_i8_imm: u8,
}
impl EXT_LIU8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = ((u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_value_1511())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(5i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(context.read_ext_value_1005())
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0))
            | i128::try_from(self.m16_i8_imm).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = ((u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_value_1511())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(5i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(context_instance.read_ext_value_1005())
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0))
            | i128::try_from(token_53(tokens_current)).unwrap());
        let m16_i8_imm = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_i8_imm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:147:1, end:147:9))"]
#[derive(Clone, Debug)]
struct EXT_LIU8Var1 {
    m16_iu8_imm: u8,
}
impl EXT_LIU8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.m16_iu8_imm as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_iu8_imm = token_63(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_iu8_imm }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_LIU8 {
    Var0(EXT_LIU8Var0),
    Var1(EXT_LIU8Var1),
}
impl TableEXT_LIU8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                EXT_LIU8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                EXT_LIU8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:149:1, end:149:10))"]
#[derive(Clone, Debug)]
struct EXT_SHIFTVar0 {}
impl EXT_SHIFTVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Number(
            true,
            false,
            context.read_ext_value_sa40() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:150:1, end:150:10))"]
#[derive(Clone, Debug)]
struct EXT_SHIFTVar1 {}
impl EXT_SHIFTVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = 8i128;
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = 8i128;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:151:1, end:151:10))"]
#[derive(Clone, Debug)]
struct EXT_SHIFTVar2 {
    m16_shft_sa: u8,
}
impl EXT_SHIFTVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.m16_shft_sa as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_shft_sa = token_59(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_shft_sa }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_SHIFT {
    Var0(EXT_SHIFTVar0),
    Var1(EXT_SHIFTVar1),
    Var2(EXT_SHIFTVar2),
}
impl TableEXT_SHIFT {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 32512 == 16384
            && (tokens_param[0] & 28) == 0
        {
            if let Some((inst_len, parsed)) =
                EXT_SHIFTVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 && (tokens_param[0] & 28) == 0 {
            if let Some((inst_len, parsed)) =
                EXT_SHIFTVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                EXT_SHIFTVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:153:1, end:153:8))"]
#[derive(Clone, Debug)]
struct EXT_SETVar0 {
    m16_i8_imm: u8,
}
impl EXT_SETVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = ((u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_value_1511())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(5i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(context.read_ext_value_1005())
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0))
            | i128::try_from(self.m16_i8_imm).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = ((u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_value_1511())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(5i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(context_instance.read_ext_value_1005())
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0))
            | i128::try_from(token_53(tokens_current)).unwrap());
        let m16_i8_imm = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_i8_imm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:154:1, end:154:8))"]
#[derive(Clone, Debug)]
struct EXT_SETVar1 {
    m16_iu8_imm: u8,
}
impl EXT_SETVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.m16_iu8_imm as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_iu8_imm = token_63(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_iu8_imm }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_SET {
    Var0(EXT_SETVar0),
    Var1(EXT_SETVar1),
}
impl TableEXT_SET {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                EXT_SETVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                EXT_SETVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:156:1, end:156:8))"]
#[derive(Clone, Debug)]
struct OFF_M16Var0 {
    m16_rx: u8,
    EXT_IS8: TableEXT_IS8,
}
impl OFF_M16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.EXT_IS8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_IS8 = if let Some((len, table)) =
            TableEXT_IS8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_IS8, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:157:1, end:157:8))"]
#[derive(Clone, Debug)]
struct OFF_M16Var1 {
    m16_rx: u8,
    EXT_I: TableEXT_I,
}
impl OFF_M16Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.EXT_I
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_I = if let Some((len, table)) =
            TableEXT_I::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_I, m16_rx }))
    }
}
#[derive(Clone, Debug)]
enum TableOFF_M16 {
    Var0(OFF_M16Var0),
    Var1(OFF_M16Var1),
}
impl TableOFF_M16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 {
            if let Some((inst_len, parsed)) =
                OFF_M16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                OFF_M16Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:158:1, end:158:10))"]
#[derive(Clone, Debug)]
struct OFF_M16S0Var0 {
    m16_rx: u8,
    EXT_IS8: TableEXT_IS8,
}
impl OFF_M16S0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.EXT_IS8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_IS8 = if let Some((len, table)) =
            TableEXT_IS8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_IS8, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:159:1, end:159:10))"]
#[derive(Clone, Debug)]
struct OFF_M16S0Var1 {
    m16_rx: u8,
    EXT_IS0: TableEXT_IS0,
}
impl OFF_M16S0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.EXT_IS0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_IS0 = if let Some((len, table)) =
            TableEXT_IS0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_IS0, m16_rx }))
    }
}
#[derive(Clone, Debug)]
enum TableOFF_M16S0 {
    Var0(OFF_M16S0Var0),
    Var1(OFF_M16S0Var1),
}
impl TableOFF_M16S0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 {
            if let Some((inst_len, parsed)) =
                OFF_M16S0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                OFF_M16S0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:160:1, end:160:10))"]
#[derive(Clone, Debug)]
struct OFF_M16S1Var0 {
    m16_rx: u8,
    EXT_IS8: TableEXT_IS8,
}
impl OFF_M16S1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.EXT_IS8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_IS8 = if let Some((len, table)) =
            TableEXT_IS8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_IS8, m16_rx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:161:1, end:161:10))"]
#[derive(Clone, Debug)]
struct OFF_M16S1Var1 {
    m16_rx: u8,
    EXT_IS1: TableEXT_IS1,
}
impl OFF_M16S1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.EXT_IS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_21_display(self.m16_rx),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_IS1 = if let Some((len, table)) =
            TableEXT_IS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_rx = token_54(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_IS1, m16_rx }))
    }
}
#[derive(Clone, Debug)]
enum TableOFF_M16S1 {
    Var0(OFF_M16S1Var0),
    Var1(OFF_M16S1Var1),
}
impl TableOFF_M16S1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 {
            if let Some((inst_len, parsed)) =
                OFF_M16S1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                OFF_M16S1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:163:1, end:163:10))"]
#[derive(Clone, Debug)]
struct OFF_M16PCVar0 {
    EXT_IS8: TableEXT_IS8,
}
impl OFF_M16PCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.EXT_IS8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_IS8 = if let Some((len, table)) =
            TableEXT_IS8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_IS8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:164:1, end:164:10))"]
#[derive(Clone, Debug)]
struct OFF_M16PCVar1 {
    m16_iu8_imm: u8,
}
impl OFF_M16PCVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| i128::try_from(self.m16_iu8_imm).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Number(true, calc_val.is_negative(), calc_val.abs() as u64),
            <DisplayElement>::Literal("("),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_63(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let m16_iu8_imm = token_63(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_iu8_imm }))
    }
}
#[derive(Clone, Debug)]
enum TableOFF_M16PC {
    Var0(OFF_M16PCVar0),
    Var1(OFF_M16PCVar1),
}
impl TableOFF_M16PC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                OFF_M16PCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                OFF_M16PCVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:166:1, end:166:10))"]
#[derive(Clone, Debug)]
struct OFF_M16SPVar0 {
    EXT_IS8: TableEXT_IS8,
}
impl OFF_M16SPVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.EXT_IS8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_IS8 = if let Some((len, table)) =
            TableEXT_IS8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { EXT_IS8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:167:1, end:167:10))"]
#[derive(Clone, Debug)]
struct OFF_M16SPVar1 {
    m16_iu8_imm: u8,
}
impl OFF_M16SPVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| i128::try_from(self.m16_iu8_imm).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Number(true, calc_val.is_negative(), calc_val.abs() as u64),
            <DisplayElement>::Literal("("),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_63(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let m16_iu8_imm = token_63(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_iu8_imm }))
    }
}
#[derive(Clone, Debug)]
enum TableOFF_M16SP {
    Var0(OFF_M16SPVar0),
    Var1(OFF_M16SPVar1),
}
impl TableOFF_M16SP {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                OFF_M16SPVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                OFF_M16SPVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:169:1, end:169:10))"]
#[derive(Clone, Debug)]
struct EXT_FRAMEVar0 {}
impl EXT_FRAMEVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = 128i128;
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = 128i128;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:170:1, end:170:10))"]
#[derive(Clone, Debug)]
struct EXT_FRAMEVar1 {
    m16_svrs_frame: u8,
}
impl EXT_FRAMEVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(3i128)
            .ok()
            .and_then(|shl| {
                (u32::try_from(4i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(context.read_ext_value_frame())
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | i128::try_from(self.m16_svrs_frame).unwrap())
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(3i128)
            .ok()
            .and_then(|shl| {
                (u32::try_from(4i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(context_instance.read_ext_value_frame())
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | i128::try_from(token_62(tokens_current)).unwrap())
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let m16_svrs_frame = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m16_svrs_frame }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_FRAME {
    Var0(EXT_FRAMEVar0),
    Var1(EXT_FRAMEVar1),
}
impl TableEXT_FRAME {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 960 == 0 && (tokens_param[0] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                EXT_FRAMEVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_FRAMEVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:173:1, end:173:11))"]
#[derive(Clone, Debug)]
struct REGRS_STATVar0 {}
impl REGRS_STATVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a3")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let mut sub_pattern_c26 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if context_param.read_ext_value_areg() == 1 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_areg() == 5 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_areg() == 9 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_areg() == 13 {
                    return Some(((), (), 0));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c26(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:177:1, end:177:11))"]
#[derive(Clone, Debug)]
struct REGRS_STATVar1 {}
impl REGRS_STATVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a2-a3")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if context_param.read_ext_value_areg() == 2 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_areg() == 6 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_areg() == 10 {
                    return Some(((), (), 0));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:183:1, end:183:11))"]
#[derive(Clone, Debug)]
struct REGRS_STATVar2 {}
impl REGRS_STATVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a1-a3")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if context_param.read_ext_value_areg() == 3 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_areg() == 7 {
                    return Some(((), (), 0));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:191:1, end:191:11))"]
#[derive(Clone, Debug)]
struct REGRS_STATVar3 {}
impl REGRS_STATVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a0-a3")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:172:1, end:172:11))"]
#[derive(Clone, Debug)]
struct REGRS_STATVar4 {}
impl REGRS_STATVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREGRS_STAT {
    Var0(REGRS_STATVar0),
    Var1(REGRS_STATVar1),
    Var2(REGRS_STATVar2),
    Var3(REGRS_STATVar3),
    Var4(REGRS_STATVar4),
}
impl TableREGRS_STAT {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 12288 == 8192 {
            if let Some((inst_len, parsed)) =
                REGRS_STATVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 12288 == 4096 {
            if let Some((inst_len, parsed)) =
                REGRS_STATVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 13312 == 12288 {
            if let Some((inst_len, parsed)) =
                REGRS_STATVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 15360 == 13312 {
            if let Some((inst_len, parsed)) =
                REGRS_STATVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGRS_STATVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:202:1, end:202:10))"]
#[derive(Clone, Debug)]
struct REST_STATVar0 {}
impl REST_STATVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
            if context_param.read_ext_value_areg() == 0 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 4 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 8 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 12 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 14 {
                return Some(((), (), 0));
            }
            None
        };
        let ((), (), block_0_len) = block_0(tokens_current, &mut context_instance)?;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:203:1, end:203:10))"]
#[derive(Clone, Debug)]
struct REST_STATVar1 {
    REGRS_STAT: TableREGRS_STAT,
}
impl REST_STATVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.REGRS_STAT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGRS_STAT = if let Some((len, table)) =
            TableREGRS_STAT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGRS_STAT }))
    }
}
#[derive(Clone, Debug)]
enum TableREST_STAT {
    Var0(REST_STATVar0),
    Var1(REST_STATVar1),
}
impl TableREST_STAT {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 8192 == 0 {
            if let Some((inst_len, parsed)) =
                REST_STATVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REST_STATVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:209:1, end:209:11))"]
#[derive(Clone, Debug)]
struct REGSV_STATVar0 {}
impl REGSV_STATVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a3")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let mut sub_pattern_c26 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if context_param.read_ext_value_areg() == 1 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_areg() == 5 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_areg() == 9 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_areg() == 13 {
                    return Some(((), (), 0));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c26(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:213:1, end:213:11))"]
#[derive(Clone, Debug)]
struct REGSV_STATVar1 {}
impl REGSV_STATVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a2-a3")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let mut sub_pattern_c29 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if context_param.read_ext_value_areg() == 2 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_areg() == 6 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_areg() == 10 {
                    return Some(((), (), 0));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c29(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:219:1, end:219:11))"]
#[derive(Clone, Debug)]
struct REGSV_STATVar2 {}
impl REGSV_STATVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a1-a3")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if context_param.read_ext_value_areg() == 3 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_areg() == 7 {
                    return Some(((), (), 0));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:227:1, end:227:11))"]
#[derive(Clone, Debug)]
struct REGSV_STATVar3 {}
impl REGSV_STATVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a0-a3")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:208:1, end:208:11))"]
#[derive(Clone, Debug)]
struct REGSV_STATVar4 {}
impl REGSV_STATVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_STAT {
    Var0(REGSV_STATVar0),
    Var1(REGSV_STATVar1),
    Var2(REGSV_STATVar2),
    Var3(REGSV_STATVar3),
    Var4(REGSV_STATVar4),
}
impl TableREGSV_STAT {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 12288 == 8192 {
            if let Some((inst_len, parsed)) =
                REGSV_STATVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 12288 == 4096 {
            if let Some((inst_len, parsed)) =
                REGSV_STATVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 13312 == 12288 {
            if let Some((inst_len, parsed)) =
                REGSV_STATVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 15360 == 13312 {
            if let Some((inst_len, parsed)) =
                REGSV_STATVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGSV_STATVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:238:1, end:238:10))"]
#[derive(Clone, Debug)]
struct SAVE_STATVar0 {}
impl SAVE_STATVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
            if context_param.read_ext_value_areg() == 0 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 4 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 8 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 12 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 14 {
                return Some(((), (), 0));
            }
            None
        };
        let ((), (), block_0_len) = block_0(tokens_current, &mut context_instance)?;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:239:1, end:239:10))"]
#[derive(Clone, Debug)]
struct SAVE_STATVar1 {
    REGSV_STAT: TableREGSV_STAT,
}
impl SAVE_STATVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.REGSV_STAT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGSV_STAT = if let Some((len, table)) =
            TableREGSV_STAT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGSV_STAT }))
    }
}
#[derive(Clone, Debug)]
enum TableSAVE_STAT {
    Var0(SAVE_STATVar0),
    Var1(SAVE_STATVar1),
}
impl TableSAVE_STAT {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 8192 == 0 {
            if let Some((inst_len, parsed)) =
                SAVE_STATVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                SAVE_STATVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:243:1, end:243:11))"]
#[derive(Clone, Debug)]
struct REGSV_BLD1Var0 {}
impl REGSV_BLD1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:244:1, end:244:11))"]
#[derive(Clone, Debug)]
struct REGSV_BLD1Var1 {}
impl REGSV_BLD1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("a0,")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_BLD1 {
    Var0(REGSV_BLD1Var0),
    Var1(REGSV_BLD1Var1),
}
impl TableREGSV_BLD1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 2048 == 0 {
            if let Some((inst_len, parsed)) =
                REGSV_BLD1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 2048 == 2048 {
            if let Some((inst_len, parsed)) =
                REGSV_BLD1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:250:1, end:250:11))"]
#[derive(Clone, Debug)]
struct REGSV_BLD2Var0 {}
impl REGSV_BLD2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("a0-a1,")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let mut sub_pattern_c62 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if context_param.read_ext_value_b1() == 0 {
                    return Some(((), (), 0));
                }
                if context_param.read_ext_value_b0() == 0 {
                    return Some(((), (), 0));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c62(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:249:1, end:249:11))"]
#[derive(Clone, Debug)]
struct REGSV_BLD2Var1 {
    REGSV_BLD1: TableREGSV_BLD1,
}
impl REGSV_BLD2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.REGSV_BLD1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGSV_BLD1 = if let Some((len, table)) =
            TableREGSV_BLD1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGSV_BLD1 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_BLD2 {
    Var0(REGSV_BLD2Var0),
    Var1(REGSV_BLD2Var1),
}
impl TableREGSV_BLD2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 3072 == 1024 {
            if let Some((inst_len, parsed)) =
                REGSV_BLD2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGSV_BLD2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:258:1, end:258:11))"]
#[derive(Clone, Debug)]
struct REGSV_BLD3Var0 {}
impl REGSV_BLD3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("a0-a2,")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:257:1, end:257:11))"]
#[derive(Clone, Debug)]
struct REGSV_BLD3Var1 {
    REGSV_BLD2: TableREGSV_BLD2,
}
impl REGSV_BLD3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.REGSV_BLD2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGSV_BLD2 = if let Some((len, table)) =
            TableREGSV_BLD2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGSV_BLD2 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_BLD3 {
    Var0(REGSV_BLD3Var0),
    Var1(REGSV_BLD3Var1),
}
impl TableREGSV_BLD3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 7168 == 3072 {
            if let Some((inst_len, parsed)) =
                REGSV_BLD3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGSV_BLD3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:268:1, end:268:11))"]
#[derive(Clone, Debug)]
struct REGSV_BLD4Var0 {}
impl REGSV_BLD4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("a0-a3,")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:267:1, end:267:11))"]
#[derive(Clone, Debug)]
struct REGSV_BLD4Var1 {
    REGSV_BLD3: TableREGSV_BLD3,
}
impl REGSV_BLD4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.REGSV_BLD3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGSV_BLD3 = if let Some((len, table)) =
            TableREGSV_BLD3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGSV_BLD3 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_BLD4 {
    Var0(REGSV_BLD4Var0),
    Var1(REGSV_BLD4Var1),
}
impl TableREGSV_BLD4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 15360 == 7168 {
            if let Some((inst_len, parsed)) =
                REGSV_BLD4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGSV_BLD4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:279:1, end:279:9))"]
#[derive(Clone, Debug)]
struct SAVE_ARGVar0 {}
impl SAVE_ARGVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
            if context_param.read_ext_value_areg() == 0 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 1 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 2 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 3 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 11 {
                return Some(((), (), 0));
            }
            if context_param.read_ext_value_areg() == 15 {
                return Some(((), (), 0));
            }
            None
        };
        let ((), (), block_0_len) = block_0(tokens_current, &mut context_instance)?;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:280:1, end:280:9))"]
#[derive(Clone, Debug)]
struct SAVE_ARGVar1 {
    REGSV_BLD4: TableREGSV_BLD4,
}
impl SAVE_ARGVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.REGSV_BLD4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGSV_BLD4 = if let Some((len, table)) =
            TableREGSV_BLD4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGSV_BLD4 }))
    }
}
#[derive(Clone, Debug)]
enum TableSAVE_ARG {
    Var0(SAVE_ARGVar0),
    Var1(SAVE_ARGVar1),
}
impl TableSAVE_ARG {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                SAVE_ARGVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                SAVE_ARGVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:285:1, end:285:9))"]
#[derive(Clone, Debug)]
struct REGRS_S0Var0 {}
impl REGRS_S0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:284:1, end:284:9))"]
#[derive(Clone, Debug)]
struct REGRS_S0Var1 {}
impl REGRS_S0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_svrs_s0 = token_58(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREGRS_S0 {
    Var0(REGRS_S0Var0),
    Var1(REGRS_S0Var1),
}
impl TableREGRS_S0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                REGRS_S0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                REGRS_S0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:288:1, end:288:9))"]
#[derive(Clone, Debug)]
struct REGRS_S1Var0 {}
impl REGRS_S1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:287:1, end:287:9))"]
#[derive(Clone, Debug)]
struct REGRS_S1Var1 {}
impl REGRS_S1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_svrs_s1 = token_61(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREGRS_S1 {
    Var0(REGRS_S1Var0),
    Var1(REGRS_S1Var1),
}
impl TableREGRS_S1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                REGRS_S1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                REGRS_S1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:290:1, end:290:9))"]
#[derive(Clone, Debug)]
struct REGRS_S8Var0 {}
impl REGRS_S8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:291:1, end:291:9))"]
#[derive(Clone, Debug)]
struct REGRS_S8Var1 {}
impl REGRS_S8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREGRS_S8 {
    Var0(REGRS_S8Var0),
    Var1(REGRS_S8Var1),
}
impl TableREGRS_S8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 24 {
            if let Some((inst_len, parsed)) =
                REGRS_S8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGRS_S8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:293:1, end:293:9))"]
#[derive(Clone, Debug)]
struct REGRS_S7Var0 {}
impl REGRS_S7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:294:1, end:294:9))"]
#[derive(Clone, Debug)]
struct REGRS_S7Var1 {
    REGRS_S8: TableREGRS_S8,
}
impl REGRS_S7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGRS_S8 = if let Some((len, table)) =
            TableREGRS_S8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGRS_S8 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGRS_S7 {
    Var0(REGRS_S7Var0),
    Var1(REGRS_S7Var1),
}
impl TableREGRS_S7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 40 {
            if let Some((inst_len, parsed)) =
                REGRS_S7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGRS_S7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:296:1, end:296:9))"]
#[derive(Clone, Debug)]
struct REGRS_S6Var0 {}
impl REGRS_S6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:297:1, end:297:9))"]
#[derive(Clone, Debug)]
struct REGRS_S6Var1 {
    REGRS_S7: TableREGRS_S7,
}
impl REGRS_S6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGRS_S7 = if let Some((len, table)) =
            TableREGRS_S7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGRS_S7 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGRS_S6 {
    Var0(REGRS_S6Var0),
    Var1(REGRS_S6Var1),
}
impl TableREGRS_S6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 8 {
            if let Some((inst_len, parsed)) =
                REGRS_S6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGRS_S6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:299:1, end:299:9))"]
#[derive(Clone, Debug)]
struct REGRS_S5Var0 {}
impl REGRS_S5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:300:1, end:300:9))"]
#[derive(Clone, Debug)]
struct REGRS_S5Var1 {
    REGRS_S6: TableREGRS_S6,
}
impl REGRS_S5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGRS_S6 = if let Some((len, table)) =
            TableREGRS_S6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGRS_S6 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGRS_S5 {
    Var0(REGRS_S5Var0),
    Var1(REGRS_S5Var1),
}
impl TableREGRS_S5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 48 {
            if let Some((inst_len, parsed)) =
                REGRS_S5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGRS_S5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:302:1, end:302:9))"]
#[derive(Clone, Debug)]
struct REGRS_S4Var0 {}
impl REGRS_S4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:303:1, end:303:9))"]
#[derive(Clone, Debug)]
struct REGRS_S4Var1 {
    REGRS_S5: TableREGRS_S5,
}
impl REGRS_S4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGRS_S5 = if let Some((len, table)) =
            TableREGRS_S5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGRS_S5 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGRS_S4 {
    Var0(REGRS_S4Var0),
    Var1(REGRS_S4Var1),
}
impl TableREGRS_S4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 16 {
            if let Some((inst_len, parsed)) =
                REGRS_S4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGRS_S4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:305:1, end:305:9))"]
#[derive(Clone, Debug)]
struct REGRS_S3Var0 {}
impl REGRS_S3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:306:1, end:306:9))"]
#[derive(Clone, Debug)]
struct REGRS_S3Var1 {
    REGRS_S4: TableREGRS_S4,
}
impl REGRS_S3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGRS_S4 = if let Some((len, table)) =
            TableREGRS_S4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGRS_S4 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGRS_S3 {
    Var0(REGRS_S3Var0),
    Var1(REGRS_S3Var1),
}
impl TableREGRS_S3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 32 {
            if let Some((inst_len, parsed)) =
                REGRS_S3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGRS_S3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:308:1, end:308:9))"]
#[derive(Clone, Debug)]
struct REGRS_S2Var0 {}
impl REGRS_S2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:309:1, end:309:9))"]
#[derive(Clone, Debug)]
struct REGRS_S2Var1 {
    REGRS_S3: TableREGRS_S3,
}
impl REGRS_S2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGRS_S3 = if let Some((len, table)) =
            TableREGRS_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGRS_S3 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGRS_S2 {
    Var0(REGRS_S2Var0),
    Var1(REGRS_S2Var1),
}
impl TableREGRS_S2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 0 {
            if let Some((inst_len, parsed)) =
                REGRS_S2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGRS_S2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:311:1, end:311:10))"]
#[derive(Clone, Debug)]
struct REST_SREGVar0 {}
impl REST_SREGVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:312:1, end:312:10))"]
#[derive(Clone, Debug)]
struct REST_SREGVar1 {
    m16_svrs_s0: u8,
    m16_svrs_s1: u8,
    REGRS_S1: TableREGRS_S1,
    REGRS_S0: TableREGRS_S0,
    REGRS_S2: TableREGRS_S2,
}
impl REST_SREGVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_37_display(context.read_ext_svrs_sreg()),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_svrs_s0(
            u8::try_from(i128::try_from(token_58(tokens_current)).unwrap() & 1).unwrap(),
        );
        context_instance.write_ext_svrs_s1(
            u8::try_from(i128::try_from(token_61(tokens_current)).unwrap() & 1).unwrap(),
        );
        context_instance.write_ext_svrs_xs(
            u8::try_from(i128::try_from(context_instance.read_ext_value_xreg()).unwrap() & 7)
                .unwrap(),
        );
        let REGRS_S0 = if let Some((len, table)) =
            TableREGRS_S0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REGRS_S1 = if let Some((len, table)) =
            TableREGRS_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REGRS_S2 = if let Some((len, table)) =
            TableREGRS_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_svrs_s1 = token_61(tokens_current);
        let m16_svrs_s0 = token_58(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                REGRS_S1,
                REGRS_S0,
                REGRS_S2,
                m16_svrs_s0,
                m16_svrs_s1,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableREST_SREG {
    Var0(REST_SREGVar0),
    Var1(REST_SREGVar1),
}
impl TableREST_SREG {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 56 == 0 && (tokens_param[0] & 48) == 0 {
            if let Some((inst_len, parsed)) =
                REST_SREGVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                REST_SREGVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:320:1, end:320:9))"]
#[derive(Clone, Debug)]
struct REGSV_S0Var0 {}
impl REGSV_S0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:319:1, end:319:9))"]
#[derive(Clone, Debug)]
struct REGSV_S0Var1 {}
impl REGSV_S0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_svrs_s0 = token_58(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_S0 {
    Var0(REGSV_S0Var0),
    Var1(REGSV_S0Var1),
}
impl TableREGSV_S0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                REGSV_S0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                REGSV_S0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:323:1, end:323:9))"]
#[derive(Clone, Debug)]
struct REGSV_S1Var0 {}
impl REGSV_S1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:322:1, end:322:9))"]
#[derive(Clone, Debug)]
struct REGSV_S1Var1 {}
impl REGSV_S1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m16_svrs_s1 = token_61(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_S1 {
    Var0(REGSV_S1Var0),
    Var1(REGSV_S1Var1),
}
impl TableREGSV_S1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                REGSV_S1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                REGSV_S1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:325:1, end:325:9))"]
#[derive(Clone, Debug)]
struct REGSV_S8Var0 {}
impl REGSV_S8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:326:1, end:326:9))"]
#[derive(Clone, Debug)]
struct REGSV_S8Var1 {}
impl REGSV_S8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_S8 {
    Var0(REGSV_S8Var0),
    Var1(REGSV_S8Var1),
}
impl TableREGSV_S8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 24 {
            if let Some((inst_len, parsed)) =
                REGSV_S8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGSV_S8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:328:1, end:328:9))"]
#[derive(Clone, Debug)]
struct REGSV_S7Var0 {}
impl REGSV_S7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:329:1, end:329:9))"]
#[derive(Clone, Debug)]
struct REGSV_S7Var1 {
    REGSV_S8: TableREGSV_S8,
}
impl REGSV_S7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGSV_S8 = if let Some((len, table)) =
            TableREGSV_S8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGSV_S8 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_S7 {
    Var0(REGSV_S7Var0),
    Var1(REGSV_S7Var1),
}
impl TableREGSV_S7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 40 {
            if let Some((inst_len, parsed)) =
                REGSV_S7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGSV_S7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:331:1, end:331:9))"]
#[derive(Clone, Debug)]
struct REGSV_S6Var0 {}
impl REGSV_S6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:332:1, end:332:9))"]
#[derive(Clone, Debug)]
struct REGSV_S6Var1 {
    REGSV_S7: TableREGSV_S7,
}
impl REGSV_S6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGSV_S7 = if let Some((len, table)) =
            TableREGSV_S7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGSV_S7 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_S6 {
    Var0(REGSV_S6Var0),
    Var1(REGSV_S6Var1),
}
impl TableREGSV_S6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 8 {
            if let Some((inst_len, parsed)) =
                REGSV_S6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGSV_S6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:334:1, end:334:9))"]
#[derive(Clone, Debug)]
struct REGSV_S5Var0 {}
impl REGSV_S5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:335:1, end:335:9))"]
#[derive(Clone, Debug)]
struct REGSV_S5Var1 {
    REGSV_S6: TableREGSV_S6,
}
impl REGSV_S5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGSV_S6 = if let Some((len, table)) =
            TableREGSV_S6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGSV_S6 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_S5 {
    Var0(REGSV_S5Var0),
    Var1(REGSV_S5Var1),
}
impl TableREGSV_S5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 48 {
            if let Some((inst_len, parsed)) =
                REGSV_S5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGSV_S5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:337:1, end:337:9))"]
#[derive(Clone, Debug)]
struct REGSV_S4Var0 {}
impl REGSV_S4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:338:1, end:338:9))"]
#[derive(Clone, Debug)]
struct REGSV_S4Var1 {
    REGSV_S5: TableREGSV_S5,
}
impl REGSV_S4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGSV_S5 = if let Some((len, table)) =
            TableREGSV_S5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGSV_S5 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_S4 {
    Var0(REGSV_S4Var0),
    Var1(REGSV_S4Var1),
}
impl TableREGSV_S4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 16 {
            if let Some((inst_len, parsed)) =
                REGSV_S4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGSV_S4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:340:1, end:340:9))"]
#[derive(Clone, Debug)]
struct REGSV_S3Var0 {}
impl REGSV_S3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:341:1, end:341:9))"]
#[derive(Clone, Debug)]
struct REGSV_S3Var1 {
    REGSV_S4: TableREGSV_S4,
}
impl REGSV_S3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGSV_S4 = if let Some((len, table)) =
            TableREGSV_S4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGSV_S4 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_S3 {
    Var0(REGSV_S3Var0),
    Var1(REGSV_S3Var1),
}
impl TableREGSV_S3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 32 {
            if let Some((inst_len, parsed)) =
                REGSV_S3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGSV_S3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:343:1, end:343:9))"]
#[derive(Clone, Debug)]
struct REGSV_S2Var0 {}
impl REGSV_S2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:344:1, end:344:9))"]
#[derive(Clone, Debug)]
struct REGSV_S2Var1 {
    REGSV_S3: TableREGSV_S3,
}
impl REGSV_S2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let REGSV_S3 = if let Some((len, table)) =
            TableREGSV_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REGSV_S3 }))
    }
}
#[derive(Clone, Debug)]
enum TableREGSV_S2 {
    Var0(REGSV_S2Var0),
    Var1(REGSV_S2Var1),
}
impl TableREGSV_S2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 56 == 0 {
            if let Some((inst_len, parsed)) =
                REGSV_S2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                REGSV_S2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:346:1, end:346:10))"]
#[derive(Clone, Debug)]
struct SAVE_SREGVar0 {}
impl SAVE_SREGVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:347:1, end:347:10))"]
#[derive(Clone, Debug)]
struct SAVE_SREGVar1 {
    m16_svrs_s0: u8,
    m16_svrs_s1: u8,
    REGSV_S0: TableREGSV_S0,
    REGSV_S2: TableREGSV_S2,
    REGSV_S1: TableREGSV_S1,
}
impl SAVE_SREGVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_37_display(context.read_ext_svrs_sreg()),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_svrs_s0(
            u8::try_from(i128::try_from(token_58(tokens_current)).unwrap() & 1).unwrap(),
        );
        context_instance.write_ext_svrs_s1(
            u8::try_from(i128::try_from(token_61(tokens_current)).unwrap() & 1).unwrap(),
        );
        context_instance.write_ext_svrs_xs(
            u8::try_from(i128::try_from(context_instance.read_ext_value_xreg()).unwrap() & 7)
                .unwrap(),
        );
        let REGSV_S0 = if let Some((len, table)) =
            TableREGSV_S0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REGSV_S1 = if let Some((len, table)) =
            TableREGSV_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REGSV_S2 = if let Some((len, table)) =
            TableREGSV_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m16_svrs_s0 = token_58(tokens_current);
        let m16_svrs_s1 = token_61(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                REGSV_S0,
                REGSV_S2,
                REGSV_S1,
                m16_svrs_s0,
                m16_svrs_s1,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableSAVE_SREG {
    Var0(SAVE_SREGVar0),
    Var1(SAVE_SREGVar1),
}
impl TableSAVE_SREG {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 56 == 0 && (tokens_param[0] & 48) == 0 {
            if let Some((inst_len, parsed)) =
                SAVE_SREGVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                SAVE_SREGVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:354:1, end:354:8))"]
#[derive(Clone, Debug)]
struct REST_RAVar0 {}
impl REST_RAVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:355:1, end:355:8))"]
#[derive(Clone, Debug)]
struct REST_RAVar1 {}
impl REST_RAVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",ra")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREST_RA {
    Var0(REST_RAVar0),
    Var1(REST_RAVar1),
}
impl TableREST_RA {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                REST_RAVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                REST_RAVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:360:1, end:360:8))"]
#[derive(Clone, Debug)]
struct SAVE_RAVar0 {}
impl SAVE_RAVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:361:1, end:361:8))"]
#[derive(Clone, Debug)]
struct SAVE_RAVar1 {}
impl SAVE_RAVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",ra")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSAVE_RA {
    Var0(SAVE_RAVar0),
    Var1(SAVE_RAVar1),
}
impl TableSAVE_RA {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                SAVE_RAVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                SAVE_RAVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:366:1, end:366:9))"]
#[derive(Clone, Debug)]
struct REST_TOPVar0 {
    EXT_FRAME: TableEXT_FRAME,
    REST_STAT: TableREST_STAT,
    REST_SREG: TableREST_SREG,
    REST_RA: TableREST_RA,
}
impl REST_TOPVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.EXT_FRAME
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.REST_RA
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.REST_SREG
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.REST_STAT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_FRAME = if let Some((len, table)) =
            TableEXT_FRAME::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REST_RA = if let Some((len, table)) =
            TableREST_RA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REST_SREG = if let Some((len, table)) =
            TableREST_SREG::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REST_STAT = if let Some((len, table)) =
            TableREST_STAT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_FRAME,
                REST_STAT,
                REST_SREG,
                REST_RA,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableREST_TOP {
    Var0(REST_TOPVar0),
}
impl TableREST_TOP {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                REST_TOPVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mips16.sinc, start:379:1, end:379:9))"]
#[derive(Clone, Debug)]
struct SAVE_TOPVar0 {
    SAVE_RA: TableSAVE_RA,
    SAVE_SREG: TableSAVE_SREG,
    SAVE_STAT: TableSAVE_STAT,
    EXT_FRAME: TableEXT_FRAME,
    SAVE_ARG: TableSAVE_ARG,
}
impl SAVE_TOPVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.SAVE_ARG
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.EXT_FRAME
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SAVE_RA
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SAVE_SREG
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SAVE_STAT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let EXT_FRAME = if let Some((len, table)) =
            TableEXT_FRAME::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SAVE_RA = if let Some((len, table)) =
            TableSAVE_RA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SAVE_SREG = if let Some((len, table)) =
            TableSAVE_SREG::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SAVE_ARG = if let Some((len, table)) =
            TableSAVE_ARG::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SAVE_STAT = if let Some((len, table)) =
            TableSAVE_STAT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SAVE_RA,
                SAVE_SREG,
                SAVE_STAT,
                EXT_FRAME,
                SAVE_ARG,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableSAVE_TOP {
    Var0(SAVE_TOPVar0),
}
impl TableSAVE_TOP {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                SAVE_TOPVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:272:1, end:272:5))"]
#[derive(Clone, Debug)]
struct RD5LVar0 {
    mic_rd32_5: u8,
}
impl RD5LVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rd32_5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rd32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rd32_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:271:1, end:271:5))"]
#[derive(Clone, Debug)]
struct RD5LVar1 {
    mic_rd32_5: u8,
}
impl RD5LVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rd32_5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rd32_5lo = token_69(tokens_current);
        let mic_rd32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rd32_5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRD5L {
    Var0(RD5LVar0),
    Var1(RD5LVar1),
}
impl TableRD5L {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 224) == 0 && (tokens_param[1] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                RD5LVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RD5LVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:274:1, end:274:6))"]
#[derive(Clone, Debug)]
struct RD7R1Var0 {
    mic_rd7: u8,
}
impl RD7R1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_25_display(self.mic_rd7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rd7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rd7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:275:1, end:275:6))"]
#[derive(Clone, Debug)]
struct RD7R1Var1 {
    mic_rd1: u8,
}
impl RD7R1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_25_display(self.mic_rd1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rd1 = token_77(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rd1 }))
    }
}
#[derive(Clone, Debug)]
enum TableRD7R1 {
    Var0(RD7R1Var0),
    Var1(RD7R1Var1),
}
impl TableRD7R1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                RD7R1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                RD7R1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:278:1, end:278:7))"]
#[derive(Clone, Debug)]
struct RSEXTLVar0 {}
impl RSEXTLVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(context.read_ext_32_rs1())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:277:1, end:277:7))"]
#[derive(Clone, Debug)]
struct RSEXTLVar1 {}
impl RSEXTLVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(context.read_ext_32_rs1())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableRSEXTL {
    Var0(RSEXTLVar0),
    Var1(RSEXTLVar1),
}
impl TableRSEXTL {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 3968 == 0 {
            if let Some((inst_len, parsed)) =
                RSEXTLVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                RSEXTLVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:281:1, end:281:5))"]
#[derive(Clone, Debug)]
struct RS0LVar0 {
    mic_rs32_0: u8,
}
impl RS0LVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:280:1, end:280:5))"]
#[derive(Clone, Debug)]
struct RS0LVar1 {
    mic_rs32_0: u8,
}
impl RS0LVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        let mic_rs32_0lo = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableRS0L {
    Var0(RS0LVar0),
    Var1(RS0LVar1),
}
impl TableRS0L {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                RS0LVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RS0LVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:282:1, end:282:5))"]
#[derive(Clone, Debug)]
struct RS4LVar0 {
    mic_rs4: u8,
}
impl RS4LVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_25_display(self.mic_rs4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs4lo = token_75(tokens_current);
        let mic_rs4 = token_75(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs4 }))
    }
}
#[derive(Clone, Debug)]
enum TableRS4L {
    Var0(RS4LVar0),
}
impl TableRS4L {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RS4LVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:284:1, end:284:6))"]
#[derive(Clone, Debug)]
struct RS0R4Var0 {
    mic_rs0: u8,
}
impl RS0R4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_25_display(self.mic_rs0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs0 = token_64(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:285:1, end:285:6))"]
#[derive(Clone, Debug)]
struct RS0R4Var1 {
    mic_rs4: u8,
}
impl RS0R4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_25_display(self.mic_rs4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs4 = token_75(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs4 }))
    }
}
#[derive(Clone, Debug)]
enum TableRS0R4 {
    Var0(RS0R4Var0),
    Var1(RS0R4Var1),
}
impl TableRS0R4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                RS0R4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                RS0R4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:287:1, end:287:6))"]
#[derive(Clone, Debug)]
struct RS0R5Var0 {
    mic_rs32_0: u8,
}
impl RS0R5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:289:1, end:289:6))"]
#[derive(Clone, Debug)]
struct RS0R5Var1 {
    mic_rs32_5: u8,
}
impl RS0R5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:286:1, end:286:6))"]
#[derive(Clone, Debug)]
struct RS0R5Var2 {
    mic_rs32_0: u8,
}
impl RS0R5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:288:1, end:288:6))"]
#[derive(Clone, Debug)]
struct RS0R5Var3 {
    mic_rs32_5: u8,
}
impl RS0R5Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRS0R5 {
    Var0(RS0R5Var0),
    Var1(RS0R5Var1),
    Var2(RS0R5Var2),
    Var3(RS0R5Var3),
}
impl TableRS0R5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 536870912 == 0
            && (tokens_param[0] & 31) == 0
        {
            if let Some((inst_len, parsed)) =
                RS0R5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 536870912 == 536870912
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 3) == 0
        {
            if let Some((inst_len, parsed)) =
                RS0R5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                RS0R5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                RS0R5Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:291:1, end:291:7))"]
#[derive(Clone, Debug)]
struct RS1R7LVar0 {
    mic_rs1: u8,
}
impl RS1R7LVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_25_display(self.mic_rs1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs1 = token_77(tokens_current);
        let mic_rs1lo = token_77(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:292:1, end:292:7))"]
#[derive(Clone, Debug)]
struct RS1R7LVar1 {
    mic_rs7: u8,
}
impl RS1R7LVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_25_display(self.mic_rs7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs7 = token_76(tokens_current);
        let mic_rs7lo = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs7 }))
    }
}
#[derive(Clone, Debug)]
enum TableRS1R7L {
    Var0(RS1R7LVar0),
    Var1(RS1R7LVar1),
}
impl TableRS1R7L {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                RS1R7LVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                RS1R7LVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:294:1, end:294:5))"]
#[derive(Clone, Debug)]
struct RT4LVar0 {
    mic_rt4: u8,
}
impl RT4LVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_25_display(self.mic_rt4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt4lo = token_75(tokens_current);
        let mic_rt4 = token_75(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt4 }))
    }
}
#[derive(Clone, Debug)]
enum TableRT4L {
    Var0(RT4LVar0),
}
impl TableRT4L {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RT4LVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:296:1, end:296:5))"]
#[derive(Clone, Debug)]
struct RT5LVar0 {
    mic_rt32_5: u8,
}
impl RT5LVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rt32_5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt32_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:295:1, end:295:5))"]
#[derive(Clone, Debug)]
struct RT5LVar1 {
    mic_rt32_5: u8,
}
impl RT5LVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rt32_5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5lo = token_69(tokens_current);
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt32_5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRT5L {
    Var0(RT5LVar0),
    Var1(RT5LVar1),
}
impl TableRT5L {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 224) == 0 && (tokens_param[1] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                RT5LVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RT5LVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:299:1, end:299:6))"]
#[derive(Clone, Debug)]
struct RT3R7Var0 {
    mic_rt3: u8,
}
impl RT3R7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_25_display(self.mic_rt3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt3 = token_78(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:300:1, end:300:6))"]
#[derive(Clone, Debug)]
struct RT3R7Var1 {
    mic_rt7: u8,
}
impl RT3R7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_25_display(self.mic_rt7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt7 }))
    }
}
#[derive(Clone, Debug)]
enum TableRT3R7 {
    Var0(RT3R7Var0),
    Var1(RT3R7Var1),
}
impl TableRT3R7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                RT3R7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                RT3R7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:304:1, end:304:7))"]
#[derive(Clone, Debug)]
struct RST7R5Var0 {
    mic_rt32_5: u8,
}
impl RST7R5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rt32_5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt32_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:302:1, end:302:7))"]
#[derive(Clone, Debug)]
struct RST7R5Var1 {
    mic_rs7: u8,
}
impl RST7R5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_25_display(self.mic_rs7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs7 = token_76(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:303:1, end:303:7))"]
#[derive(Clone, Debug)]
struct RST7R5Var2 {
    mic_rt32_5: u8,
}
impl RST7R5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rt32_5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt32_5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRST7R5 {
    Var0(RST7R5Var0),
    Var1(RST7R5Var1),
    Var2(RST7R5Var2),
}
impl TableRST7R5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 536870912 == 536870912
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 3) == 0
        {
            if let Some((inst_len, parsed)) =
                RST7R5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                RST7R5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                RST7R5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:308:1, end:308:7))"]
#[derive(Clone, Debug)]
struct RT5RD5Var0 {}
impl RT5RD5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(context.read_ext_32_rd())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:310:1, end:310:7))"]
#[derive(Clone, Debug)]
struct RT5RD5Var1 {
    micb_rd32: u8,
}
impl RT5RD5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.micb_rd32)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_rd32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:307:1, end:307:7))"]
#[derive(Clone, Debug)]
struct RT5RD5Var2 {}
impl RT5RD5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(context.read_ext_32_rd())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:309:1, end:309:7))"]
#[derive(Clone, Debug)]
struct RT5RD5Var3 {
    micb_rd32: u8,
}
impl RT5RD5Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.micb_rd32)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let micb_rd32 = token_52(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_rd32 }))
    }
}
#[derive(Clone, Debug)]
enum TableRT5RD5 {
    Var0(RT5RD5Var0),
    Var1(RT5RD5Var1),
    Var2(RT5RD5Var2),
    Var3(RT5RD5Var3),
}
impl TableRT5RD5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 536874880 == 0 {
            if let Some((inst_len, parsed)) =
                RT5RD5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 536870912 == 536870912
            && (tokens_param[1] & 248) == 0
        {
            if let Some((inst_len, parsed)) =
                RT5RD5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                RT5RD5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                RT5RD5Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:313:1, end:313:7))"]
#[derive(Clone, Debug)]
struct RS0RT5Var0 {
    mic_rs32_0: u8,
}
impl RS0RT5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:315:1, end:315:7))"]
#[derive(Clone, Debug)]
struct RS0RT5Var1 {
    mic_rt32_5: u8,
}
impl RS0RT5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rt32_5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt32_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:312:1, end:312:7))"]
#[derive(Clone, Debug)]
struct RS0RT5Var2 {
    mic_rs32_0: u8,
}
impl RS0RT5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:314:1, end:314:7))"]
#[derive(Clone, Debug)]
struct RS0RT5Var3 {
    mic_rt32_5: u8,
}
impl RS0RT5Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rt32_5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt32_5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRS0RT5 {
    Var0(RS0RT5Var0),
    Var1(RS0RT5Var1),
    Var2(RS0RT5Var2),
    Var3(RS0RT5Var3),
}
impl TableRS0RT5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 536870912 == 0
            && (tokens_param[0] & 31) == 0
        {
            if let Some((inst_len, parsed)) =
                RS0RT5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 536870912 == 536870912
            && (tokens_param[0] & 224) == 0
            && (tokens_param[1] & 3) == 0
        {
            if let Some((inst_len, parsed)) =
                RS0RT5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                RS0RT5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                RS0RT5Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:318:1, end:318:6))"]
#[derive(Clone, Debug)]
struct ENCRSVar0 {
    mic_encrs: u8,
}
impl ENCRSVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_29_display(self.mic_encrs)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_encrs = token_77(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_encrs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:320:1, end:320:6))"]
#[derive(Clone, Debug)]
struct ENCRSVar1 {}
impl ENCRSVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_29_display(context.read_ext_16_rs())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:317:1, end:317:6))"]
#[derive(Clone, Debug)]
struct ENCRSVar2 {
    mic_encrs: u8,
}
impl ENCRSVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_29_display(self.mic_encrs)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_encrs = token_77(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_encrs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:319:1, end:319:6))"]
#[derive(Clone, Debug)]
struct ENCRSVar3 {}
impl ENCRSVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_29_display(context.read_ext_16_rs())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableENCRS {
    Var0(ENCRSVar0),
    Var1(ENCRSVar1),
    Var2(ENCRSVar2),
    Var3(ENCRSVar3),
}
impl TableENCRS {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 536870912 == 0
            && (tokens_param[0] & 14) == 0
        {
            if let Some((inst_len, parsed)) =
                ENCRSVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 536871808 == 536870912 {
            if let Some((inst_len, parsed)) =
                ENCRSVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                ENCRSVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                ENCRSVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:322:1, end:322:11))"]
#[derive(Clone, Debug)]
struct Abs26_mic1Var0 {
    micb_imm16: u16,
}
impl Abs26_mic1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 18446744073575333888i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    (i128::try_from(self.micb_imm16).unwrap()
                        | u32::try_from(16i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(context.read_ext_32_code())
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0)),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 18446744073575333888i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    (i128::try_from(token_68(tokens_current)).unwrap()
                        | u32::try_from(16i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(context_instance.read_ext_32_code())
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0)),
                ),
            );
        let micb_imm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_imm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableAbs26_mic1 {
    Var0(Abs26_mic1Var0),
}
impl TableAbs26_mic1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Abs26_mic1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:323:1, end:323:11))"]
#[derive(Clone, Debug)]
struct Abs26_mic2Var0 {
    micb_imm16: u16,
}
impl Abs26_mic2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 18446744073441116160i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    (i128::try_from(self.micb_imm16).unwrap()
                        | u32::try_from(16i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(context.read_ext_32_code())
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0)),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128)
            & 18446744073441116160i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    (i128::try_from(token_68(tokens_current)).unwrap()
                        | u32::try_from(16i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(context_instance.read_ext_32_code())
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0)),
                ),
            );
        let micb_imm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_imm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableAbs26_mic2 {
    Var0(Abs26_mic2Var0),
}
impl TableAbs26_mic2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Abs26_mic2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:324:1, end:324:10))"]
#[derive(Clone, Debug)]
struct Rel26_micVar0 {
    micb_imm16: u16,
}
impl Rel26_micVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    (u32::try_from(16i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(context.read_ext_32_codes())
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)
                        | i128::try_from(self.micb_imm16).unwrap()),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    (u32::try_from(16i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(context_instance.read_ext_32_codes())
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)
                        | i128::try_from(token_68(tokens_current)).unwrap()),
                ),
            );
        let micb_imm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_imm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableRel26_mic {
    Var0(Rel26_micVar0),
}
impl TableRel26_mic {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Rel26_micVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:325:1, end:325:10))"]
#[derive(Clone, Debug)]
struct Rel21_micVar0 {
    micb_imm16: u16,
}
impl Rel21_micVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    (u32::try_from(16i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(context.read_ext_32_imm5s())
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)
                        | i128::try_from(self.micb_imm16).unwrap()),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    (u32::try_from(16i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(context_instance.read_ext_32_imm5s())
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)
                        | i128::try_from(token_68(tokens_current)).unwrap()),
                ),
            );
        let micb_imm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_imm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableRel21_mic {
    Var0(Rel21_micVar0),
}
impl TableRel21_mic {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Rel21_micVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:326:1, end:326:10))"]
#[derive(Clone, Debug)]
struct Rel16_micVar0 {
    micb_simm16: u16,
}
impl Rel16_micVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    i128::try_from(
                        (if self.micb_simm16 & 32768 != 0 {
                            -1 & !32767
                        } else {
                            0
                        } | self.micb_simm16 as i16),
                    )
                    .unwrap(),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(2i128.wrapping_mul(i128::try_from(token_68(tokens_current)).unwrap()));
        let micb_simm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableRel16_mic {
    Var0(Rel16_micVar0),
}
impl TableRel16_mic {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Rel16_micVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:327:1, end:327:10))"]
#[derive(Clone, Debug)]
struct Rel10_micVar0 {
    mic_soff10: u16,
}
impl Rel10_micVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    i128::try_from(
                        (if self.mic_soff10 & 512 != 0 {
                            -1 & !511
                        } else {
                            0
                        } | self.mic_soff10 as i16),
                    )
                    .unwrap(),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(2i128.wrapping_mul(i128::try_from(token_72(tokens_current)).unwrap()));
        let mic_soff10 = token_72(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_soff10 }))
    }
}
#[derive(Clone, Debug)]
enum TableRel10_mic {
    Var0(Rel10_micVar0),
}
impl TableRel10_mic {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Rel10_micVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:328:1, end:328:9))"]
#[derive(Clone, Debug)]
struct Rel7_micVar0 {
    mic_soff7: u8,
}
impl Rel7_micVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    i128::try_from(
                        (if self.mic_soff7 & 64 != 0 {
                            -1 & !63
                        } else {
                            0
                        } | self.mic_soff7 as i8),
                    )
                    .unwrap(),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(2i128.wrapping_mul(i128::try_from(token_81(tokens_current)).unwrap()));
        let mic_soff7 = token_81(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_soff7 }))
    }
}
#[derive(Clone, Debug)]
enum TableRel7_mic {
    Var0(Rel7_micVar0),
}
impl TableRel7_mic {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Rel7_micVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:330:1, end:330:10))"]
#[derive(Clone, Debug)]
struct EXT_CODE3Var0 {}
impl EXT_CODE3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_s()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_s(i16::try_from(1i128).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_s()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:331:1, end:331:10))"]
#[derive(Clone, Debug)]
struct EXT_CODE3Var1 {}
impl EXT_CODE3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_s()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_s(i16::try_from(65535i128).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_s()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:332:1, end:332:10))"]
#[derive(Clone, Debug)]
struct EXT_CODE3Var2 {
    mic_imm3: u8,
}
impl EXT_CODE3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_s()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_s(
            i16::try_from(
                u32::try_from(2i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(token_77(tokens_current))
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0),
            )
            .unwrap(),
        );
        calc_val = i128::try_from(context_instance.read_ext_off16_s()).unwrap();
        let mic_imm3 = token_77(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_imm3 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE3 {
    Var0(EXT_CODE3Var0),
    Var1(EXT_CODE3Var1),
    Var2(EXT_CODE3Var2),
}
impl TableEXT_CODE3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 14) == 0 {
            if let Some((inst_len, parsed)) =
                EXT_CODE3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 14) == 14 {
            if let Some((inst_len, parsed)) =
                EXT_CODE3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:334:1, end:334:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar0 {}
impl EXT_CODE4AVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(128i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:335:1, end:335:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar1 {}
impl EXT_CODE4AVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(1i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:336:1, end:336:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar2 {}
impl EXT_CODE4AVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(2i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:337:1, end:337:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar3 {}
impl EXT_CODE4AVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(3i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:338:1, end:338:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar4 {}
impl EXT_CODE4AVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(4i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:339:1, end:339:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar5 {}
impl EXT_CODE4AVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(7i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:340:1, end:340:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar6 {}
impl EXT_CODE4AVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(8i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:341:1, end:341:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar7 {}
impl EXT_CODE4AVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(15i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:342:1, end:342:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar8 {}
impl EXT_CODE4AVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(16i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:343:1, end:343:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar9 {}
impl EXT_CODE4AVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(31i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:344:1, end:344:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar10 {}
impl EXT_CODE4AVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(32i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:345:1, end:345:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar11 {}
impl EXT_CODE4AVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(63i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:346:1, end:346:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar12 {}
impl EXT_CODE4AVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(64i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:347:1, end:347:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar13 {}
impl EXT_CODE4AVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(255i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:348:1, end:348:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar14 {}
impl EXT_CODE4AVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(32768i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:349:1, end:349:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4AVar15 {}
impl EXT_CODE4AVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_u()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_u(u16::try_from(65535i128 & 65535).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_u()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE4A {
    Var0(EXT_CODE4AVar0),
    Var1(EXT_CODE4AVar1),
    Var2(EXT_CODE4AVar2),
    Var3(EXT_CODE4AVar3),
    Var4(EXT_CODE4AVar4),
    Var5(EXT_CODE4AVar5),
    Var6(EXT_CODE4AVar6),
    Var7(EXT_CODE4AVar7),
    Var8(EXT_CODE4AVar8),
    Var9(EXT_CODE4AVar9),
    Var10(EXT_CODE4AVar10),
    Var11(EXT_CODE4AVar11),
    Var12(EXT_CODE4AVar12),
    Var13(EXT_CODE4AVar13),
    Var14(EXT_CODE4AVar14),
    Var15(EXT_CODE4AVar15),
}
impl TableEXT_CODE4A {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 1 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 3 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 5 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 6 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 7 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 9 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 10 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 11 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 12 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 13 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 14 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4AVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:351:1, end:351:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4BVar0 {}
impl EXT_CODE4BVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_s()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_s(i16::try_from(65535i128).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_s()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:352:1, end:352:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4BVar1 {
    mic_code4: u8,
}
impl EXT_CODE4BVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_s()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_s(
            i16::try_from(i128::try_from(token_62(tokens_current)).unwrap()).unwrap(),
        );
        calc_val = i128::try_from(context_instance.read_ext_off16_s()).unwrap();
        let mic_code4 = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_code4 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE4B {
    Var0(EXT_CODE4BVar0),
    Var1(EXT_CODE4BVar1),
}
impl TableEXT_CODE4B {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4BVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4BVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:354:1, end:354:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4CVar0 {
    mic_code4: u8,
}
impl EXT_CODE4CVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(1i128)
            .ok()
            .and_then(|shl| i128::try_from(self.mic_code4).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(1i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_62(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let mic_code4 = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_code4 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE4C {
    Var0(EXT_CODE4CVar0),
}
impl TableEXT_CODE4C {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4CVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:356:1, end:356:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4DVar0 {
    mic_code4s: u8,
}
impl EXT_CODE4DVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.mic_code4s & 8 != 0 { -1 & !7 } else { 0 } | self.mic_code4s as i8),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_62(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let mic_code4s = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_code4s }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE4D {
    Var0(EXT_CODE4DVar0),
}
impl TableEXT_CODE4D {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4DVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:358:1, end:358:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4EVar0 {
    mic_code4: u8,
}
impl EXT_CODE4EVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| i128::try_from(self.mic_code4).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_62(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let mic_code4 = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_code4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:359:1, end:359:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE4EVar1 {
    mic_off4r6: u8,
}
impl EXT_CODE4EVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| i128::try_from(self.mic_off4r6).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_74(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let mic_off4r6 = token_74(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_off4r6 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE4E {
    Var0(EXT_CODE4EVar0),
    Var1(EXT_CODE4EVar1),
}
impl TableEXT_CODE4E {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4EVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                EXT_CODE4EVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:360:1, end:360:12))"]
#[derive(Clone, Debug)]
struct EXT_CODE5R6Var0 {
    mic_imm5r6: u8,
}
impl EXT_CODE5R6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| i128::try_from(self.mic_imm5r6).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_69(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let mic_imm5r6 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_imm5r6 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE5R6 {
    Var0(EXT_CODE5R6Var0),
}
impl TableEXT_CODE5R6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE5R6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:363:1, end:363:10))"]
#[derive(Clone, Debug)]
struct EXT_CODE5Var0 {
    mic_imm5: u8,
}
impl EXT_CODE5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| i128::try_from(self.mic_imm5).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_53(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let mic_imm5 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_imm5 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE5 {
    Var0(EXT_CODE5Var0),
}
impl TableEXT_CODE5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:365:1, end:365:10))"]
#[derive(Clone, Debug)]
struct EXT_CODE7Var0 {}
impl EXT_CODE7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_s()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_s(i16::try_from(65535i128).unwrap());
        calc_val = i128::try_from(context_instance.read_ext_off16_s()).unwrap();
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:366:1, end:366:10))"]
#[derive(Clone, Debug)]
struct EXT_CODE7Var1 {
    mic_imm7: u8,
}
impl EXT_CODE7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(context.read_ext_off16_s()).unwrap();
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_s(
            i16::try_from(i128::try_from(token_81(tokens_current)).unwrap()).unwrap(),
        );
        calc_val = i128::try_from(context_instance.read_ext_off16_s()).unwrap();
        let mic_imm7 = token_81(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_imm7 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE7 {
    Var0(EXT_CODE7Var0),
    Var1(EXT_CODE7Var1),
}
impl TableEXT_CODE7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 127) == 127 {
            if let Some((inst_len, parsed)) =
                EXT_CODE7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:368:1, end:368:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE7AVar0 {
    mic_soff7: u8,
}
impl EXT_CODE7AVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.mic_soff7 & 64 != 0 {
                        -1 & !63
                    } else {
                        0
                    } | self.mic_soff7 as i8),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_81(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let mic_soff7 = token_81(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_soff7 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE7A {
    Var0(EXT_CODE7AVar0),
}
impl TableEXT_CODE7A {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE7AVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:370:1, end:370:10))"]
#[derive(Clone, Debug)]
struct EXT_CODE9Var0 {}
impl EXT_CODE9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_off16_s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_s(i16::try_from(256i128).unwrap());
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_off16_s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:371:1, end:371:10))"]
#[derive(Clone, Debug)]
struct EXT_CODE9Var1 {}
impl EXT_CODE9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_off16_s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_s(i16::try_from(257i128).unwrap());
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_off16_s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:372:1, end:372:10))"]
#[derive(Clone, Debug)]
struct EXT_CODE9Var2 {}
impl EXT_CODE9Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_off16_s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_s(i16::try_from(65278i128).unwrap());
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_off16_s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:373:1, end:373:10))"]
#[derive(Clone, Debug)]
struct EXT_CODE9Var3 {}
impl EXT_CODE9Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_off16_s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        context_instance.write_ext_off16_s(i16::try_from(65279i128).unwrap());
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_off16_s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:374:1, end:374:10))"]
#[derive(Clone, Debug)]
struct EXT_CODE9Var4 {
    mic_imm9s: u16,
}
impl EXT_CODE9Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.mic_imm9s & 256 != 0 {
                        -1 & !255
                    } else {
                        0
                    } | self.mic_imm9s as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_79(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let mic_imm9s = token_79(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_imm9s }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE9 {
    Var0(EXT_CODE9Var0),
    Var1(EXT_CODE9Var1),
    Var2(EXT_CODE9Var2),
    Var3(EXT_CODE9Var3),
    Var4(EXT_CODE9Var4),
}
impl TableEXT_CODE9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 254) == 0 && (tokens_param[1] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                EXT_CODE9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 254) == 2 && (tokens_param[1] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                EXT_CODE9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 254) == 252 && (tokens_param[1] & 3) == 3 {
            if let Some((inst_len, parsed)) =
                EXT_CODE9Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 254) == 254 && (tokens_param[1] & 3) == 3 {
            if let Some((inst_len, parsed)) =
                EXT_CODE9Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE9Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:376:1, end:376:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE9EVar0 {
    micb_offset9s: u16,
}
impl EXT_CODE9EVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.micb_offset9s & 256 != 0 {
                        -1 & !255
                    } else {
                        0
                    } | self.micb_offset9s as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_80(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let micb_offset9s = token_80(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_offset9s }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE9E {
    Var0(EXT_CODE9EVar0),
}
impl TableEXT_CODE9E {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE9EVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:377:1, end:377:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE12Var0 {
    micb_offset12s: u16,
}
impl EXT_CODE12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.micb_offset12s & 2048 != 0 {
                        -1 & !2047
                    } else {
                        0
                    } | self.micb_offset12s as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_87(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let micb_offset12s = token_87(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_offset12s }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE12 {
    Var0(EXT_CODE12Var0),
}
impl TableEXT_CODE12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:379:1, end:379:11))"]
#[derive(Clone, Debug)]
struct EXT_CODE16Var0 {
    micb_code10: u16,
}
impl EXT_CODE16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = (u32::try_from(10i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_32_imm6())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(self.micb_code10).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = (u32::try_from(10i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_32_imm6())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_89(tokens_current)).unwrap());
        let micb_code10 = token_89(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_code10 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_CODE16 {
    Var0(EXT_CODE16Var0),
}
impl TableEXT_CODE16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_CODE16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:381:1, end:381:9))"]
#[derive(Clone, Debug)]
struct EXT_MS16Var0 {
    micb_simm16: u16,
}
impl EXT_MS16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.micb_simm16 & 32768 != 0 {
                        -1 & !32767
                    } else {
                        0
                    } | self.micb_simm16 as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_68(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let micb_simm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_MS16 {
    Var0(EXT_MS16Var0),
}
impl TableEXT_MS16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_MS16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:382:1, end:382:9))"]
#[derive(Clone, Debug)]
struct EXT_MS18Var0 {
    micb_imm16: u16,
}
impl EXT_MS18Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = (u32::try_from(19i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_32_imm2s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(3i128)
                .ok()
                .and_then(|shl| i128::try_from(self.micb_imm16).unwrap().checked_shl(shl))
                .unwrap_or(0));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = (u32::try_from(19i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_32_imm2s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(3i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(token_68(tokens_current))
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0));
        let micb_imm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_imm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_MS18 {
    Var0(EXT_MS18Var0),
}
impl TableEXT_MS18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_MS18Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:384:1, end:384:9))"]
#[derive(Clone, Debug)]
struct EXT_MS19Var0 {
    micb_imm16: u16,
}
impl EXT_MS19Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = (u32::try_from(18i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_32_imm3s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(2i128)
                .ok()
                .and_then(|shl| i128::try_from(self.micb_imm16).unwrap().checked_shl(shl))
                .unwrap_or(0));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = (u32::try_from(18i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_32_imm3s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(2i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(token_68(tokens_current))
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0));
        let micb_imm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_imm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_MS19 {
    Var0(EXT_MS19Var0),
}
impl TableEXT_MS19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_MS19Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:386:1, end:386:9))"]
#[derive(Clone, Debug)]
struct EXT_MS32Var0 {
    micb_simm16: u16,
}
impl EXT_MS32Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(16i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.micb_simm16 & 32768 != 0 {
                        -1 & !32767
                    } else {
                        0
                    } | self.micb_simm16 as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(16i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_68(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let micb_simm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_MS32 {
    Var0(EXT_MS32Var0),
}
impl TableEXT_MS32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_MS32Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:387:1, end:387:9))"]
#[derive(Clone, Debug)]
struct EXT_MS48Var0 {
    micb_simm16: u16,
}
impl EXT_MS48Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(32i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.micb_simm16 & 32768 != 0 {
                        -1 & !32767
                    } else {
                        0
                    } | self.micb_simm16 as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(32i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_68(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let micb_simm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_MS48 {
    Var0(EXT_MS48Var0),
}
impl TableEXT_MS48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_MS48Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:388:1, end:388:9))"]
#[derive(Clone, Debug)]
struct EXT_MS64Var0 {
    micb_simm16: u16,
}
impl EXT_MS64Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(48i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.micb_simm16 & 32768 != 0 {
                        -1 & !32767
                    } else {
                        0
                    } | self.micb_simm16 as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(48i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_68(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let micb_simm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_MS64 {
    Var0(EXT_MS64Var0),
}
impl TableEXT_MS64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_MS64Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:390:1, end:390:9))"]
#[derive(Clone, Debug)]
struct EXT_MSPCVar0 {
    micb_imm16: u16,
}
impl EXT_MSPCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = (u32::try_from(18i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_32_imm3s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(2i128)
                .ok()
                .and_then(|shl| i128::try_from(self.micb_imm16).unwrap().checked_shl(shl))
                .unwrap_or(0));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = (u32::try_from(18i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_32_imm3s())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(2i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(token_68(tokens_current))
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0));
        let micb_imm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:392:1, end:392:9))"]
#[derive(Clone, Debug)]
struct EXT_MSPCVar1 {
    micb_imm16: u16,
}
impl EXT_MSPCVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = (u32::try_from(18i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_32_addims())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(2i128)
                .ok()
                .and_then(|shl| i128::try_from(self.micb_imm16).unwrap().checked_shl(shl))
                .unwrap_or(0));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = (u32::try_from(18i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_32_addims())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | u32::try_from(2i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(token_68(tokens_current))
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0));
        let micb_imm16 = token_68(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_imm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_MSPC {
    Var0(EXT_MSPCVar0),
    Var1(EXT_MSPCVar1),
}
impl TableEXT_MSPC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                EXT_MSPCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                EXT_MSPCVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:394:1, end:394:9))"]
#[derive(Clone, Debug)]
struct EXT_MU23Var0 {
    micb_cofun: u16,
}
impl EXT_MU23Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = (u32::try_from(13i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context.read_ext_32_code())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(self.micb_cofun).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = (u32::try_from(13i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(context_instance.read_ext_32_code())
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_92(tokens_current)).unwrap());
        let micb_cofun = token_92(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_cofun }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_MU23 {
    Var0(EXT_MU23Var0),
}
impl TableEXT_MU23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_MU23Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:396:1, end:396:8))"]
#[derive(Clone, Debug)]
struct EXT_MU6Var0 {
    mic_imm6: u8,
}
impl EXT_MU6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| i128::try_from(self.mic_imm6).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_82(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let mic_imm6 = token_82(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_imm6 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_MU6 {
    Var0(EXT_MU6Var0),
}
impl TableEXT_MU6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_MU6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:398:1, end:398:7))"]
#[derive(Clone, Debug)]
struct EXT_SAVar0 {}
impl EXT_SAVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = 8i128;
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = 8i128;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:399:1, end:399:7))"]
#[derive(Clone, Debug)]
struct EXT_SAVar1 {
    mic_sa: u8,
}
impl EXT_SAVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| i128::try_from(self.mic_sa).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_77(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let mic_sa = token_77(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_sa }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_SA {
    Var0(EXT_SAVar0),
    Var1(EXT_SAVar1),
}
impl TableEXT_SA {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 14) == 0 {
            if let Some((inst_len, parsed)) =
                EXT_SAVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_SAVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:401:1, end:401:8))"]
#[derive(Clone, Debug)]
struct EXT_SA9Var0 {
    micb_sa9: u8,
}
impl EXT_SA9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(self.micb_sa9).unwrap().wrapping_add(1i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = i128::try_from(token_93(tokens_current))
            .unwrap()
            .wrapping_add(1i128);
        let micb_sa9 = token_93(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_sa9 }))
    }
}
#[derive(Clone, Debug)]
enum TableEXT_SA9 {
    Var0(EXT_SA9Var0),
}
impl TableEXT_SA9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                EXT_SA9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:403:1, end:403:7))"]
#[derive(Clone, Debug)]
struct DIDISPVar0 {}
impl DIDISPVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:404:1, end:404:7))"]
#[derive(Clone, Debug)]
struct DIDISPVar1 {
    mic_rs32_0: u8,
}
impl DIDISPVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_33_display(self.mic_rs32_0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rs32_0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rs32_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableDIDISP {
    Var0(DIDISPVar0),
    Var1(DIDISPVar1),
}
impl TableDIDISP {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                DIDISPVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                DIDISPVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:406:1, end:406:6))"]
#[derive(Clone, Debug)]
struct RTIMPVar0 {}
impl RTIMPVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:407:1, end:407:6))"]
#[derive(Clone, Debug)]
struct RTIMPVar1 {
    mic_rt32_5: u8,
}
impl RTIMPVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_33_display(self.mic_rt32_5),
            <DisplayElement>::Literal(", "),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_rt32_5 = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_rt32_5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRTIMP {
    Var0(RTIMPVar0),
    Var1(RTIMPVar1),
}
impl TableRTIMP {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 224) == 224 && (tokens_param[1] & 3) == 3 {
            if let Some((inst_len, parsed)) =
                RTIMPVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RTIMPVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:409:1, end:409:6))"]
#[derive(Clone, Debug)]
struct SIZEPVar0 {
    micb_size: u8,
}
impl SIZEPVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(self.micb_size).unwrap().wrapping_add(1i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = i128::try_from(token_52(tokens_current))
            .unwrap()
            .wrapping_add(1i128);
        let micb_size = token_52(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_size }))
    }
}
#[derive(Clone, Debug)]
enum TableSIZEP {
    Var0(SIZEPVar0),
}
impl TableSIZEP {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                SIZEPVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:410:1, end:410:8))"]
#[derive(Clone, Debug)]
struct SIZEPLGVar0 {
    micb_size: u8,
}
impl SIZEPLGVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(self.micb_size)
            .unwrap()
            .wrapping_add(1i128)
            .wrapping_add(32i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = i128::try_from(token_52(tokens_current))
            .unwrap()
            .wrapping_add(1i128)
            .wrapping_add(32i128);
        let micb_size = token_52(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_size }))
    }
}
#[derive(Clone, Debug)]
enum TableSIZEPLG {
    Var0(SIZEPLGVar0),
}
impl TableSIZEPLG {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                SIZEPLGVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:411:1, end:411:6))"]
#[derive(Clone, Debug)]
struct SIZEQVar0 {
    micb_size: u8,
    micb_pos: u8,
}
impl SIZEQVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(self.micb_size)
            .unwrap()
            .wrapping_add(1i128.wrapping_sub(i128::try_from(self.micb_pos).unwrap()));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = i128::try_from(token_52(tokens_current))
            .unwrap()
            .wrapping_add(1i128.wrapping_sub(i128::try_from(token_105(tokens_current)).unwrap()));
        let micb_size = token_52(tokens_current);
        let micb_pos = token_105(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_size,
                micb_pos,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableSIZEQ {
    Var0(SIZEQVar0),
}
impl TableSIZEQ {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                SIZEQVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:412:1, end:412:8))"]
#[derive(Clone, Debug)]
struct SIZEQLGVar0 {
    micb_size: u8,
    micb_pos: u8,
}
impl SIZEQLGVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(self.micb_size)
            .unwrap()
            .wrapping_add(1i128.wrapping_sub(i128::try_from(self.micb_pos).unwrap()))
            .wrapping_add(32i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = i128::try_from(token_52(tokens_current))
            .unwrap()
            .wrapping_add(1i128.wrapping_sub(i128::try_from(token_105(tokens_current)).unwrap()))
            .wrapping_add(32i128);
        let micb_size = token_52(tokens_current);
        let micb_pos = token_105(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                micb_size,
                micb_pos,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableSIZEQLG {
    Var0(SIZEQLGVar0),
}
impl TableSIZEQLG {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                SIZEQLGVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:413:1, end:413:6))"]
#[derive(Clone, Debug)]
struct POSHIVar0 {
    micb_pos: u8,
}
impl POSHIVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(self.micb_pos).unwrap().wrapping_add(32i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = i128::try_from(token_105(tokens_current))
            .unwrap()
            .wrapping_add(32i128);
        let micb_pos = token_105(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_pos }))
    }
}
#[derive(Clone, Debug)]
enum TablePOSHI {
    Var0(POSHIVar0),
}
impl TablePOSHI {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                POSHIVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:415:1, end:415:6))"]
#[derive(Clone, Debug)]
struct CPSELVar0 {}
impl CPSELVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:416:1, end:416:6))"]
#[derive(Clone, Debug)]
struct CPSELVar1 {
    micb_sel: u8,
}
impl CPSELVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(", "),
            DisplayElement::Number(true, false, self.micb_sel as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let micb_sel = token_111(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_sel }))
    }
}
#[derive(Clone, Debug)]
enum TableCPSEL {
    Var0(CPSELVar0),
    Var1(CPSELVar1),
}
impl TableCPSEL {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 0 {
            if let Some((inst_len, parsed)) =
                CPSELVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                CPSELVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:418:1, end:418:6))"]
#[derive(Clone, Debug)]
struct STYPEVar0 {}
impl STYPEVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:419:1, end:419:6))"]
#[derive(Clone, Debug)]
struct STYPEVar1 {
    mic_stype: u8,
}
impl STYPEVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| i128::try_from(self.mic_stype).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_53(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let mic_stype = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_stype }))
    }
}
#[derive(Clone, Debug)]
enum TableSTYPE {
    Var0(STYPEVar0),
    Var1(STYPEVar1),
}
impl TableSTYPE {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                STYPEVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                STYPEVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:421:1, end:421:6))"]
#[derive(Clone, Debug)]
struct SDB16Var0 {
    mic_code4: u8,
}
impl SDB16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.mic_code4 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_code4 = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_code4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:422:1, end:422:6))"]
#[derive(Clone, Debug)]
struct SDB16Var1 {
    mic_code4r6: u8,
}
impl SDB16Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.mic_code4r6 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mic_code4r6 = token_73(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_code4r6 }))
    }
}
#[derive(Clone, Debug)]
enum TableSDB16 {
    Var0(SDB16Var0),
    Var1(SDB16Var1),
}
impl TableSDB16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                SDB16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                SDB16Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:424:1, end:424:5))"]
#[derive(Clone, Debug)]
struct SA32Var0 {
    micb_sa: u8,
}
impl SA32Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(self.micb_sa).unwrap().wrapping_add(32i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = i128::try_from(token_52(tokens_current))
            .unwrap()
            .wrapping_add(32i128);
        let micb_sa = token_52(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { micb_sa }))
    }
}
#[derive(Clone, Debug)]
enum TableSA32 {
    Var0(SA32Var0),
}
impl TableSA32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                SA32Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:426:1, end:426:7))"]
#[derive(Clone, Debug)]
struct COP2CCVar0 {}
impl COP2CCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:427:1, end:427:7))"]
#[derive(Clone, Debug)]
struct COP2CCVar1 {
    mic_cc: u8,
}
impl COP2CCVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| i128::try_from(self.mic_cc).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Number(true, calc_val.is_negative(), calc_val.abs() as u64),
            <DisplayElement>::Literal(", "),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 2;
        calc_val = u32::try_from(0i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_59(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let mic_cc = token_59(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mic_cc }))
    }
}
#[derive(Clone, Debug)]
enum TableCOP2CC {
    Var0(COP2CCVar0),
    Var1(COP2CCVar1),
}
impl TableCOP2CC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 28) == 0 {
            if let Some((inst_len, parsed)) =
                COP2CCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                COP2CCVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:429:1, end:429:8))"]
#[derive(Clone, Debug)]
struct LOAD_S8Var0 {}
impl LOAD_S8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:430:1, end:430:8))"]
#[derive(Clone, Debug)]
struct LOAD_S8Var1 {}
impl LOAD_S8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_S8 {
    Var0(LOAD_S8Var0),
    Var1(LOAD_S8Var1),
}
impl TableLOAD_S8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 4 {
            if let Some((inst_len, parsed)) =
                LOAD_S8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LOAD_S8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:432:1, end:432:8))"]
#[derive(Clone, Debug)]
struct LOAD_S7Var0 {}
impl LOAD_S7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:433:1, end:433:8))"]
#[derive(Clone, Debug)]
struct LOAD_S7Var1 {
    LOAD_S8: TableLOAD_S8,
}
impl LOAD_S7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LOAD_S8 = if let Some((len, table)) =
            TableLOAD_S8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LOAD_S8 }))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_S7 {
    Var0(LOAD_S7Var0),
    Var1(LOAD_S7Var1),
}
impl TableLOAD_S7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 56 {
            if let Some((inst_len, parsed)) =
                LOAD_S7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LOAD_S7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:435:1, end:435:8))"]
#[derive(Clone, Debug)]
struct LOAD_S6Var0 {}
impl LOAD_S6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:436:1, end:436:8))"]
#[derive(Clone, Debug)]
struct LOAD_S6Var1 {
    LOAD_S7: TableLOAD_S7,
}
impl LOAD_S6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LOAD_S7 = if let Some((len, table)) =
            TableLOAD_S7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LOAD_S7 }))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_S6 {
    Var0(LOAD_S6Var0),
    Var1(LOAD_S6Var1),
}
impl TableLOAD_S6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 24 {
            if let Some((inst_len, parsed)) =
                LOAD_S6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LOAD_S6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:438:1, end:438:8))"]
#[derive(Clone, Debug)]
struct LOAD_S5Var0 {}
impl LOAD_S5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:439:1, end:439:8))"]
#[derive(Clone, Debug)]
struct LOAD_S5Var1 {
    LOAD_S6: TableLOAD_S6,
}
impl LOAD_S5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LOAD_S6 = if let Some((len, table)) =
            TableLOAD_S6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LOAD_S6 }))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_S5 {
    Var0(LOAD_S5Var0),
    Var1(LOAD_S5Var1),
}
impl TableLOAD_S5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 40 {
            if let Some((inst_len, parsed)) =
                LOAD_S5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LOAD_S5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:441:1, end:441:8))"]
#[derive(Clone, Debug)]
struct LOAD_S4Var0 {}
impl LOAD_S4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:442:1, end:442:8))"]
#[derive(Clone, Debug)]
struct LOAD_S4Var1 {
    LOAD_S5: TableLOAD_S5,
}
impl LOAD_S4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LOAD_S5 = if let Some((len, table)) =
            TableLOAD_S5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LOAD_S5 }))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_S4 {
    Var0(LOAD_S4Var0),
    Var1(LOAD_S4Var1),
}
impl TableLOAD_S4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 8 {
            if let Some((inst_len, parsed)) =
                LOAD_S4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LOAD_S4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:444:1, end:444:8))"]
#[derive(Clone, Debug)]
struct LOAD_S3Var0 {}
impl LOAD_S3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:445:1, end:445:8))"]
#[derive(Clone, Debug)]
struct LOAD_S3Var1 {
    LOAD_S4: TableLOAD_S4,
}
impl LOAD_S3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LOAD_S4 = if let Some((len, table)) =
            TableLOAD_S4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LOAD_S4 }))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_S3 {
    Var0(LOAD_S3Var0),
    Var1(LOAD_S3Var1),
}
impl TableLOAD_S3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 48 {
            if let Some((inst_len, parsed)) =
                LOAD_S3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LOAD_S3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:447:1, end:447:8))"]
#[derive(Clone, Debug)]
struct LOAD_S2Var0 {}
impl LOAD_S2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:448:1, end:448:8))"]
#[derive(Clone, Debug)]
struct LOAD_S2Var1 {
    LOAD_S3: TableLOAD_S3,
}
impl LOAD_S2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LOAD_S3 = if let Some((len, table)) =
            TableLOAD_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LOAD_S3 }))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_S2 {
    Var0(LOAD_S2Var0),
    Var1(LOAD_S2Var1),
}
impl TableLOAD_S2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 16 {
            if let Some((inst_len, parsed)) =
                LOAD_S2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LOAD_S2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:450:1, end:450:8))"]
#[derive(Clone, Debug)]
struct LOAD_S1Var0 {}
impl LOAD_S1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:451:1, end:451:8))"]
#[derive(Clone, Debug)]
struct LOAD_S1Var1 {
    LOAD_S2: TableLOAD_S2,
}
impl LOAD_S1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LOAD_S2 = if let Some((len, table)) =
            TableLOAD_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LOAD_S2 }))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_S1 {
    Var0(LOAD_S1Var0),
    Var1(LOAD_S1Var1),
}
impl TableLOAD_S1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 32 {
            if let Some((inst_len, parsed)) =
                LOAD_S1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LOAD_S1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:453:1, end:453:8))"]
#[derive(Clone, Debug)]
struct LOAD_S0Var0 {}
impl LOAD_S0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:454:1, end:454:8))"]
#[derive(Clone, Debug)]
struct LOAD_S0Var1 {
    LOAD_S1: TableLOAD_S1,
}
impl LOAD_S0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LOAD_S1 = if let Some((len, table)) =
            TableLOAD_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LOAD_S1 }))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_S0 {
    Var0(LOAD_S0Var0),
    Var1(LOAD_S0Var1),
}
impl TableLOAD_S0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 0 {
            if let Some((inst_len, parsed)) =
                LOAD_S0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LOAD_S0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:456:1, end:456:10))"]
#[derive(Clone, Debug)]
struct LOAD_SREGVar0 {}
impl LOAD_SREGVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:457:1, end:457:10))"]
#[derive(Clone, Debug)]
struct LOAD_SREGVar1 {
    LOAD_S0: TableLOAD_S0,
}
impl LOAD_SREGVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_38_display(context.read_ext_t4_name()),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LOAD_S0 = if let Some((len, table)) =
            TableLOAD_S0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LOAD_S0 }))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_SREG {
    Var0(LOAD_SREGVar0),
    Var1(LOAD_SREGVar1),
}
impl TableLOAD_SREG {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 0 {
            if let Some((inst_len, parsed)) =
                LOAD_SREGVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LOAD_SREGVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:459:1, end:459:8))"]
#[derive(Clone, Debug)]
struct LOAD_RAVar0 {}
impl LOAD_RAVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:460:1, end:460:8))"]
#[derive(Clone, Debug)]
struct LOAD_RAVar1 {}
impl LOAD_RAVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ra,")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_RA {
    Var0(LOAD_RAVar0),
    Var1(LOAD_RAVar1),
}
impl TableLOAD_RA {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 64 == 0 {
            if let Some((inst_len, parsed)) =
                LOAD_RAVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 64 == 64 {
            if let Some((inst_len, parsed)) =
                LOAD_RAVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:462:1, end:462:9))"]
#[derive(Clone, Debug)]
struct LOAD_TOPVar0 {
    LOAD_SREG: TableLOAD_SREG,
    LOAD_RA: TableLOAD_RA,
    EXT_CODE12: TableEXT_CODE12,
}
impl LOAD_TOPVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LOAD_SREG
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.LOAD_RA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(context.read_ext_32_base()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_t4(
            u8::try_from(
                (i128::try_from(context_instance.read_ext_32_rlist()).unwrap() & 15i128) & 15,
            )
            .unwrap(),
        );
        context_instance.write_ext_tra(
            u8::try_from(
                u32::try_from(4i128)
                    .ok()
                    .and_then(|shr| {
                        i128::try_from(context_instance.read_ext_32_rlist())
                            .unwrap()
                            .checked_shr(shr)
                    })
                    .unwrap_or(0)
                    & 1,
            )
            .unwrap(),
        );
        let LOAD_SREG = if let Some((len, table)) =
            TableLOAD_SREG::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let LOAD_RA = if let Some((len, table)) =
            TableLOAD_RA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                LOAD_SREG,
                LOAD_RA,
                EXT_CODE12,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_TOP {
    Var0(LOAD_TOPVar0),
}
impl TableLOAD_TOP {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                LOAD_TOPVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:471:1, end:471:11))"]
#[derive(Clone, Debug)]
struct LOAD_TOP16Var0 {
    mic_list: u8,
    LOAD_SREG: TableLOAD_SREG,
    EXT_CODE4E: TableEXT_CODE4E,
}
impl LOAD_TOP16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LOAD_SREG
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::ra),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE4E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_t4(
            u8::try_from(
                i128::try_from(token_90(tokens_current))
                    .unwrap()
                    .wrapping_add(1i128)
                    & 15,
            )
            .unwrap(),
        );
        let LOAD_SREG = if let Some((len, table)) =
            TableLOAD_SREG::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_CODE4E = if let Some((len, table)) =
            TableEXT_CODE4E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_list = token_90(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                LOAD_SREG,
                EXT_CODE4E,
                mic_list,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:480:1, end:480:11))"]
#[derive(Clone, Debug)]
struct LOAD_TOP16Var1 {
    mic_listr6: u8,
    LOAD_SREG: TableLOAD_SREG,
    EXT_CODE4E: TableEXT_CODE4E,
}
impl LOAD_TOP16Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LOAD_SREG
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::ra),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE4E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_t4(
            u8::try_from(
                i128::try_from(token_91(tokens_current))
                    .unwrap()
                    .wrapping_add(1i128)
                    & 15,
            )
            .unwrap(),
        );
        let LOAD_SREG = if let Some((len, table)) =
            TableLOAD_SREG::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_CODE4E = if let Some((len, table)) =
            TableEXT_CODE4E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_listr6 = token_91(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                LOAD_SREG,
                EXT_CODE4E,
                mic_listr6,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableLOAD_TOP16 {
    Var0(LOAD_TOP16Var0),
    Var1(LOAD_TOP16Var1),
}
impl TableLOAD_TOP16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                LOAD_TOP16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                LOAD_TOP16Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:491:1, end:491:9))"]
#[derive(Clone, Debug)]
struct STORE_S8Var0 {}
impl STORE_S8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:492:1, end:492:9))"]
#[derive(Clone, Debug)]
struct STORE_S8Var1 {}
impl STORE_S8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_S8 {
    Var0(STORE_S8Var0),
    Var1(STORE_S8Var1),
}
impl TableSTORE_S8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 4 {
            if let Some((inst_len, parsed)) =
                STORE_S8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STORE_S8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:494:1, end:494:9))"]
#[derive(Clone, Debug)]
struct STORE_S7Var0 {}
impl STORE_S7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:495:1, end:495:9))"]
#[derive(Clone, Debug)]
struct STORE_S7Var1 {
    STORE_S8: TableSTORE_S8,
}
impl STORE_S7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STORE_S8 = if let Some((len, table)) =
            TableSTORE_S8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STORE_S8 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_S7 {
    Var0(STORE_S7Var0),
    Var1(STORE_S7Var1),
}
impl TableSTORE_S7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 56 {
            if let Some((inst_len, parsed)) =
                STORE_S7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STORE_S7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:497:1, end:497:9))"]
#[derive(Clone, Debug)]
struct STORE_S6Var0 {}
impl STORE_S6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:498:1, end:498:9))"]
#[derive(Clone, Debug)]
struct STORE_S6Var1 {
    STORE_S7: TableSTORE_S7,
}
impl STORE_S6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STORE_S7 = if let Some((len, table)) =
            TableSTORE_S7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STORE_S7 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_S6 {
    Var0(STORE_S6Var0),
    Var1(STORE_S6Var1),
}
impl TableSTORE_S6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 24 {
            if let Some((inst_len, parsed)) =
                STORE_S6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STORE_S6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:500:1, end:500:9))"]
#[derive(Clone, Debug)]
struct STORE_S5Var0 {}
impl STORE_S5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:501:1, end:501:9))"]
#[derive(Clone, Debug)]
struct STORE_S5Var1 {
    STORE_S6: TableSTORE_S6,
}
impl STORE_S5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STORE_S6 = if let Some((len, table)) =
            TableSTORE_S6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STORE_S6 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_S5 {
    Var0(STORE_S5Var0),
    Var1(STORE_S5Var1),
}
impl TableSTORE_S5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 40 {
            if let Some((inst_len, parsed)) =
                STORE_S5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STORE_S5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:503:1, end:503:9))"]
#[derive(Clone, Debug)]
struct STORE_S4Var0 {}
impl STORE_S4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:504:1, end:504:9))"]
#[derive(Clone, Debug)]
struct STORE_S4Var1 {
    STORE_S5: TableSTORE_S5,
}
impl STORE_S4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STORE_S5 = if let Some((len, table)) =
            TableSTORE_S5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STORE_S5 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_S4 {
    Var0(STORE_S4Var0),
    Var1(STORE_S4Var1),
}
impl TableSTORE_S4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 8 {
            if let Some((inst_len, parsed)) =
                STORE_S4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STORE_S4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:506:1, end:506:9))"]
#[derive(Clone, Debug)]
struct STORE_S3Var0 {}
impl STORE_S3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:507:1, end:507:9))"]
#[derive(Clone, Debug)]
struct STORE_S3Var1 {
    STORE_S4: TableSTORE_S4,
}
impl STORE_S3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STORE_S4 = if let Some((len, table)) =
            TableSTORE_S4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STORE_S4 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_S3 {
    Var0(STORE_S3Var0),
    Var1(STORE_S3Var1),
}
impl TableSTORE_S3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 48 {
            if let Some((inst_len, parsed)) =
                STORE_S3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STORE_S3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:509:1, end:509:9))"]
#[derive(Clone, Debug)]
struct STORE_S2Var0 {}
impl STORE_S2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:510:1, end:510:9))"]
#[derive(Clone, Debug)]
struct STORE_S2Var1 {
    STORE_S3: TableSTORE_S3,
}
impl STORE_S2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STORE_S3 = if let Some((len, table)) =
            TableSTORE_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STORE_S3 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_S2 {
    Var0(STORE_S2Var0),
    Var1(STORE_S2Var1),
}
impl TableSTORE_S2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 16 {
            if let Some((inst_len, parsed)) =
                STORE_S2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STORE_S2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:512:1, end:512:9))"]
#[derive(Clone, Debug)]
struct STORE_S1Var0 {}
impl STORE_S1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:513:1, end:513:9))"]
#[derive(Clone, Debug)]
struct STORE_S1Var1 {
    STORE_S2: TableSTORE_S2,
}
impl STORE_S1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STORE_S2 = if let Some((len, table)) =
            TableSTORE_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STORE_S2 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_S1 {
    Var0(STORE_S1Var0),
    Var1(STORE_S1Var1),
}
impl TableSTORE_S1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 32 {
            if let Some((inst_len, parsed)) =
                STORE_S1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STORE_S1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:515:1, end:515:9))"]
#[derive(Clone, Debug)]
struct STORE_S0Var0 {}
impl STORE_S0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:516:1, end:516:9))"]
#[derive(Clone, Debug)]
struct STORE_S0Var1 {
    STORE_S1: TableSTORE_S1,
}
impl STORE_S0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STORE_S1 = if let Some((len, table)) =
            TableSTORE_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STORE_S1 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_S0 {
    Var0(STORE_S0Var0),
    Var1(STORE_S0Var1),
}
impl TableSTORE_S0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 0 {
            if let Some((inst_len, parsed)) =
                STORE_S0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STORE_S0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:518:1, end:518:11))"]
#[derive(Clone, Debug)]
struct STORE_SREGVar0 {}
impl STORE_SREGVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:519:1, end:519:11))"]
#[derive(Clone, Debug)]
struct STORE_SREGVar1 {
    STORE_S0: TableSTORE_S0,
}
impl STORE_SREGVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_38_display(context.read_ext_t4_name()),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STORE_S0 = if let Some((len, table)) =
            TableSTORE_S0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STORE_S0 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_SREG {
    Var0(STORE_SREGVar0),
    Var1(STORE_SREGVar1),
}
impl TableSTORE_SREG {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 60 == 0 {
            if let Some((inst_len, parsed)) =
                STORE_SREGVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STORE_SREGVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:521:1, end:521:9))"]
#[derive(Clone, Debug)]
struct STORE_RAVar0 {}
impl STORE_RAVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:522:1, end:522:9))"]
#[derive(Clone, Debug)]
struct STORE_RAVar1 {}
impl STORE_RAVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ra,")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_RA {
    Var0(STORE_RAVar0),
    Var1(STORE_RAVar1),
}
impl TableSTORE_RA {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 64 == 0 {
            if let Some((inst_len, parsed)) =
                STORE_RAVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 64 == 64 {
            if let Some((inst_len, parsed)) =
                STORE_RAVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:524:1, end:524:10))"]
#[derive(Clone, Debug)]
struct STORE_TOPVar0 {
    STORE_RA: TableSTORE_RA,
    EXT_CODE12: TableEXT_CODE12,
    STORE_SREG: TableSTORE_SREG,
}
impl STORE_TOPVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.STORE_SREG
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.STORE_RA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.EXT_CODE12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_33_display(context.read_ext_32_base()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_t4(
            u8::try_from(
                (i128::try_from(context_instance.read_ext_32_rlist()).unwrap() & 15i128) & 15,
            )
            .unwrap(),
        );
        context_instance.write_ext_tra(
            u8::try_from(
                u32::try_from(4i128)
                    .ok()
                    .and_then(|shr| {
                        i128::try_from(context_instance.read_ext_32_rlist())
                            .unwrap()
                            .checked_shr(shr)
                    })
                    .unwrap_or(0)
                    & 1,
            )
            .unwrap(),
        );
        let STORE_SREG = if let Some((len, table)) =
            TableSTORE_SREG::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let STORE_RA = if let Some((len, table)) =
            TableSTORE_RA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_CODE12 = if let Some((len, table)) =
            TableEXT_CODE12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                STORE_RA,
                EXT_CODE12,
                STORE_SREG,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_TOP {
    Var0(STORE_TOPVar0),
}
impl TableSTORE_TOP {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                STORE_TOPVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:533:1, end:533:12))"]
#[derive(Clone, Debug)]
struct STORE_TOP16Var0 {
    mic_list: u8,
    EXT_CODE4E: TableEXT_CODE4E,
    STORE_SREG: TableSTORE_SREG,
}
impl STORE_TOP16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.STORE_SREG
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::ra),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE4E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_t4(
            u8::try_from(
                i128::try_from(token_90(tokens_current))
                    .unwrap()
                    .wrapping_add(1i128)
                    & 15,
            )
            .unwrap(),
        );
        let STORE_SREG = if let Some((len, table)) =
            TableSTORE_SREG::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_CODE4E = if let Some((len, table)) =
            TableEXT_CODE4E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_list = token_90(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                EXT_CODE4E,
                STORE_SREG,
                mic_list,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/MIPS/data/languages/mipsmicro.sinc, start:542:1, end:542:12))"]
#[derive(Clone, Debug)]
struct STORE_TOP16Var1 {
    mic_listr6: u8,
    STORE_SREG: TableSTORE_SREG,
    EXT_CODE4E: TableEXT_CODE4E,
}
impl STORE_TOP16Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.STORE_SREG
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::ra),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.EXT_CODE4E
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ext_t4(
            u8::try_from(
                i128::try_from(token_91(tokens_current))
                    .unwrap()
                    .wrapping_add(1i128)
                    & 15,
            )
            .unwrap(),
        );
        let STORE_SREG = if let Some((len, table)) =
            TableSTORE_SREG::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let EXT_CODE4E = if let Some((len, table)) =
            TableEXT_CODE4E::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mic_listr6 = token_91(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                STORE_SREG,
                EXT_CODE4E,
                mic_listr6,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableSTORE_TOP16 {
    Var0(STORE_TOP16Var0),
    Var1(STORE_TOP16Var1),
}
impl TableSTORE_TOP16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 0 {
            if let Some((inst_len, parsed)) =
                STORE_TOP16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 536870912 == 536870912 {
            if let Some((inst_len, parsed)) =
                STORE_TOP16Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
pub fn parse_instruction(
    tokens: &[u8],
    context: &mut ContextMemory,
    inst_start: AddrType,
    global_set: &mut GlobalSet,
) -> Option<(u32, Vec<DisplayElement>)> {
    let (inst_len, instruction) = Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(&mut display, context, inst_start, inst_next, global_set);
    Some((inst_next, display))
}
