pub type AddrType = u64;
#[derive(Clone, Copy, Debug)]
pub enum Register {
    g0,
    g1,
    g2,
    g3,
    g4,
    g5,
    g6,
    g7,
    o0,
    o1,
    o2,
    o3,
    o4,
    o5,
    sp,
    o7,
    l0,
    l1,
    l2,
    l3,
    l4,
    l5,
    l6,
    l7,
    i0,
    i1,
    i2,
    i3,
    i4,
    i5,
    fp,
    i7,
    s_l0,
    s_l1,
    s_l2,
    s_l3,
    s_l4,
    s_l5,
    s_l6,
    s_l7,
    s_i0,
    s_i1,
    s_i2,
    s_i3,
    s_i4,
    s_i5,
    s_fp,
    s_i7,
    PC,
    nPC,
    TICK,
    Y,
    CCR,
    PCR,
    PIC,
    GSR,
    SOFTINT_SET,
    SOFTINT_CLR,
    SOFTINT,
    TICK_CMPR,
    STICK,
    STICK_CMPR,
    asr7,
    asr8,
    asr9,
    asr10,
    asr11,
    asr12,
    asr13,
    asr14,
    asr15,
    asr16,
    asr17,
    asr18,
    asr19,
    asr20,
    asr21,
    asr22,
    asr23,
    asr24,
    asr25,
    asr26,
    asr27,
    asr28,
    asr29,
    asr30,
    asr31,
    x_nf,
    x_zf,
    x_vf,
    x_cf,
    i_nf,
    i_zf,
    i_vf,
    i_cf,
    ASI,
    FPRS,
    fsr,
    fcc0,
    fcc1,
    fcc2,
    fcc3,
    didrestore,
    DECOMPILE_MODE,
    TPC1,
    TPC2,
    TPC3,
    TPC4,
    TNPC1,
    TNPC2,
    TNPC3,
    TNPC4,
    TSTATE1,
    TSTATE2,
    TSTATE3,
    TSTATE4,
    TT1,
    TT2,
    TT3,
    TT4,
    TCK,
    TBA,
    PSTATE,
    TL,
    PIL,
    CWP,
    CANSAVE,
    CANRESTORE,
    CLEANWIN,
    OTHERWIN,
    WSTATE,
    FQ,
    VER,
    GL,
    HPSTATE1,
    HPSTATE2,
    HPSTATE3,
    HPSTATE4,
    HTSTATE1,
    HTSTATE2,
    HTSTATE3,
    HTSTATE4,
    RESV2_1,
    RESV2_2,
    RESV2_3,
    RESV2_4,
    HINTP1,
    HINTP2,
    HINTP3,
    HINTP4,
    RESV4_1,
    RESV4_2,
    RESV4_3,
    RESV4_4,
    HTBA1,
    HTBA2,
    HTBA3,
    HTBA4,
    HVER1,
    HVER2,
    HVER3,
    HVER4,
    RESV30_1,
    RESV30_2,
    RESV30_3,
    RESV30_4,
    HSTICK_CMPR1,
    HSTICK_CMPR2,
    HSTICK_CMPR3,
    HSTICK_CMPR4,
    w010,
    w011,
    w012,
    w013,
    w014,
    w015,
    w016,
    w017,
    w020,
    w021,
    w022,
    w023,
    w024,
    w025,
    w026,
    w027,
    w030,
    w031,
    w032,
    w033,
    w034,
    w035,
    w036,
    w037,
    w110,
    w111,
    w112,
    w113,
    w114,
    w115,
    w116,
    w117,
    w120,
    w121,
    w122,
    w123,
    w124,
    w125,
    w126,
    w127,
    w130,
    w131,
    w132,
    w133,
    w134,
    w135,
    w136,
    w137,
    w210,
    w211,
    w212,
    w213,
    w214,
    w215,
    w216,
    w217,
    w220,
    w221,
    w222,
    w223,
    w224,
    w225,
    w226,
    w227,
    w230,
    w231,
    w232,
    w233,
    w234,
    w235,
    w236,
    w237,
    w310,
    w311,
    w312,
    w313,
    w314,
    w315,
    w316,
    w317,
    w320,
    w321,
    w322,
    w323,
    w324,
    w325,
    w326,
    w327,
    w330,
    w331,
    w332,
    w333,
    w334,
    w335,
    w336,
    w337,
    w410,
    w411,
    w412,
    w413,
    w414,
    w415,
    w416,
    w417,
    w420,
    w421,
    w422,
    w423,
    w424,
    w425,
    w426,
    w427,
    w430,
    w431,
    w432,
    w433,
    w434,
    w435,
    w436,
    w437,
    w510,
    w511,
    w512,
    w513,
    w514,
    w515,
    w516,
    w517,
    w520,
    w521,
    w522,
    w523,
    w524,
    w525,
    w526,
    w527,
    w530,
    w531,
    w532,
    w533,
    w534,
    w535,
    w536,
    w537,
    w610,
    w611,
    w612,
    w613,
    w614,
    w615,
    w616,
    w617,
    w620,
    w621,
    w622,
    w623,
    w624,
    w625,
    w626,
    w627,
    w630,
    w631,
    w632,
    w633,
    w634,
    w635,
    w636,
    w637,
    w710,
    w711,
    w712,
    w713,
    w714,
    w715,
    w716,
    w717,
    w720,
    w721,
    w722,
    w723,
    w724,
    w725,
    w726,
    w727,
    w730,
    w731,
    w732,
    w733,
    w734,
    w735,
    w736,
    w737,
    fs0,
    fs1,
    fs2,
    fs3,
    fs4,
    fs5,
    fs6,
    fs7,
    fs8,
    fs9,
    fs10,
    fs11,
    fs12,
    fs13,
    fs14,
    fs15,
    fs16,
    fs17,
    fs18,
    fs19,
    fs20,
    fs21,
    fs22,
    fs23,
    fs24,
    fs25,
    fs26,
    fs27,
    fs28,
    fs29,
    fs30,
    fs31,
    fd0,
    fd2,
    fd4,
    fd6,
    fd8,
    fd10,
    fd12,
    fd14,
    fd16,
    fd18,
    fd20,
    fd22,
    fd24,
    fd26,
    fd28,
    fd30,
    fd32,
    fd34,
    fd36,
    fd38,
    fd40,
    fd42,
    fd44,
    fd46,
    fd48,
    fd50,
    fd52,
    fd54,
    fd56,
    fd58,
    fd60,
    fd62,
    fq0,
    fq4,
    fq8,
    fq12,
    fq16,
    fq20,
    fq24,
    fq28,
    fq32,
    fq36,
    fq40,
    fq44,
    fq48,
    fq52,
    fq56,
    fq60,
}
impl Register {
    fn as_str(&self) -> &'static str {
        match self {
            Self::g0 => "g0",
            Self::g1 => "g1",
            Self::g2 => "g2",
            Self::g3 => "g3",
            Self::g4 => "g4",
            Self::g5 => "g5",
            Self::g6 => "g6",
            Self::g7 => "g7",
            Self::o0 => "o0",
            Self::o1 => "o1",
            Self::o2 => "o2",
            Self::o3 => "o3",
            Self::o4 => "o4",
            Self::o5 => "o5",
            Self::sp => "sp",
            Self::o7 => "o7",
            Self::l0 => "l0",
            Self::l1 => "l1",
            Self::l2 => "l2",
            Self::l3 => "l3",
            Self::l4 => "l4",
            Self::l5 => "l5",
            Self::l6 => "l6",
            Self::l7 => "l7",
            Self::i0 => "i0",
            Self::i1 => "i1",
            Self::i2 => "i2",
            Self::i3 => "i3",
            Self::i4 => "i4",
            Self::i5 => "i5",
            Self::fp => "fp",
            Self::i7 => "i7",
            Self::s_l0 => "s_l0",
            Self::s_l1 => "s_l1",
            Self::s_l2 => "s_l2",
            Self::s_l3 => "s_l3",
            Self::s_l4 => "s_l4",
            Self::s_l5 => "s_l5",
            Self::s_l6 => "s_l6",
            Self::s_l7 => "s_l7",
            Self::s_i0 => "s_i0",
            Self::s_i1 => "s_i1",
            Self::s_i2 => "s_i2",
            Self::s_i3 => "s_i3",
            Self::s_i4 => "s_i4",
            Self::s_i5 => "s_i5",
            Self::s_fp => "s_fp",
            Self::s_i7 => "s_i7",
            Self::PC => "PC",
            Self::nPC => "nPC",
            Self::TICK => "TICK",
            Self::Y => "Y",
            Self::CCR => "CCR",
            Self::PCR => "PCR",
            Self::PIC => "PIC",
            Self::GSR => "GSR",
            Self::SOFTINT_SET => "SOFTINT_SET",
            Self::SOFTINT_CLR => "SOFTINT_CLR",
            Self::SOFTINT => "SOFTINT",
            Self::TICK_CMPR => "TICK_CMPR",
            Self::STICK => "STICK",
            Self::STICK_CMPR => "STICK_CMPR",
            Self::asr7 => "asr7",
            Self::asr8 => "asr8",
            Self::asr9 => "asr9",
            Self::asr10 => "asr10",
            Self::asr11 => "asr11",
            Self::asr12 => "asr12",
            Self::asr13 => "asr13",
            Self::asr14 => "asr14",
            Self::asr15 => "asr15",
            Self::asr16 => "asr16",
            Self::asr17 => "asr17",
            Self::asr18 => "asr18",
            Self::asr19 => "asr19",
            Self::asr20 => "asr20",
            Self::asr21 => "asr21",
            Self::asr22 => "asr22",
            Self::asr23 => "asr23",
            Self::asr24 => "asr24",
            Self::asr25 => "asr25",
            Self::asr26 => "asr26",
            Self::asr27 => "asr27",
            Self::asr28 => "asr28",
            Self::asr29 => "asr29",
            Self::asr30 => "asr30",
            Self::asr31 => "asr31",
            Self::x_nf => "x_nf",
            Self::x_zf => "x_zf",
            Self::x_vf => "x_vf",
            Self::x_cf => "x_cf",
            Self::i_nf => "i_nf",
            Self::i_zf => "i_zf",
            Self::i_vf => "i_vf",
            Self::i_cf => "i_cf",
            Self::ASI => "ASI",
            Self::FPRS => "FPRS",
            Self::fsr => "fsr",
            Self::fcc0 => "fcc0",
            Self::fcc1 => "fcc1",
            Self::fcc2 => "fcc2",
            Self::fcc3 => "fcc3",
            Self::didrestore => "didrestore",
            Self::DECOMPILE_MODE => "DECOMPILE_MODE",
            Self::TPC1 => "TPC1",
            Self::TPC2 => "TPC2",
            Self::TPC3 => "TPC3",
            Self::TPC4 => "TPC4",
            Self::TNPC1 => "TNPC1",
            Self::TNPC2 => "TNPC2",
            Self::TNPC3 => "TNPC3",
            Self::TNPC4 => "TNPC4",
            Self::TSTATE1 => "TSTATE1",
            Self::TSTATE2 => "TSTATE2",
            Self::TSTATE3 => "TSTATE3",
            Self::TSTATE4 => "TSTATE4",
            Self::TT1 => "TT1",
            Self::TT2 => "TT2",
            Self::TT3 => "TT3",
            Self::TT4 => "TT4",
            Self::TCK => "TCK",
            Self::TBA => "TBA",
            Self::PSTATE => "PSTATE",
            Self::TL => "TL",
            Self::PIL => "PIL",
            Self::CWP => "CWP",
            Self::CANSAVE => "CANSAVE",
            Self::CANRESTORE => "CANRESTORE",
            Self::CLEANWIN => "CLEANWIN",
            Self::OTHERWIN => "OTHERWIN",
            Self::WSTATE => "WSTATE",
            Self::FQ => "FQ",
            Self::VER => "VER",
            Self::GL => "GL",
            Self::HPSTATE1 => "HPSTATE1",
            Self::HPSTATE2 => "HPSTATE2",
            Self::HPSTATE3 => "HPSTATE3",
            Self::HPSTATE4 => "HPSTATE4",
            Self::HTSTATE1 => "HTSTATE1",
            Self::HTSTATE2 => "HTSTATE2",
            Self::HTSTATE3 => "HTSTATE3",
            Self::HTSTATE4 => "HTSTATE4",
            Self::RESV2_1 => "RESV2_1",
            Self::RESV2_2 => "RESV2_2",
            Self::RESV2_3 => "RESV2_3",
            Self::RESV2_4 => "RESV2_4",
            Self::HINTP1 => "HINTP1",
            Self::HINTP2 => "HINTP2",
            Self::HINTP3 => "HINTP3",
            Self::HINTP4 => "HINTP4",
            Self::RESV4_1 => "RESV4_1",
            Self::RESV4_2 => "RESV4_2",
            Self::RESV4_3 => "RESV4_3",
            Self::RESV4_4 => "RESV4_4",
            Self::HTBA1 => "HTBA1",
            Self::HTBA2 => "HTBA2",
            Self::HTBA3 => "HTBA3",
            Self::HTBA4 => "HTBA4",
            Self::HVER1 => "HVER1",
            Self::HVER2 => "HVER2",
            Self::HVER3 => "HVER3",
            Self::HVER4 => "HVER4",
            Self::RESV30_1 => "RESV30_1",
            Self::RESV30_2 => "RESV30_2",
            Self::RESV30_3 => "RESV30_3",
            Self::RESV30_4 => "RESV30_4",
            Self::HSTICK_CMPR1 => "HSTICK_CMPR1",
            Self::HSTICK_CMPR2 => "HSTICK_CMPR2",
            Self::HSTICK_CMPR3 => "HSTICK_CMPR3",
            Self::HSTICK_CMPR4 => "HSTICK_CMPR4",
            Self::w010 => "w010",
            Self::w011 => "w011",
            Self::w012 => "w012",
            Self::w013 => "w013",
            Self::w014 => "w014",
            Self::w015 => "w015",
            Self::w016 => "w016",
            Self::w017 => "w017",
            Self::w020 => "w020",
            Self::w021 => "w021",
            Self::w022 => "w022",
            Self::w023 => "w023",
            Self::w024 => "w024",
            Self::w025 => "w025",
            Self::w026 => "w026",
            Self::w027 => "w027",
            Self::w030 => "w030",
            Self::w031 => "w031",
            Self::w032 => "w032",
            Self::w033 => "w033",
            Self::w034 => "w034",
            Self::w035 => "w035",
            Self::w036 => "w036",
            Self::w037 => "w037",
            Self::w110 => "w110",
            Self::w111 => "w111",
            Self::w112 => "w112",
            Self::w113 => "w113",
            Self::w114 => "w114",
            Self::w115 => "w115",
            Self::w116 => "w116",
            Self::w117 => "w117",
            Self::w120 => "w120",
            Self::w121 => "w121",
            Self::w122 => "w122",
            Self::w123 => "w123",
            Self::w124 => "w124",
            Self::w125 => "w125",
            Self::w126 => "w126",
            Self::w127 => "w127",
            Self::w130 => "w130",
            Self::w131 => "w131",
            Self::w132 => "w132",
            Self::w133 => "w133",
            Self::w134 => "w134",
            Self::w135 => "w135",
            Self::w136 => "w136",
            Self::w137 => "w137",
            Self::w210 => "w210",
            Self::w211 => "w211",
            Self::w212 => "w212",
            Self::w213 => "w213",
            Self::w214 => "w214",
            Self::w215 => "w215",
            Self::w216 => "w216",
            Self::w217 => "w217",
            Self::w220 => "w220",
            Self::w221 => "w221",
            Self::w222 => "w222",
            Self::w223 => "w223",
            Self::w224 => "w224",
            Self::w225 => "w225",
            Self::w226 => "w226",
            Self::w227 => "w227",
            Self::w230 => "w230",
            Self::w231 => "w231",
            Self::w232 => "w232",
            Self::w233 => "w233",
            Self::w234 => "w234",
            Self::w235 => "w235",
            Self::w236 => "w236",
            Self::w237 => "w237",
            Self::w310 => "w310",
            Self::w311 => "w311",
            Self::w312 => "w312",
            Self::w313 => "w313",
            Self::w314 => "w314",
            Self::w315 => "w315",
            Self::w316 => "w316",
            Self::w317 => "w317",
            Self::w320 => "w320",
            Self::w321 => "w321",
            Self::w322 => "w322",
            Self::w323 => "w323",
            Self::w324 => "w324",
            Self::w325 => "w325",
            Self::w326 => "w326",
            Self::w327 => "w327",
            Self::w330 => "w330",
            Self::w331 => "w331",
            Self::w332 => "w332",
            Self::w333 => "w333",
            Self::w334 => "w334",
            Self::w335 => "w335",
            Self::w336 => "w336",
            Self::w337 => "w337",
            Self::w410 => "w410",
            Self::w411 => "w411",
            Self::w412 => "w412",
            Self::w413 => "w413",
            Self::w414 => "w414",
            Self::w415 => "w415",
            Self::w416 => "w416",
            Self::w417 => "w417",
            Self::w420 => "w420",
            Self::w421 => "w421",
            Self::w422 => "w422",
            Self::w423 => "w423",
            Self::w424 => "w424",
            Self::w425 => "w425",
            Self::w426 => "w426",
            Self::w427 => "w427",
            Self::w430 => "w430",
            Self::w431 => "w431",
            Self::w432 => "w432",
            Self::w433 => "w433",
            Self::w434 => "w434",
            Self::w435 => "w435",
            Self::w436 => "w436",
            Self::w437 => "w437",
            Self::w510 => "w510",
            Self::w511 => "w511",
            Self::w512 => "w512",
            Self::w513 => "w513",
            Self::w514 => "w514",
            Self::w515 => "w515",
            Self::w516 => "w516",
            Self::w517 => "w517",
            Self::w520 => "w520",
            Self::w521 => "w521",
            Self::w522 => "w522",
            Self::w523 => "w523",
            Self::w524 => "w524",
            Self::w525 => "w525",
            Self::w526 => "w526",
            Self::w527 => "w527",
            Self::w530 => "w530",
            Self::w531 => "w531",
            Self::w532 => "w532",
            Self::w533 => "w533",
            Self::w534 => "w534",
            Self::w535 => "w535",
            Self::w536 => "w536",
            Self::w537 => "w537",
            Self::w610 => "w610",
            Self::w611 => "w611",
            Self::w612 => "w612",
            Self::w613 => "w613",
            Self::w614 => "w614",
            Self::w615 => "w615",
            Self::w616 => "w616",
            Self::w617 => "w617",
            Self::w620 => "w620",
            Self::w621 => "w621",
            Self::w622 => "w622",
            Self::w623 => "w623",
            Self::w624 => "w624",
            Self::w625 => "w625",
            Self::w626 => "w626",
            Self::w627 => "w627",
            Self::w630 => "w630",
            Self::w631 => "w631",
            Self::w632 => "w632",
            Self::w633 => "w633",
            Self::w634 => "w634",
            Self::w635 => "w635",
            Self::w636 => "w636",
            Self::w637 => "w637",
            Self::w710 => "w710",
            Self::w711 => "w711",
            Self::w712 => "w712",
            Self::w713 => "w713",
            Self::w714 => "w714",
            Self::w715 => "w715",
            Self::w716 => "w716",
            Self::w717 => "w717",
            Self::w720 => "w720",
            Self::w721 => "w721",
            Self::w722 => "w722",
            Self::w723 => "w723",
            Self::w724 => "w724",
            Self::w725 => "w725",
            Self::w726 => "w726",
            Self::w727 => "w727",
            Self::w730 => "w730",
            Self::w731 => "w731",
            Self::w732 => "w732",
            Self::w733 => "w733",
            Self::w734 => "w734",
            Self::w735 => "w735",
            Self::w736 => "w736",
            Self::w737 => "w737",
            Self::fs0 => "fs0",
            Self::fs1 => "fs1",
            Self::fs2 => "fs2",
            Self::fs3 => "fs3",
            Self::fs4 => "fs4",
            Self::fs5 => "fs5",
            Self::fs6 => "fs6",
            Self::fs7 => "fs7",
            Self::fs8 => "fs8",
            Self::fs9 => "fs9",
            Self::fs10 => "fs10",
            Self::fs11 => "fs11",
            Self::fs12 => "fs12",
            Self::fs13 => "fs13",
            Self::fs14 => "fs14",
            Self::fs15 => "fs15",
            Self::fs16 => "fs16",
            Self::fs17 => "fs17",
            Self::fs18 => "fs18",
            Self::fs19 => "fs19",
            Self::fs20 => "fs20",
            Self::fs21 => "fs21",
            Self::fs22 => "fs22",
            Self::fs23 => "fs23",
            Self::fs24 => "fs24",
            Self::fs25 => "fs25",
            Self::fs26 => "fs26",
            Self::fs27 => "fs27",
            Self::fs28 => "fs28",
            Self::fs29 => "fs29",
            Self::fs30 => "fs30",
            Self::fs31 => "fs31",
            Self::fd0 => "fd0",
            Self::fd2 => "fd2",
            Self::fd4 => "fd4",
            Self::fd6 => "fd6",
            Self::fd8 => "fd8",
            Self::fd10 => "fd10",
            Self::fd12 => "fd12",
            Self::fd14 => "fd14",
            Self::fd16 => "fd16",
            Self::fd18 => "fd18",
            Self::fd20 => "fd20",
            Self::fd22 => "fd22",
            Self::fd24 => "fd24",
            Self::fd26 => "fd26",
            Self::fd28 => "fd28",
            Self::fd30 => "fd30",
            Self::fd32 => "fd32",
            Self::fd34 => "fd34",
            Self::fd36 => "fd36",
            Self::fd38 => "fd38",
            Self::fd40 => "fd40",
            Self::fd42 => "fd42",
            Self::fd44 => "fd44",
            Self::fd46 => "fd46",
            Self::fd48 => "fd48",
            Self::fd50 => "fd50",
            Self::fd52 => "fd52",
            Self::fd54 => "fd54",
            Self::fd56 => "fd56",
            Self::fd58 => "fd58",
            Self::fd60 => "fd60",
            Self::fd62 => "fd62",
            Self::fq0 => "fq0",
            Self::fq4 => "fq4",
            Self::fq8 => "fq8",
            Self::fq12 => "fq12",
            Self::fq16 => "fq16",
            Self::fq20 => "fq20",
            Self::fq24 => "fq24",
            Self::fq28 => "fq28",
            Self::fq32 => "fq32",
            Self::fq36 => "fq36",
            Self::fq40 => "fq40",
            Self::fq44 => "fq44",
            Self::fq48 => "fq48",
            Self::fq52 => "fq52",
            Self::fq56 => "fq56",
            Self::fq60 => "fq60",
        }
    }
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::g0,
        1 => Register::g1,
        2 => Register::g2,
        3 => Register::g3,
        4 => Register::g4,
        5 => Register::g5,
        6 => Register::g6,
        7 => Register::g7,
        8 => Register::o0,
        9 => Register::o1,
        10 => Register::o2,
        11 => Register::o3,
        12 => Register::o4,
        13 => Register::o5,
        14 => Register::sp,
        15 => Register::o7,
        16 => Register::l0,
        17 => Register::l1,
        18 => Register::l2,
        19 => Register::l3,
        20 => Register::l4,
        21 => Register::l5,
        22 => Register::l6,
        23 => Register::l7,
        24 => Register::i0,
        25 => Register::i1,
        26 => Register::i2,
        27 => Register::i3,
        28 => Register::i4,
        29 => Register::i5,
        30 => Register::fp,
        31 => Register::i7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fcc0,
        1 => Register::fcc1,
        2 => Register::fcc2,
        3 => Register::fcc3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::Y,
        2 => Register::CCR,
        4 => Register::TICK,
        16 => Register::PCR,
        17 => Register::PIC,
        18 => Register::asr18,
        19 => Register::GSR,
        20 => Register::SOFTINT_SET,
        21 => Register::SOFTINT_CLR,
        22 => Register::SOFTINT,
        23 => Register::TICK_CMPR,
        24 => Register::STICK,
        25 => Register::STICK_CMPR,
        26 => Register::asr26,
        27 => Register::asr27,
        28 => Register::asr28,
        29 => Register::asr29,
        30 => Register::asr30,
        31 => Register::asr31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::Y,
        16 => Register::PCR,
        17 => Register::PIC,
        18 => Register::asr18,
        19 => Register::GSR,
        20 => Register::SOFTINT_SET,
        21 => Register::SOFTINT_CLR,
        22 => Register::SOFTINT,
        23 => Register::TICK_CMPR,
        24 => Register::STICK,
        25 => Register::STICK_CMPR,
        26 => Register::asr26,
        27 => Register::asr27,
        28 => Register::asr28,
        29 => Register::asr29,
        30 => Register::asr30,
        31 => Register::asr31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::TPC1,
        1 => Register::TNPC1,
        2 => Register::TSTATE1,
        3 => Register::TT1,
        4 => Register::TCK,
        5 => Register::TBA,
        6 => Register::PSTATE,
        7 => Register::TL,
        8 => Register::PIL,
        9 => Register::CWP,
        10 => Register::CANSAVE,
        11 => Register::CANRESTORE,
        12 => Register::CLEANWIN,
        13 => Register::OTHERWIN,
        14 => Register::WSTATE,
        15 => Register::FQ,
        16 => Register::GL,
        31 => Register::VER,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fs0,
        1 => Register::fs1,
        2 => Register::fs2,
        3 => Register::fs3,
        4 => Register::fs4,
        5 => Register::fs5,
        6 => Register::fs6,
        7 => Register::fs7,
        8 => Register::fs8,
        9 => Register::fs9,
        10 => Register::fs10,
        11 => Register::fs11,
        12 => Register::fs12,
        13 => Register::fs13,
        14 => Register::fs14,
        15 => Register::fs15,
        16 => Register::fs16,
        17 => Register::fs17,
        18 => Register::fs18,
        19 => Register::fs19,
        20 => Register::fs20,
        21 => Register::fs21,
        22 => Register::fs22,
        23 => Register::fs23,
        24 => Register::fs24,
        25 => Register::fs25,
        26 => Register::fs26,
        27 => Register::fs27,
        28 => Register::fs28,
        29 => Register::fs29,
        30 => Register::fs30,
        31 => Register::fs31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fd0,
        1 => Register::fd32,
        2 => Register::fd2,
        3 => Register::fd34,
        4 => Register::fd4,
        5 => Register::fd36,
        6 => Register::fd6,
        7 => Register::fd38,
        8 => Register::fd8,
        9 => Register::fd40,
        10 => Register::fd10,
        11 => Register::fd42,
        12 => Register::fd12,
        13 => Register::fd44,
        14 => Register::fd14,
        15 => Register::fd46,
        16 => Register::fd16,
        17 => Register::fd48,
        18 => Register::fd18,
        19 => Register::fd50,
        20 => Register::fd20,
        21 => Register::fd52,
        22 => Register::fd22,
        23 => Register::fd54,
        24 => Register::fd24,
        25 => Register::fd56,
        26 => Register::fd26,
        27 => Register::fd58,
        28 => Register::fd28,
        29 => Register::fd60,
        30 => Register::fd30,
        31 => Register::fd62,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_7_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fq0,
        2 => Register::fq32,
        4 => Register::fq4,
        6 => Register::fq36,
        8 => Register::fq8,
        10 => Register::fq40,
        12 => Register::fq12,
        14 => Register::fq44,
        16 => Register::fq16,
        18 => Register::fq48,
        20 => Register::fq20,
        22 => Register::fq52,
        24 => Register::fq24,
        26 => Register::fq56,
        28 => Register::fq28,
        30 => Register::fq60,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_7_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, bool, u64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(true, false, value) => {
                write!(f, "0x{:x}", value)
            }
            Self::Number(true, true, value) => {
                write!(f, "-0x{:x}", value)
            }
            Self::Number(false, false, value) => value.fmt(f),
            Self::Number(false, true, value) => {
                write!(f, "-{:x}", value)
            }
        }
    }
}
#[doc = "Create token_fields: cc0_3"]
fn token_16(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 1) as u8)
}
#[doc = "Create token_fields: rs1 rs1_zero rs_asr prs1 fsrs1 fdrs1 fqrs1"]
fn token_25(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 14) & 31) as u8)
}
#[doc = "Create token_fields: opf"]
fn token_36(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 511) as u16)
}
#[doc = "Create token_fields: opf6 opf_low"]
fn token_38(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 63) as u8)
}
#[doc = "Create token_fields: simm11"]
fn token_31(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 2047) as u16)
}
#[doc = "Create token_fields: cond4"]
fn token_11(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 14) & 15) as u8)
}
#[doc = "Create token_fields: cc0_4"]
fn token_18(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 1) as u8)
}
#[doc = "Create token_fields: rd rd_d rd_asr rd_zero fsrd fdrd fqrd prd fcn"]
fn token_23(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 31) as u8)
}
#[doc = "Create token_fields: simm10"]
fn token_32(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 1023) as u16)
}
#[doc = "Create token_fields: op2"]
fn token_7(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 22) & 7) as u8)
}
#[doc = "Create token_fields: disp19"]
fn token_4(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 524287) as u32)
}
#[doc = "Create token_fields: cond"]
fn token_10(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 15) as u8)
}
#[doc = "Create token_fields: a"]
fn token_8(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 29) & 1) as u8)
}
#[doc = "Create token_fields: simm13"]
fn token_30(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 8191) as u16)
}
#[doc = "Create token_fields: rcond2"]
fn token_12(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 7) as u8)
}
#[doc = "Create token_fields: cc1"]
fn token_14(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 1) as u8)
}
#[doc = "Create token_fields: d16lo"]
fn token_5(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 16383) as u16)
}
#[doc = "Create token_fields: imm_asi"]
fn token_33(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 255) as u8)
}
#[doc = "Create token_fields: opf5 opf_low_5_9"]
fn token_37(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 31) as u8)
}
#[doc = "Create token_fields: opf_cc"]
fn token_39(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 7) as u8)
}
#[doc = "Create token_fields: cc1_4 x"]
fn token_19(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 12) & 1) as u8)
}
#[doc = "Create token_fields: cc0"]
fn token_13(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 1) as u8)
}
#[doc = "Create token_fields: fccn2"]
fn token_15(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 3) as u8)
}
#[doc = "Create token_fields: cc1_3"]
fn token_17(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 26) & 1) as u8)
}
#[doc = "Create token_fields: disp30"]
fn token_2(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 1073741823) as u32)
}
#[doc = "Create token_fields: fpc"]
fn token_9(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 27) & 7) as u8)
}
#[doc = "Create token_fields: op"]
fn token_1(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 30) & 3) as u8)
}
#[doc = "Create token_fields: cc2_4 bit18"]
fn token_21(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 18) & 1) as u8)
}
#[doc = "Create token_fields: bit28"]
fn token_41(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 28) & 1) as u8)
}
#[doc = "Create token_fields: fccn_4"]
fn token_20(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 3) as u8)
}
#[doc = "Create token_fields: udisp22 disp22 const22"]
fn token_3(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 4194303) as u32)
}
#[doc = "Create token_fields: cmask"]
fn token_34(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 7) as u8)
}
#[doc = "Create token_fields: d16hi fccn"]
fn token_6(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 3) as u8)
}
#[doc = "Create token_fields: i bit13"]
fn token_26(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 1) as u8)
}
#[doc = "Create token_fields: rs2 rs2_zero fsrs2 fdrs2 fqrs2 shcnt32"]
fn token_28(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 31) as u8)
}
#[doc = "Create token_fields: rcond3"]
fn token_27(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 7) as u8)
}
#[doc = "Create token_fields: shcnt64"]
fn token_29(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 63) as u8)
}
#[doc = "Create token_fields: swtrap"]
fn token_40(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 127) as u8)
}
#[doc = "Create token_fields: p"]
fn token_22(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 19) & 1) as u8)
}
#[doc = "Create token_fields: op3"]
fn token_24(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 19) & 63) as u8)
}
#[doc = "Create token_fields: mmask"]
fn token_35(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 15) as u8)
}
#[derive(Clone, Copy, Default)]
pub struct ContextMemory(pub ());
#[derive(Clone, Copy, Default)]
pub struct GlobalSet(());
impl GlobalSet {
    pub fn new(_: ContextMemory) -> Self {
        Self(())
    }
    pub fn set(&mut self, _: Option<AddrType>, _: impl FnOnce(&mut ContextMemory)) {
        unreachable!()
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:631:1, end:631:2))"]
#[derive(Clone, Debug)]
struct nop_instructionVar0 {}
impl nop_instructionVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nop"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:808:1, end:808:2))"]
#[derive(Clone, Debug)]
struct call_instructionVar1 {
    callreloff: Tablecallreloff,
}
impl call_instructionVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("call"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.callreloff
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let callreloff = if let Some((len, table)) =
            Tablecallreloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { callreloff }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:995:1, end:995:2))"]
#[derive(Clone, Debug)]
struct ret_instructionVar2 {
    retea: Tableretea,
}
impl ret_instructionVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ret"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let retea = if let Some((len, table)) =
            Tableretea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { retea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:996:1, end:996:2))"]
#[derive(Clone, Debug)]
struct retl_instructionVar3 {
    retea: Tableretea,
}
impl retl_instructionVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("retl"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let retea = if let Some((len, table)) =
            Tableretea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { retea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1065:1, end:1065:2))"]
#[derive(Clone, Debug)]
struct membar_instructionVar4 {
    membar_mask: Tablemembar_mask,
}
impl membar_instructionVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("membar"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.membar_mask
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let membar_mask = if let Some((len, table)) =
            Tablemembar_mask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { membar_mask }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1067:1, end:1067:2))"]
#[derive(Clone, Debug)]
struct stbar_instructionVar5 {}
impl stbar_instructionVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stbar"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1069:1, end:1069:2))"]
#[derive(Clone, Debug)]
struct sir_instructionVar6 {
    simm13: u16,
}
impl sir_instructionVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sir"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.simm13 & 4096 != 0 {
                    -1 & !4095
                } else {
                    0
                } | self.simm13 as i16)
                    .is_negative(),
                (if self.simm13 & 4096 != 0 {
                    -1 & !4095
                } else {
                    0
                } | self.simm13 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let simm13 = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:594:1, end:594:2))"]
#[derive(Clone, Debug)]
struct clrx_instructionVar7 {
    ea: Tableea,
}
impl clrx_instructionVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clrx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:595:1, end:595:2))"]
#[derive(Clone, Debug)]
struct clrd_instructionVar8 {
    ea: Tableea,
}
impl clrd_instructionVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clrd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:635:1, end:635:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar9 {
    regorimm: Tableregorimm,
    RS1: TableRS1,
}
impl cmp_instructionVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:952:1, end:952:2))"]
#[derive(Clone, Debug)]
struct rd_instructionVar10 {
    rsASR: TablersASR,
    RD: TableRD,
}
impl rd_instructionVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rsASR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rsASR = if let Some((len, table)) =
            TablersASR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rsASR, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:645:1, end:645:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar11 {
    RD: TableRD,
    regorimm: Tableregorimm,
}
impl mov_instructionVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:980:1, end:980:2))"]
#[derive(Clone, Debug)]
struct popc_instructionVar12 {
    RD: TableRD,
    regorimm: Tableregorimm,
}
impl popc_instructionVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("popc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1086:1, end:1086:2))"]
#[derive(Clone, Debug)]
struct rdpr_instructionVar13 {
    RD: TableRD,
    tpc: Tabletpc,
}
impl rdpr_instructionVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.tpc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let tpc = if let Some((len, table)) =
            Tabletpc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, tpc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1087:1, end:1087:2))"]
#[derive(Clone, Debug)]
struct rdpr_instructionVar14 {
    RD: TableRD,
    tnpc: Tabletnpc,
}
impl rdpr_instructionVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.tnpc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let tnpc = if let Some((len, table)) =
            Tabletnpc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, tnpc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1088:1, end:1088:2))"]
#[derive(Clone, Debug)]
struct rdpr_instructionVar15 {
    RD: TableRD,
    tt: Tablett,
}
impl rdpr_instructionVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.tt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let tt = if let Some((len, table)) =
            Tablett::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, tt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1089:1, end:1089:2))"]
#[derive(Clone, Debug)]
struct rdpr_instructionVar16 {
    tstate: Tabletstate,
    RD: TableRD,
}
impl rdpr_instructionVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.tstate
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let tstate = if let Some((len, table)) =
            Tabletstate::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { tstate, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1111:1, end:1111:2))"]
#[derive(Clone, Debug)]
struct rdhpr_instructionVar17 {
    RD: TableRD,
    hpstate: Tablehpstate,
}
impl rdhpr_instructionVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.hpstate
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let hpstate = if let Some((len, table)) =
            Tablehpstate::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, hpstate }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1112:1, end:1112:2))"]
#[derive(Clone, Debug)]
struct rdhpr_instructionVar18 {
    RD: TableRD,
    htstate: Tablehtstate,
}
impl rdhpr_instructionVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.htstate
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let htstate = if let Some((len, table)) =
            Tablehtstate::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, htstate }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1113:1, end:1113:2))"]
#[derive(Clone, Debug)]
struct rdhpr_instructionVar19 {
    RD: TableRD,
    hintp: Tablehintp,
}
impl rdhpr_instructionVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.hintp
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let hintp = if let Some((len, table)) =
            Tablehintp::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, hintp }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1114:1, end:1114:2))"]
#[derive(Clone, Debug)]
struct rdhpr_instructionVar20 {
    RD: TableRD,
    htba: Tablehtba,
}
impl rdhpr_instructionVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.htba
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let htba = if let Some((len, table)) =
            Tablehtba::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, htba }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1115:1, end:1115:2))"]
#[derive(Clone, Debug)]
struct rdhpr_instructionVar21 {
    RD: TableRD,
    hver: Tablehver,
}
impl rdhpr_instructionVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.hver
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let hver = if let Some((len, table)) =
            Tablehver::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, hver }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1116:1, end:1116:2))"]
#[derive(Clone, Debug)]
struct rdhpr_instructionVar22 {
    hsys_tick_cmpr: Tablehsys_tick_cmpr,
    RD: TableRD,
}
impl rdhpr_instructionVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.hsys_tick_cmpr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let hsys_tick_cmpr = if let Some((len, table)) =
            Tablehsys_tick_cmpr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { hsys_tick_cmpr, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1117:1, end:1117:2))"]
#[derive(Clone, Debug)]
struct rdhpr_instructionVar23 {
    RD: TableRD,
    resv30: Tableresv30,
}
impl rdhpr_instructionVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.resv30
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let resv30 = if let Some((len, table)) =
            Tableresv30::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, resv30 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1371:1, end:1371:2))"]
#[derive(Clone, Debug)]
struct fmovs_instructionVar24 {
    fsrs2: u8,
    fsrd: u8,
    fcc_icc_xcc: Tablefcc_icc_xcc,
    fmfcc_or_fmicc: Tablefmfcc_or_fmicc,
}
impl fmovs_instructionVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovs"));
        self.fmfcc_or_fmicc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.fcc_icc_xcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmfcc_or_fmicc = if let Some((len, table)) =
            Tablefmfcc_or_fmicc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fcc_icc_xcc = if let Some((len, table)) =
            Tablefcc_icc_xcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fcc_icc_xcc,
                fmfcc_or_fmicc,
                fsrs2,
                fsrd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1373:1, end:1373:2))"]
#[derive(Clone, Debug)]
struct fmovd_instructionVar25 {
    fdrs2: u8,
    fdrd: u8,
    fcc_icc_xcc: Tablefcc_icc_xcc,
    fmfcc_or_fmicc: Tablefmfcc_or_fmicc,
}
impl fmovd_instructionVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovd"));
        self.fmfcc_or_fmicc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.fcc_icc_xcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmfcc_or_fmicc = if let Some((len, table)) =
            Tablefmfcc_or_fmicc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fcc_icc_xcc = if let Some((len, table)) =
            Tablefcc_icc_xcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fcc_icc_xcc,
                fmfcc_or_fmicc,
                fdrs2,
                fdrd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1375:1, end:1375:2))"]
#[derive(Clone, Debug)]
struct fmovq_instructionVar26 {
    fqrs2: u8,
    fqrd: u8,
    fmfcc_or_fmicc: Tablefmfcc_or_fmicc,
    fcc_icc_xcc: Tablefcc_icc_xcc,
}
impl fmovq_instructionVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovq"));
        self.fmfcc_or_fmicc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.fcc_icc_xcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmfcc_or_fmicc = if let Some((len, table)) =
            Tablefmfcc_or_fmicc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fcc_icc_xcc = if let Some((len, table)) =
            Tablefcc_icc_xcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fqrs2 = token_28(tokens_current);
        let fqrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fmfcc_or_fmicc,
                fcc_icc_xcc,
                fqrs2,
                fqrd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:710:1, end:710:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar27 {
    m_cc: Tablem_cc,
    RD: TableRD,
    regorimm11: Tableregorimm11,
    MICC: TableMICC,
}
impl mov_instructionVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.m_cc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.MICC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let m_cc = if let Some((len, table)) =
            Tablem_cc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let MICC = if let Some((len, table)) =
            TableMICC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm11 = if let Some((len, table)) =
            Tableregorimm11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                m_cc,
                RD,
                regorimm11,
                MICC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1308:1, end:1308:2))"]
#[derive(Clone, Debug)]
struct fcmps_instructionVar28 {
    fccn2: u8,
    fsrs1: u8,
    fsrs2: u8,
}
impl fcmps_instructionVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmps"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("%"),
            meaning_1_display(self.fccn2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrs1),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrs2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn2 = token_15(tokens_current);
        let fsrs2 = token_28(tokens_current);
        let fsrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fccn2,
                fsrs1,
                fsrs2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1309:1, end:1309:2))"]
#[derive(Clone, Debug)]
struct fcmpd_instructionVar29 {
    fccn2: u8,
    fdrs1: u8,
    fdrs2: u8,
}
impl fcmpd_instructionVar29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmpd"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("%"),
            meaning_1_display(self.fccn2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn2 = token_15(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fccn2,
                fdrs1,
                fdrs2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1310:1, end:1310:2))"]
#[derive(Clone, Debug)]
struct fcmpq_instructionVar30 {
    fccn2: u8,
    fqrs1: u8,
    fqrs2: u8,
}
impl fcmpq_instructionVar30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmpq"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("%"),
            meaning_1_display(self.fccn2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrs1),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrs2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn2 = token_15(tokens_current);
        let fqrs2 = token_28(tokens_current);
        let fqrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fccn2,
                fqrs1,
                fqrs2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1312:1, end:1312:2))"]
#[derive(Clone, Debug)]
struct fcmpes_instructionVar31 {
    fccn2: u8,
    fsrs1: u8,
    fsrs2: u8,
}
impl fcmpes_instructionVar31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmpes"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("%"),
            meaning_1_display(self.fccn2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrs1),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrs2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrs1 = token_25(tokens_current);
        let fccn2 = token_15(tokens_current);
        let fsrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fccn2,
                fsrs1,
                fsrs2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1313:1, end:1313:2))"]
#[derive(Clone, Debug)]
struct fcmped_instructionVar32 {
    fccn2: u8,
    fdrs1: u8,
    fdrs2: u8,
}
impl fcmped_instructionVar32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmped"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("%"),
            meaning_1_display(self.fccn2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fccn2 = token_15(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fccn2,
                fdrs1,
                fdrs2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1314:1, end:1314:2))"]
#[derive(Clone, Debug)]
struct fcmpeq_instructionVar33 {
    fccn2: u8,
    fqrs1: u8,
    fqrs2: u8,
}
impl fcmpeq_instructionVar33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmpeq"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("%"),
            meaning_1_display(self.fccn2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrs1),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrs2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrs1 = token_25(tokens_current);
        let fccn2 = token_15(tokens_current);
        let fqrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fccn2,
                fqrs1,
                fqrs2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1181:1, end:1181:2))"]
#[derive(Clone, Debug)]
struct fabss_instructionVar34 {
    fsrs2: u8,
    fsrd: u8,
}
impl fabss_instructionVar34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fabss"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrs2 = token_28(tokens_current);
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1182:1, end:1182:2))"]
#[derive(Clone, Debug)]
struct fabsd_instructionVar35 {
    fdrs2: u8,
    fdrd: u8,
}
impl fabsd_instructionVar35 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fabsd"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1183:1, end:1183:2))"]
#[derive(Clone, Debug)]
struct fabsq_instructionVar36 {
    fqrs2: u8,
    fqrd: u8,
}
impl fabsq_instructionVar36 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fabsq"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrd = token_23(tokens_current);
        let fqrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fqrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1185:1, end:1185:2))"]
#[derive(Clone, Debug)]
struct fadds_instructionVar37 {
    fsrs1: u8,
    fsrs2: u8,
    fsrd: u8,
}
impl fadds_instructionVar37 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fadds"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs1),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrs1 = token_25(tokens_current);
        let fsrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs1, fsrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1186:1, end:1186:2))"]
#[derive(Clone, Debug)]
struct faddd_instructionVar38 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl faddd_instructionVar38 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("faddd"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1187:1, end:1187:2))"]
#[derive(Clone, Debug)]
struct faddq_instructionVar39 {
    fqrs1: u8,
    fqrs2: u8,
    fqrd: u8,
}
impl faddq_instructionVar39 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("faddq"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrs1),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrs1 = token_25(tokens_current);
        let fqrs2 = token_28(tokens_current);
        let fqrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fqrs1, fqrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1189:1, end:1189:2))"]
#[derive(Clone, Debug)]
struct fdivs_instructionVar40 {
    fsrs1: u8,
    fsrs2: u8,
    fsrd: u8,
}
impl fdivs_instructionVar40 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdivs"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs1),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrs2 = token_28(tokens_current);
        let fsrd = token_23(tokens_current);
        let fsrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs1, fsrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1190:1, end:1190:2))"]
#[derive(Clone, Debug)]
struct fdivd_instructionVar41 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fdivd_instructionVar41 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdivd"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1191:1, end:1191:2))"]
#[derive(Clone, Debug)]
struct fdivq_instructionVar42 {
    fqrs1: u8,
    fqrs2: u8,
    fqrd: u8,
}
impl fdivq_instructionVar42 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdivq"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrs1),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrs1 = token_25(tokens_current);
        let fqrs2 = token_28(tokens_current);
        let fqrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fqrs1, fqrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1193:1, end:1193:2))"]
#[derive(Clone, Debug)]
struct fdmulq_instructionVar43 {
    fdrs1: u8,
    fdrs2: u8,
    fqrd: u8,
}
impl fdmulq_instructionVar43 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdmulq"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1198:1, end:1198:2))"]
#[derive(Clone, Debug)]
struct fsmuld_instructionVar44 {
    fsrs1: u8,
    fsrs2: u8,
    fdrd: u8,
}
impl fsmuld_instructionVar44 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsmuld"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs1),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        let fsrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs1, fsrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1204:1, end:1204:2))"]
#[derive(Clone, Debug)]
struct fitos_instructionVar45 {
    fsrs2: u8,
    fsrd: u8,
}
impl fitos_instructionVar45 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fitos"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1205:1, end:1205:2))"]
#[derive(Clone, Debug)]
struct fitod_instructionVar46 {
    fsrs2: u8,
    fdrd: u8,
}
impl fitod_instructionVar46 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fitod"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1206:1, end:1206:2))"]
#[derive(Clone, Debug)]
struct fitoq_instructionVar47 {
    fsrs2: u8,
    fqrd: u8,
}
impl fitoq_instructionVar47 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fitoq"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1208:1, end:1208:2))"]
#[derive(Clone, Debug)]
struct fmovs_instructionVar48 {
    fsrs2: u8,
    fsrd: u8,
}
impl fmovs_instructionVar48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovs"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrs2 = token_28(tokens_current);
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1209:1, end:1209:2))"]
#[derive(Clone, Debug)]
struct fmovd_instructionVar49 {
    fdrs2: u8,
    fdrd: u8,
}
impl fmovd_instructionVar49 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovd"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1210:1, end:1210:2))"]
#[derive(Clone, Debug)]
struct fmovq_instructionVar50 {
    fqrs2: u8,
    fqrd: u8,
}
impl fmovq_instructionVar50 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovq"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrs2 = token_28(tokens_current);
        let fqrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fqrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1212:1, end:1212:2))"]
#[derive(Clone, Debug)]
struct fmuls_instructionVar51 {
    fsrs1: u8,
    fsrs2: u8,
    fsrd: u8,
}
impl fmuls_instructionVar51 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmuls"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs1),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        let fsrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs1, fsrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1213:1, end:1213:2))"]
#[derive(Clone, Debug)]
struct fmuld_instructionVar52 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fmuld_instructionVar52 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmuld"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1214:1, end:1214:2))"]
#[derive(Clone, Debug)]
struct fmulq_instructionVar53 {
    fqrs1: u8,
    fqrs2: u8,
    fqrd: u8,
}
impl fmulq_instructionVar53 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmulq"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrs1),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrs2 = token_28(tokens_current);
        let fqrd = token_23(tokens_current);
        let fqrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fqrs1, fqrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1216:1, end:1216:2))"]
#[derive(Clone, Debug)]
struct fnegs_instructionVar54 {
    fsrs2: u8,
    fsrd: u8,
}
impl fnegs_instructionVar54 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnegs"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1217:1, end:1217:2))"]
#[derive(Clone, Debug)]
struct fnegd_instructionVar55 {
    fdrs2: u8,
    fdrd: u8,
}
impl fnegd_instructionVar55 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnegd"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1218:1, end:1218:2))"]
#[derive(Clone, Debug)]
struct fnegq_instructionVar56 {
    fqrs2: u8,
    fqrd: u8,
}
impl fnegq_instructionVar56 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnegq"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrs2 = token_28(tokens_current);
        let fqrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fqrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1220:1, end:1220:2))"]
#[derive(Clone, Debug)]
struct fsubs_instructionVar57 {
    fsrs1: u8,
    fsrs2: u8,
    fsrd: u8,
}
impl fsubs_instructionVar57 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsubs"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs1),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        let fsrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs1, fsrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1221:1, end:1221:2))"]
#[derive(Clone, Debug)]
struct fsubd_instructionVar58 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fsubd_instructionVar58 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsubd"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1222:1, end:1222:2))"]
#[derive(Clone, Debug)]
struct fsubq_instructionVar59 {
    fqrs1: u8,
    fqrs2: u8,
    fqrd: u8,
}
impl fsubq_instructionVar59 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsubq"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrs1),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrd = token_23(tokens_current);
        let fqrs2 = token_28(tokens_current);
        let fqrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fqrs1, fqrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1224:1, end:1224:2))"]
#[derive(Clone, Debug)]
struct fxtos_instructionVar60 {
    fdrs2: u8,
    fsrd: u8,
}
impl fxtos_instructionVar60 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fxtos"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1225:1, end:1225:2))"]
#[derive(Clone, Debug)]
struct fxtod_instructionVar61 {
    fdrs2: u8,
    fdrd: u8,
}
impl fxtod_instructionVar61 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fxtod"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1226:1, end:1226:2))"]
#[derive(Clone, Debug)]
struct fxtoq_instructionVar62 {
    fdrs2: u8,
    fqrd: u8,
}
impl fxtoq_instructionVar62 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fxtoq"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1228:1, end:1228:2))"]
#[derive(Clone, Debug)]
struct fstoi_instructionVar63 {
    fsrs2: u8,
    fsrd: u8,
}
impl fstoi_instructionVar63 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fstoi"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrs2 = token_28(tokens_current);
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1229:1, end:1229:2))"]
#[derive(Clone, Debug)]
struct fdtoi_instructionVar64 {
    fdrs2: u8,
    fdrd: u8,
}
impl fdtoi_instructionVar64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdtoi"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1230:1, end:1230:2))"]
#[derive(Clone, Debug)]
struct fqtoi_instructionVar65 {
    fqrs2: u8,
    fqrd: u8,
}
impl fqtoi_instructionVar65 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fqtoi"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrd = token_23(tokens_current);
        let fqrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fqrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1232:1, end:1232:2))"]
#[derive(Clone, Debug)]
struct fstox_instructionVar66 {
    fsrs2: u8,
    fsrd: u8,
}
impl fstox_instructionVar66 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fstox"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1233:1, end:1233:2))"]
#[derive(Clone, Debug)]
struct fdtox_instructionVar67 {
    fdrs2: u8,
    fdrd: u8,
}
impl fdtox_instructionVar67 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdtox"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1234:1, end:1234:2))"]
#[derive(Clone, Debug)]
struct fqtox_instructionVar68 {
    fqrs2: u8,
    fqrd: u8,
}
impl fqtox_instructionVar68 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fqtox"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrs2 = token_28(tokens_current);
        let fqrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fqrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1236:1, end:1236:2))"]
#[derive(Clone, Debug)]
struct fstod_instructionVar69 {
    fsrs2: u8,
    fdrd: u8,
}
impl fstod_instructionVar69 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fstod"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1237:1, end:1237:2))"]
#[derive(Clone, Debug)]
struct fstoq_instructionVar70 {
    fsrs2: u8,
    fqrd: u8,
}
impl fstoq_instructionVar70 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fstoq"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1239:1, end:1239:2))"]
#[derive(Clone, Debug)]
struct fdtos_instructionVar71 {
    fdrs2: u8,
    fsrd: u8,
}
impl fdtos_instructionVar71 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdtos"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1240:1, end:1240:2))"]
#[derive(Clone, Debug)]
struct fdtoq_instructionVar72 {
    fdrs2: u8,
    fqrd: u8,
}
impl fdtoq_instructionVar72 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdtoq"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fqrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1242:1, end:1242:2))"]
#[derive(Clone, Debug)]
struct fqtos_instructionVar73 {
    fdrs2: u8,
    fsrd: u8,
}
impl fqtos_instructionVar73 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fqtos"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1243:1, end:1243:2))"]
#[derive(Clone, Debug)]
struct fqtod_instructionVar74 {
    fqrs2: u8,
    fdrd: u8,
}
impl fqtod_instructionVar74 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fqtod"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fqrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1245:1, end:1245:2))"]
#[derive(Clone, Debug)]
struct fsqrts_instructionVar75 {
    fsrs2: u8,
    fsrd: u8,
}
impl fsqrts_instructionVar75 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsqrts"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1246:1, end:1246:2))"]
#[derive(Clone, Debug)]
struct fsqrtd_instructionVar76 {
    fdrs2: u8,
    fdrd: u8,
}
impl fsqrtd_instructionVar76 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsqrtd"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1247:1, end:1247:2))"]
#[derive(Clone, Debug)]
struct fsqrtq_instructionVar77 {
    fqrs2: u8,
    fqrd: u8,
}
impl fsqrtq_instructionVar77 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsqrtq"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fqrd = token_23(tokens_current);
        let fqrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fqrs2, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:9:1, end:9:2))"]
#[derive(Clone, Debug)]
struct alignaddr_instructionVar78 {
    rd: u8,
    RS1: TableRS1,
    RS2: TableRS2,
}
impl alignaddr_instructionVar78 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("alignaddr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RS2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:15:1, end:15:2))"]
#[derive(Clone, Debug)]
struct alignaddrl_instructionVar79 {
    rd: u8,
    RS2: TableRS2,
    RS1: TableRS1,
}
impl alignaddrl_instructionVar79 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("alignaddrl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2, RS1, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:21:1, end:21:2))"]
#[derive(Clone, Debug)]
struct array16_instructionVar80 {
    rd: u8,
    RS1: TableRS1,
    RS2: TableRS2,
}
impl array16_instructionVar80 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("array16"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RS2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:27:1, end:27:2))"]
#[derive(Clone, Debug)]
struct array32_instructionVar81 {
    rd: u8,
    RS2: TableRS2,
    RS1: TableRS1,
}
impl array32_instructionVar81 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("array32"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2, RS1, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:33:1, end:33:2))"]
#[derive(Clone, Debug)]
struct array8_instructionVar82 {
    rd: u8,
    RS1: TableRS1,
    RS2: TableRS2,
}
impl array8_instructionVar82 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("array8"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RS2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:39:1, end:39:2))"]
#[derive(Clone, Debug)]
struct edge16cc_instructionVar83 {
    rd: u8,
    RS2: TableRS2,
    RS1: TableRS1,
}
impl edge16cc_instructionVar83 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("edge16cc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2, RS1, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:45:1, end:45:2))"]
#[derive(Clone, Debug)]
struct edge16lcc_instructionVar84 {
    rd: u8,
    RS1: TableRS1,
    RS2: TableRS2,
}
impl edge16lcc_instructionVar84 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("edge16lcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RS2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:51:1, end:51:2))"]
#[derive(Clone, Debug)]
struct edge32cc_instructionVar85 {
    rd: u8,
    RS2: TableRS2,
    RS1: TableRS1,
}
impl edge32cc_instructionVar85 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("edge32cc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2, RS1, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:57:1, end:57:2))"]
#[derive(Clone, Debug)]
struct edge32lcc_instructionVar86 {
    rd: u8,
    RS1: TableRS1,
    RS2: TableRS2,
}
impl edge32lcc_instructionVar86 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("edge32lcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RS2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:63:1, end:63:2))"]
#[derive(Clone, Debug)]
struct edge8cc_instructionVar87 {
    rd: u8,
    RS1: TableRS1,
    RS2: TableRS2,
}
impl edge8cc_instructionVar87 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("edge8cc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RS2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:69:1, end:69:2))"]
#[derive(Clone, Debug)]
struct edge8lcc_instructionVar88 {
    rd: u8,
    RS1: TableRS1,
    RS2: TableRS2,
}
impl edge8lcc_instructionVar88 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("edge8lcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RS2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:75:1, end:75:2))"]
#[derive(Clone, Debug)]
struct faligndata_instructionVar89 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl faligndata_instructionVar89 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("faligndata"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:81:1, end:81:2))"]
#[derive(Clone, Debug)]
struct fandd_instructionVar90 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fandd_instructionVar90 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fandd"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:87:1, end:87:2))"]
#[derive(Clone, Debug)]
struct fandnot1d_instructionVar91 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fandnot1d_instructionVar91 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fandnot1d"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:93:1, end:93:2))"]
#[derive(Clone, Debug)]
struct fandnot1s_instructionVar92 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fandnot1s_instructionVar92 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fandnot1s"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:99:1, end:99:2))"]
#[derive(Clone, Debug)]
struct fandnot2d_instructionVar93 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fandnot2d_instructionVar93 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fandnot2d"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:105:1, end:105:2))"]
#[derive(Clone, Debug)]
struct fandnot2s_instructionVar94 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fandnot2s_instructionVar94 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fandnot2s"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:111:1, end:111:2))"]
#[derive(Clone, Debug)]
struct fands_instructionVar95 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fands_instructionVar95 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fands"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:117:1, end:117:2))"]
#[derive(Clone, Debug)]
struct fexpand_instructionVar96 {
    fsrs2: u8,
    fdrd: u8,
}
impl fexpand_instructionVar96 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fexpand"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fsrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:123:1, end:123:2))"]
#[derive(Clone, Debug)]
struct fmul8sux16_instructionVar97 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fmul8sux16_instructionVar97 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmul8sux16"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:129:1, end:129:2))"]
#[derive(Clone, Debug)]
struct fmul8ulx16_instructionVar98 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fmul8ulx16_instructionVar98 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmul8ulx16"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:135:1, end:135:2))"]
#[derive(Clone, Debug)]
struct fmul8x16_instructionVar99 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fmul8x16_instructionVar99 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmul8x16"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:141:1, end:141:2))"]
#[derive(Clone, Debug)]
struct fmul8x16al_instructionVar100 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fmul8x16al_instructionVar100 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmul8x16al"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:147:1, end:147:2))"]
#[derive(Clone, Debug)]
struct fmul8x16au_instructionVar101 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fmul8x16au_instructionVar101 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmul8x16au"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:153:1, end:153:2))"]
#[derive(Clone, Debug)]
struct fmuld8sux16_instructionVar102 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fmuld8sux16_instructionVar102 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmuld8sux16"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:159:1, end:159:2))"]
#[derive(Clone, Debug)]
struct fmuld8ulx16_instructionVar103 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fmuld8ulx16_instructionVar103 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmuld8ulx16"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:165:1, end:165:2))"]
#[derive(Clone, Debug)]
struct fnandd_instructionVar104 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fnandd_instructionVar104 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnandd"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:171:1, end:171:2))"]
#[derive(Clone, Debug)]
struct fnands_instructionVar105 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fnands_instructionVar105 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnands"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:177:1, end:177:2))"]
#[derive(Clone, Debug)]
struct fnord_instructionVar106 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fnord_instructionVar106 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnord"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:183:1, end:183:2))"]
#[derive(Clone, Debug)]
struct fnors_instructionVar107 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fnors_instructionVar107 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnors"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:189:1, end:189:2))"]
#[derive(Clone, Debug)]
struct fnot1d_instructionVar108 {
    fdrs1: u8,
    fdrd: u8,
}
impl fnot1d_instructionVar108 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnot1d"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:195:1, end:195:2))"]
#[derive(Clone, Debug)]
struct fnot1s_instructionVar109 {
    fdrs1: u8,
    fdrd: u8,
}
impl fnot1s_instructionVar109 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnot1s"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:201:1, end:201:2))"]
#[derive(Clone, Debug)]
struct fnot2d_instructionVar110 {
    fdrs2: u8,
    fdrd: u8,
}
impl fnot2d_instructionVar110 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnot2d"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:207:1, end:207:2))"]
#[derive(Clone, Debug)]
struct fnot2s_instructionVar111 {
    fdrs2: u8,
    fdrd: u8,
}
impl fnot2s_instructionVar111 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnot2s"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:213:1, end:213:2))"]
#[derive(Clone, Debug)]
struct foned_instructionVar112 {
    fdrd: u8,
}
impl foned_instructionVar112 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("foned"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_6_display(self.fdrd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:219:1, end:219:2))"]
#[derive(Clone, Debug)]
struct fones_instructionVar113 {
    fsrd: u8,
}
impl fones_instructionVar113 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fones"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_5_display(self.fsrd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:225:1, end:225:2))"]
#[derive(Clone, Debug)]
struct ford_instructionVar114 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl ford_instructionVar114 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ford"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:231:1, end:231:2))"]
#[derive(Clone, Debug)]
struct fornot1d_instructionVar115 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fornot1d_instructionVar115 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fornot1d"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:237:1, end:237:2))"]
#[derive(Clone, Debug)]
struct fornot1s_instructionVar116 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fornot1s_instructionVar116 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fornot1s"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:243:1, end:243:2))"]
#[derive(Clone, Debug)]
struct fornot2d_instructionVar117 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fornot2d_instructionVar117 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fornot2d"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:249:1, end:249:2))"]
#[derive(Clone, Debug)]
struct fornot2s_instructionVar118 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fornot2s_instructionVar118 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fornot2s"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:255:1, end:255:2))"]
#[derive(Clone, Debug)]
struct fors_instructionVar119 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fors_instructionVar119 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fors"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:261:1, end:261:2))"]
#[derive(Clone, Debug)]
struct fpack16_instructionVar120 {
    fdrs2: u8,
    fsrd: u8,
}
impl fpack16_instructionVar120 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpack16"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:267:1, end:267:2))"]
#[derive(Clone, Debug)]
struct fpack32_instructionVar121 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fpack32_instructionVar121 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpack32"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:273:1, end:273:2))"]
#[derive(Clone, Debug)]
struct fpackfix_instructionVar122 {
    fdrs2: u8,
    fsrd: u8,
}
impl fpackfix_instructionVar122 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpackfix"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:279:1, end:279:2))"]
#[derive(Clone, Debug)]
struct fpadd16_instructionVar123 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fpadd16_instructionVar123 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpadd16"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:285:1, end:285:2))"]
#[derive(Clone, Debug)]
struct fpadd16s_instructionVar124 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fpadd16s_instructionVar124 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpadd16s"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:291:1, end:291:2))"]
#[derive(Clone, Debug)]
struct fpadd32_instructionVar125 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fpadd32_instructionVar125 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpadd32"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:297:1, end:297:2))"]
#[derive(Clone, Debug)]
struct fpadd32s_instructionVar126 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fpadd32s_instructionVar126 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpadd32s"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:303:1, end:303:2))"]
#[derive(Clone, Debug)]
struct fpcmpeq16_instructionVar127 {
    fdrs1: u8,
    fdrs2: u8,
    rd: u8,
}
impl fpcmpeq16_instructionVar127 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpcmpeq16"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.rd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let rd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:309:1, end:309:2))"]
#[derive(Clone, Debug)]
struct fpcmpeq32_instructionVar128 {
    fdrs1: u8,
    fdrs2: u8,
    rd: u8,
}
impl fpcmpeq32_instructionVar128 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpcmpeq32"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.rd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:315:1, end:315:2))"]
#[derive(Clone, Debug)]
struct fpcmpgt16_instructionVar129 {
    fdrs1: u8,
    fdrs2: u8,
    rd: u8,
}
impl fpcmpgt16_instructionVar129 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpcmpgt16"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.rd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:321:1, end:321:2))"]
#[derive(Clone, Debug)]
struct fpcmpgt32_instructionVar130 {
    fdrs1: u8,
    fdrs2: u8,
    rd: u8,
}
impl fpcmpgt32_instructionVar130 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpcmpgt32"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.rd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:327:1, end:327:2))"]
#[derive(Clone, Debug)]
struct fpcmple16_instructionVar131 {
    fdrs1: u8,
    fdrs2: u8,
    rd: u8,
}
impl fpcmple16_instructionVar131 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpcmple16"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.rd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:333:1, end:333:2))"]
#[derive(Clone, Debug)]
struct fpcmple32_instructionVar132 {
    fdrs1: u8,
    fdrs2: u8,
    rd: u8,
}
impl fpcmple32_instructionVar132 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpcmple32"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.rd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:339:1, end:339:2))"]
#[derive(Clone, Debug)]
struct fpcmpne16_instructionVar133 {
    fdrs1: u8,
    fdrs2: u8,
    rd: u8,
}
impl fpcmpne16_instructionVar133 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpcmpne16"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.rd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:345:1, end:345:2))"]
#[derive(Clone, Debug)]
struct fpcmpne32_instructionVar134 {
    fdrs1: u8,
    fdrs2: u8,
    rd: u8,
}
impl fpcmpne32_instructionVar134 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpcmpne32"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.rd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:351:1, end:351:2))"]
#[derive(Clone, Debug)]
struct fpmerge_instructionVar135 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fpmerge_instructionVar135 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpmerge"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:357:1, end:357:2))"]
#[derive(Clone, Debug)]
struct fpsub16_instructionVar136 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fpsub16_instructionVar136 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpsub16"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:363:1, end:363:2))"]
#[derive(Clone, Debug)]
struct fpsub16s_instructionVar137 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fpsub16s_instructionVar137 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpsub16s"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:369:1, end:369:2))"]
#[derive(Clone, Debug)]
struct fpsub32_instructionVar138 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fpsub32_instructionVar138 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpsub32"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:375:1, end:375:2))"]
#[derive(Clone, Debug)]
struct fpsub32s_instructionVar139 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fpsub32s_instructionVar139 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fpsub32s"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:381:1, end:381:2))"]
#[derive(Clone, Debug)]
struct fsrc1d_instructionVar140 {
    fdrs1: u8,
    fdrd: u8,
}
impl fsrc1d_instructionVar140 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsrc1d"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:387:1, end:387:2))"]
#[derive(Clone, Debug)]
struct fsrc1s_instructionVar141 {
    fdrs1: u8,
    fdrd: u8,
}
impl fsrc1s_instructionVar141 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsrc1s"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:393:1, end:393:2))"]
#[derive(Clone, Debug)]
struct fsrc2d_instructionVar142 {
    fdrs2: u8,
    fdrd: u8,
}
impl fsrc2d_instructionVar142 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsrc2d"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:399:1, end:399:2))"]
#[derive(Clone, Debug)]
struct fsrc2s_instructionVar143 {
    fdrs2: u8,
    fdrd: u8,
}
impl fsrc2s_instructionVar143 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsrc2s"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:405:1, end:405:2))"]
#[derive(Clone, Debug)]
struct fxnord_instructionVar144 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fxnord_instructionVar144 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fxnord"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:411:1, end:411:2))"]
#[derive(Clone, Debug)]
struct fxnors_instructionVar145 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fxnors_instructionVar145 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fxnors"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrs1 = token_25(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:417:1, end:417:2))"]
#[derive(Clone, Debug)]
struct fxord_instructionVar146 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fxord_instructionVar146 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fxord"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:423:1, end:423:2))"]
#[derive(Clone, Debug)]
struct fxors_instructionVar147 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl fxors_instructionVar147 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fxors"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs1 = token_25(tokens_current);
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:429:1, end:429:2))"]
#[derive(Clone, Debug)]
struct fzerod_instructionVar148 {
    fdrd: u8,
}
impl fzerod_instructionVar148 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fzerod"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_6_display(self.fdrd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:435:1, end:435:2))"]
#[derive(Clone, Debug)]
struct fzeros_instructionVar149 {
    fsrd: u8,
}
impl fzeros_instructionVar149 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fzeros"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_5_display(self.fsrd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcVIS.sinc, start:441:1, end:441:2))"]
#[derive(Clone, Debug)]
struct pdist_instructionVar150 {
    fdrs1: u8,
    fdrs2: u8,
    fdrd: u8,
}
impl pdist_instructionVar150 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pdist"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrs1),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fdrs2 = token_28(tokens_current);
        let fdrd = token_23(tokens_current);
        let fdrs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fdrs1, fdrs2, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:929:1, end:929:2))"]
#[derive(Clone, Debug)]
struct sll_instructionVar151 {
    RD: TableRD,
    reg_or_shcnt: Tablereg_or_shcnt,
    RS1: TableRS1,
}
impl sll_instructionVar151 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sll"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.reg_or_shcnt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reg_or_shcnt = if let Some((len, table)) =
            Tablereg_or_shcnt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD,
                reg_or_shcnt,
                RS1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:930:1, end:930:2))"]
#[derive(Clone, Debug)]
struct srl_instructionVar152 {
    RS1: TableRS1,
    reg_or_shcnt: Tablereg_or_shcnt,
    RD: TableRD,
}
impl srl_instructionVar152 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.reg_or_shcnt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reg_or_shcnt = if let Some((len, table)) =
            Tablereg_or_shcnt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS1,
                reg_or_shcnt,
                RD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:932:1, end:932:2))"]
#[derive(Clone, Debug)]
struct sllx_instructionVar153 {
    RS1: TableRS1,
    RD: TableRD,
    reg_or_shcnt: Tablereg_or_shcnt,
}
impl sllx_instructionVar153 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sllx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.reg_or_shcnt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reg_or_shcnt = if let Some((len, table)) =
            Tablereg_or_shcnt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS1,
                RD,
                reg_or_shcnt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:933:1, end:933:2))"]
#[derive(Clone, Debug)]
struct srlx_instructionVar154 {
    RD: TableRD,
    RS1: TableRS1,
    reg_or_shcnt: Tablereg_or_shcnt,
}
impl srlx_instructionVar154 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srlx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.reg_or_shcnt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reg_or_shcnt = if let Some((len, table)) =
            Tablereg_or_shcnt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD,
                RS1,
                reg_or_shcnt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:935:1, end:935:2))"]
#[derive(Clone, Debug)]
struct sra_instructionVar155 {
    RD: TableRD,
    RS1: TableRS1,
    reg_or_shcnt: Tablereg_or_shcnt,
}
impl sra_instructionVar155 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sra"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.reg_or_shcnt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reg_or_shcnt = if let Some((len, table)) =
            Tablereg_or_shcnt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD,
                RS1,
                reg_or_shcnt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:936:1, end:936:2))"]
#[derive(Clone, Debug)]
struct srax_instructionVar156 {
    reg_or_shcnt: Tablereg_or_shcnt,
    RD: TableRD,
    RS1: TableRS1,
}
impl srax_instructionVar156 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srax"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.reg_or_shcnt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reg_or_shcnt = if let Some((len, table)) =
            Tablereg_or_shcnt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                reg_or_shcnt,
                RD,
                RS1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1393:1, end:1393:2))"]
#[derive(Clone, Debug)]
struct fmovrs_instructionVar157 {
    fsrs2: u8,
    fsrd: u8,
    RS1: TableRS1,
    fmovrcc: Tablefmovrcc,
}
impl fmovrs_instructionVar157 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovrs"));
        self.fmovrcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrs2),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.fsrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fmovrcc = if let Some((len, table)) =
            Tablefmovrcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsrs2 = token_28(tokens_current);
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS1,
                fmovrcc,
                fsrs2,
                fsrd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1395:1, end:1395:2))"]
#[derive(Clone, Debug)]
struct fmovrd_instructionVar158 {
    fdrs2: u8,
    fdrd: u8,
    RS1: TableRS1,
    fmovrcc: Tablefmovrcc,
}
impl fmovrd_instructionVar158 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovrd"));
        self.fmovrcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrs2),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fdrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fmovrcc = if let Some((len, table)) =
            Tablefmovrcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdrd = token_23(tokens_current);
        let fdrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS1,
                fmovrcc,
                fdrs2,
                fdrd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1397:1, end:1397:2))"]
#[derive(Clone, Debug)]
struct fmovrq_instructionVar159 {
    fqrs2: u8,
    fqrd: u8,
    RS1: TableRS1,
    fmovrcc: Tablefmovrcc,
}
impl fmovrq_instructionVar159 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovrq"));
        self.fmovrcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrs2),
            <DisplayElement>::Literal(","),
            meaning_7_display(self.fqrd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fmovrcc = if let Some((len, table)) =
            Tablefmovrcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fqrd = token_23(tokens_current);
        let fqrs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS1,
                fmovrcc,
                fqrs2,
                fqrd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:951:1, end:951:2))"]
#[derive(Clone, Debug)]
struct rd_instructionVar160 {
    rsASR: TablersASR,
    RD: TableRD,
}
impl rd_instructionVar160 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rsASR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rsASR = if let Some((len, table)) =
            TablersASR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rsASR, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:969:1, end:969:2))"]
#[derive(Clone, Debug)]
struct wr_instructionVar161 {
    RS1: TableRS1,
    wrCCR: TablewrCCR,
    regorimm: Tableregorimm,
}
impl wr_instructionVar161 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.wrCCR
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let wrCCR = if let Some((len, table)) =
            TablewrCCR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS1,
                wrCCR,
                regorimm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:970:1, end:970:2))"]
#[derive(Clone, Debug)]
struct wr_instructionVar162 {
    regorimm: Tableregorimm,
    RS1: TableRS1,
    wrASI: TablewrASI,
}
impl wr_instructionVar162 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.wrASI
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let wrASI = if let Some((len, table)) =
            TablewrASI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                regorimm,
                RS1,
                wrASI,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:971:1, end:971:2))"]
#[derive(Clone, Debug)]
struct wr_instructionVar163 {
    wrFPRS: TablewrFPRS,
    regorimm: Tableregorimm,
    RS1: TableRS1,
}
impl wr_instructionVar163 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.wrFPRS
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let wrFPRS = if let Some((len, table)) =
            TablewrFPRS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                wrFPRS,
                regorimm,
                RS1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:972:1, end:972:2))"]
#[derive(Clone, Debug)]
struct wr_instructionVar164 {
    RS1: TableRS1,
    regorimm: Tableregorimm,
    wrY: TablewrY,
}
impl wr_instructionVar164 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.wrY
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let wrY = if let Some((len, table)) =
            TablewrY::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, regorimm, wrY }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:985:1, end:985:2))"]
#[derive(Clone, Debug)]
struct restore_instructionVar165 {}
impl restore_instructionVar165 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("restore"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:992:1, end:992:2))"]
#[derive(Clone, Debug)]
struct jmpl_instructionVar166 {
    RD: TableRD,
    retea: Tableretea,
}
impl jmpl_instructionVar166 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jmpl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.retea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let retea = if let Some((len, table)) =
            Tableretea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, retea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:994:1, end:994:2))"]
#[derive(Clone, Debug)]
struct jmpl_instructionVar167 {
    retea: Tableretea,
}
impl jmpl_instructionVar167 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jmpl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.retea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let retea = if let Some((len, table)) =
            Tableretea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { retea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1092:1, end:1092:2))"]
#[derive(Clone, Debug)]
struct wrpr_instructionVar168 {
    regorimm: Tableregorimm,
    tpc: Tabletpc,
    RS1: TableRS1,
}
impl wrpr_instructionVar168 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.tpc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let tpc = if let Some((len, table)) =
            Tabletpc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, tpc, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1093:1, end:1093:2))"]
#[derive(Clone, Debug)]
struct wrpr_instructionVar169 {
    tnpc: Tabletnpc,
    RS1: TableRS1,
    regorimm: Tableregorimm,
}
impl wrpr_instructionVar169 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.tnpc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let tnpc = if let Some((len, table)) =
            Tabletnpc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                tnpc,
                RS1,
                regorimm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1094:1, end:1094:2))"]
#[derive(Clone, Debug)]
struct wrpr_instructionVar170 {
    regorimm: Tableregorimm,
    RS1: TableRS1,
    tstate: Tabletstate,
}
impl wrpr_instructionVar170 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.tstate
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let tstate = if let Some((len, table)) =
            Tabletstate::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                regorimm,
                RS1,
                tstate,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1095:1, end:1095:2))"]
#[derive(Clone, Debug)]
struct wrpr_instructionVar171 {
    RS1: TableRS1,
    tt: Tablett,
    regorimm: Tableregorimm,
}
impl wrpr_instructionVar171 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.tt
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let tt = if let Some((len, table)) =
            Tablett::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, tt, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1119:1, end:1119:2))"]
#[derive(Clone, Debug)]
struct wrhpr_instructionVar172 {
    regorimm: Tableregorimm,
    hpstate: Tablehpstate,
    RS1: TableRS1,
}
impl wrhpr_instructionVar172 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.hpstate
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let hpstate = if let Some((len, table)) =
            Tablehpstate::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                regorimm,
                hpstate,
                RS1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1120:1, end:1120:2))"]
#[derive(Clone, Debug)]
struct wrhpr_instructionVar173 {
    regorimm: Tableregorimm,
    RS1: TableRS1,
    htstate: Tablehtstate,
}
impl wrhpr_instructionVar173 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.htstate
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let htstate = if let Some((len, table)) =
            Tablehtstate::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                regorimm,
                RS1,
                htstate,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1121:1, end:1121:2))"]
#[derive(Clone, Debug)]
struct wrhpr_instructionVar174 {
    regorimm: Tableregorimm,
    hintp: Tablehintp,
    RS1: TableRS1,
}
impl wrhpr_instructionVar174 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.hintp
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let hintp = if let Some((len, table)) =
            Tablehintp::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                regorimm,
                hintp,
                RS1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1122:1, end:1122:2))"]
#[derive(Clone, Debug)]
struct wrhpr_instructionVar175 {
    htba: Tablehtba,
    regorimm: Tableregorimm,
    RS1: TableRS1,
}
impl wrhpr_instructionVar175 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.htba
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let htba = if let Some((len, table)) =
            Tablehtba::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                htba,
                regorimm,
                RS1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1123:1, end:1123:2))"]
#[derive(Clone, Debug)]
struct wrhpr_instructionVar176 {
    hsys_tick_cmpr: Tablehsys_tick_cmpr,
    RS1: TableRS1,
    regorimm: Tableregorimm,
}
impl wrhpr_instructionVar176 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.hsys_tick_cmpr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let hsys_tick_cmpr = if let Some((len, table)) =
            Tablehsys_tick_cmpr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                hsys_tick_cmpr,
                RS1,
                regorimm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1124:1, end:1124:2))"]
#[derive(Clone, Debug)]
struct wrhpr_instructionVar177 {
    resv30: Tableresv30,
    RS1: TableRS1,
    regorimm: Tableregorimm,
}
impl wrhpr_instructionVar177 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrhpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.resv30
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let resv30 = if let Some((len, table)) =
            Tableresv30::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                resv30,
                RS1,
                regorimm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1128:1, end:1128:2))"]
#[derive(Clone, Debug)]
struct done_instructionVar178 {
    tnpc: Tabletnpc,
}
impl done_instructionVar178 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("done"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let tnpc = if let Some((len, table)) =
            Tabletnpc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { tnpc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1129:1, end:1129:2))"]
#[derive(Clone, Debug)]
struct retry_instructionVar179 {
    tpc: Tabletpc,
}
impl retry_instructionVar179 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("retry"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let tpc = if let Some((len, table)) =
            Tabletpc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { tpc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1132:1, end:1132:2))"]
#[derive(Clone, Debug)]
struct flushw_instructionVar180 {}
impl flushw_instructionVar180 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flushw"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1144:1, end:1144:2))"]
#[derive(Clone, Debug)]
struct restored_instructionVar181 {}
impl restored_instructionVar181 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("restored"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1145:1, end:1145:2))"]
#[derive(Clone, Debug)]
struct saved_instructionVar182 {}
impl saved_instructionVar182 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("saved"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1252:1, end:1252:2))"]
#[derive(Clone, Debug)]
struct ld_instructionVar183 {
    ea: Tableea,
}
impl ld_instructionVar183 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ld"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",%fsr")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1253:1, end:1253:2))"]
#[derive(Clone, Debug)]
struct ldx_instructionVar184 {
    ea: Tableea,
}
impl ldx_instructionVar184 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",%fsr")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1262:1, end:1262:2))"]
#[derive(Clone, Debug)]
struct st_instructionVar185 {
    ea: Tableea,
}
impl st_instructionVar185 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("st"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("%fsr,"),
        ];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1263:1, end:1263:2))"]
#[derive(Clone, Debug)]
struct stx_instructionVar186 {
    ea: Tableea,
}
impl stx_instructionVar186 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stx"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("%fsr,"),
        ];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1379:1, end:1379:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar187 {
    fccn_4: u8,
    RD: TableRD,
    regorimm11: Tableregorimm11,
    fmfcc: Tablefmfcc,
}
impl mov_instructionVar187 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.fmfcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal(" %"),
            meaning_1_display(self.fccn_4),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.regorimm11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fmfcc = if let Some((len, table)) =
            Tablefmfcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm11 = if let Some((len, table)) =
            Tableregorimm11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD,
                regorimm11,
                fmfcc,
                fccn_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:484:1, end:484:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar188 {
    RS1: TableRS1,
    RD: TableRD,
    regorimm: Tableregorimm,
}
impl add_instructionVar188 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RD, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:486:1, end:486:2))"]
#[derive(Clone, Debug)]
struct addcc_instructionVar189 {
    RD: TableRD,
    regorimm: Tableregorimm,
    RS1: TableRS1,
}
impl addcc_instructionVar189 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, regorimm, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:493:1, end:493:2))"]
#[derive(Clone, Debug)]
struct addc_instructionVar190 {
    regorimm: Tableregorimm,
    RD: TableRD,
    RS1: TableRS1,
}
impl addc_instructionVar190 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RD, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:495:1, end:495:2))"]
#[derive(Clone, Debug)]
struct addccc_instructionVar191 {
    RS1: TableRS1,
    regorimm: Tableregorimm,
    RD: TableRD,
}
impl addccc_instructionVar191 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addccc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, regorimm, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:503:1, end:503:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar192 {
    RD: TableRD,
    regorimm: Tableregorimm,
    RS1: TableRS1,
}
impl and_instructionVar192 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, regorimm, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:505:1, end:505:2))"]
#[derive(Clone, Debug)]
struct andcc_instructionVar193 {
    RD: TableRD,
    RS1: TableRS1,
    regorimm: Tableregorimm,
}
impl andcc_instructionVar193 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RS1, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:511:1, end:511:2))"]
#[derive(Clone, Debug)]
struct andn_instructionVar194 {
    RS1: TableRS1,
    RD: TableRD,
    regorimm: Tableregorimm,
}
impl andn_instructionVar194 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andn"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RD, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:513:1, end:513:2))"]
#[derive(Clone, Debug)]
struct andncc_instructionVar195 {
    regorimm: Tableregorimm,
    RD: TableRD,
    RS1: TableRS1,
}
impl andncc_instructionVar195 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andncc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RD, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:520:1, end:520:2))"]
#[derive(Clone, Debug)]
struct or_instructionVar196 {
    regorimm: Tableregorimm,
    RD: TableRD,
    RS1: TableRS1,
}
impl or_instructionVar196 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RD, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:522:1, end:522:2))"]
#[derive(Clone, Debug)]
struct orcc_instructionVar197 {
    regorimm: Tableregorimm,
    RD: TableRD,
    RS1: TableRS1,
}
impl orcc_instructionVar197 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RD, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:528:1, end:528:2))"]
#[derive(Clone, Debug)]
struct orn_instructionVar198 {
    RS1: TableRS1,
    regorimm: Tableregorimm,
    RD: TableRD,
}
impl orn_instructionVar198 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orn"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, regorimm, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:530:1, end:530:2))"]
#[derive(Clone, Debug)]
struct orncc_instructionVar199 {
    RD: TableRD,
    RS1: TableRS1,
    regorimm: Tableregorimm,
}
impl orncc_instructionVar199 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orncc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RS1, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:536:1, end:536:2))"]
#[derive(Clone, Debug)]
struct xor_instructionVar200 {
    RS1: TableRS1,
    regorimm: Tableregorimm,
    RD: TableRD,
}
impl xor_instructionVar200 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xor"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, regorimm, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:538:1, end:538:2))"]
#[derive(Clone, Debug)]
struct xorcc_instructionVar201 {
    RS1: TableRS1,
    regorimm: Tableregorimm,
    RD: TableRD,
}
impl xorcc_instructionVar201 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xorcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, regorimm, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:545:1, end:545:2))"]
#[derive(Clone, Debug)]
struct xnor_instructionVar202 {
    regorimm: Tableregorimm,
    RS1: TableRS1,
    RD: TableRD,
}
impl xnor_instructionVar202 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xnor"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RS1, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:547:1, end:547:2))"]
#[derive(Clone, Debug)]
struct xnorcc_instructionVar203 {
    RD: TableRD,
    regorimm: Tableregorimm,
    RS1: TableRS1,
}
impl xnorcc_instructionVar203 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xnorcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, regorimm, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:555:1, end:555:2))"]
#[derive(Clone, Debug)]
struct ldsb_instructionVar204 {
    RD: TableRD,
    ea: Tableea,
}
impl ldsb_instructionVar204 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldsb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:556:1, end:556:2))"]
#[derive(Clone, Debug)]
struct ldsh_instructionVar205 {
    ea: Tableea,
    RD: TableRD,
}
impl ldsh_instructionVar205 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldsh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:557:1, end:557:2))"]
#[derive(Clone, Debug)]
struct ldsw_instructionVar206 {
    ea: Tableea,
    RD: TableRD,
}
impl ldsw_instructionVar206 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldsw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:558:1, end:558:2))"]
#[derive(Clone, Debug)]
struct ldub_instructionVar207 {
    RD: TableRD,
    ea: Tableea,
}
impl ldub_instructionVar207 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:559:1, end:559:2))"]
#[derive(Clone, Debug)]
struct lduh_instructionVar208 {
    RD: TableRD,
    ea: Tableea,
}
impl lduh_instructionVar208 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lduh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:560:1, end:560:2))"]
#[derive(Clone, Debug)]
struct lduw_instructionVar209 {
    RD: TableRD,
    ea: Tableea,
}
impl lduw_instructionVar209 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lduw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:561:1, end:561:2))"]
#[derive(Clone, Debug)]
struct ldx_instructionVar210 {
    RD: TableRD,
    ea: Tableea,
}
impl ldx_instructionVar210 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:564:1, end:564:2))"]
#[derive(Clone, Debug)]
struct ldd_instructionVar211 {
    ea: Tableea,
    RD: TableRD,
}
impl ldd_instructionVar211 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:570:1, end:570:2))"]
#[derive(Clone, Debug)]
struct ldsba_instructionVar212 {
    ea_alt: Tableea_alt,
    RD: TableRD,
}
impl ldsba_instructionVar212 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldsba"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:571:1, end:571:2))"]
#[derive(Clone, Debug)]
struct ldsha_instructionVar213 {
    ea_alt: Tableea_alt,
    RD: TableRD,
}
impl ldsha_instructionVar213 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldsha"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:572:1, end:572:2))"]
#[derive(Clone, Debug)]
struct ldswa_instructionVar214 {
    RD: TableRD,
    ea_alt: Tableea_alt,
}
impl ldswa_instructionVar214 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldswa"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea_alt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:573:1, end:573:2))"]
#[derive(Clone, Debug)]
struct lduba_instructionVar215 {
    ea_alt: Tableea_alt,
    RD: TableRD,
}
impl lduba_instructionVar215 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lduba"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:574:1, end:574:2))"]
#[derive(Clone, Debug)]
struct lduha_instructionVar216 {
    ea_alt: Tableea_alt,
    RD: TableRD,
}
impl lduha_instructionVar216 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lduha"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:575:1, end:575:2))"]
#[derive(Clone, Debug)]
struct lduwa_instructionVar217 {
    RD: TableRD,
    ea_alt: Tableea_alt,
}
impl lduwa_instructionVar217 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lduwa"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea_alt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:577:1, end:577:2))"]
#[derive(Clone, Debug)]
struct ldxa_instructionVar218 {
    RD: TableRD,
    ea_alt: Tableea_alt,
}
impl ldxa_instructionVar218 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldxa"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea_alt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:578:1, end:578:2))"]
#[derive(Clone, Debug)]
struct ldda_instructionVar219 {
    RD: TableRD,
    ea_alt: Tableea_alt,
}
impl ldda_instructionVar219 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldda"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea_alt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:581:1, end:581:2))"]
#[derive(Clone, Debug)]
struct stb_instructionVar220 {
    RD: TableRD,
    ea: Tableea,
}
impl stb_instructionVar220 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:582:1, end:582:2))"]
#[derive(Clone, Debug)]
struct sth_instructionVar221 {
    ea: Tableea,
    RD: TableRD,
}
impl sth_instructionVar221 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sth"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:583:1, end:583:2))"]
#[derive(Clone, Debug)]
struct stw_instructionVar222 {
    RD: TableRD,
    ea: Tableea,
}
impl stw_instructionVar222 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:586:1, end:586:2))"]
#[derive(Clone, Debug)]
struct stx_instructionVar223 {
    RD: TableRD,
    ea: Tableea,
}
impl stx_instructionVar223 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:587:1, end:587:2))"]
#[derive(Clone, Debug)]
struct std_instructionVar224 {
    ea: Tableea,
    RD: TableRD,
}
impl std_instructionVar224 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("std"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:597:1, end:597:2))"]
#[derive(Clone, Debug)]
struct stba_instructionVar225 {
    RD: TableRD,
    ea_alt: Tableea_alt,
}
impl stba_instructionVar225 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stba"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea_alt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:598:1, end:598:2))"]
#[derive(Clone, Debug)]
struct stha_instructionVar226 {
    ea_alt: Tableea_alt,
    RD: TableRD,
}
impl stha_instructionVar226 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stha"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:599:1, end:599:2))"]
#[derive(Clone, Debug)]
struct stwa_instructionVar227 {
    ea_alt: Tableea_alt,
    RD: TableRD,
}
impl stwa_instructionVar227 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stwa"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:600:1, end:600:2))"]
#[derive(Clone, Debug)]
struct stxa_instructionVar228 {
    RD: TableRD,
    ea_alt: Tableea_alt,
}
impl stxa_instructionVar228 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stxa"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea_alt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:601:1, end:601:2))"]
#[derive(Clone, Debug)]
struct stda_instructionVar229 {
    RD: TableRD,
    ea_alt: Tableea_alt,
}
impl stda_instructionVar229 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stda"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea_alt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:604:1, end:604:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar230 {
    RS1: TableRS1,
    RD: TableRD,
    regorimm: Tableregorimm,
}
impl sub_instructionVar230 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RD, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:609:1, end:609:2))"]
#[derive(Clone, Debug)]
struct subcc_instructionVar231 {
    RD: TableRD,
    RS1: TableRS1,
    regorimm: Tableregorimm,
}
impl subcc_instructionVar231 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RS1, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:616:1, end:616:2))"]
#[derive(Clone, Debug)]
struct subc_instructionVar232 {
    regorimm: Tableregorimm,
    RS1: TableRS1,
    RD: TableRD,
}
impl subc_instructionVar232 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RS1, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:621:1, end:621:2))"]
#[derive(Clone, Debug)]
struct subccc_instructionVar233 {
    regorimm: Tableregorimm,
    RD: TableRD,
    RS1: TableRS1,
}
impl subccc_instructionVar233 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subccc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RD, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:656:1, end:656:2))"]
#[derive(Clone, Debug)]
struct movr_instructionVar234 {
    RD: TableRD,
    RCOND: TableRCOND,
    regorimm10: Tableregorimm10,
    RS1: TableRS1,
}
impl movr_instructionVar234 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movr"));
        self.RCOND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm10
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RCOND = if let Some((len, table)) =
            TableRCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm10 = if let Some((len, table)) =
            Tableregorimm10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RD,
                RCOND,
                regorimm10,
                RS1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:758:1, end:758:2))"]
#[derive(Clone, Debug)]
struct brz_instructionVar235 {
    d16off: Tabled16off,
    predict: Tablepredict,
    RS1: TableRS1,
}
impl brz_instructionVar235 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("brz"));
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.d16off
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d16off = if let Some((len, table)) =
            Tabled16off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                d16off,
                predict,
                RS1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:759:1, end:759:2))"]
#[derive(Clone, Debug)]
struct brlez_instructionVar236 {
    RS1: TableRS1,
    predict: Tablepredict,
    d16off: Tabled16off,
}
impl brlez_instructionVar236 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("brlez"));
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.d16off
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d16off = if let Some((len, table)) =
            Tabled16off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS1,
                predict,
                d16off,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:760:1, end:760:2))"]
#[derive(Clone, Debug)]
struct brlz_instructionVar237 {
    RS1: TableRS1,
    d16off: Tabled16off,
    predict: Tablepredict,
}
impl brlz_instructionVar237 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("brlz"));
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.d16off
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d16off = if let Some((len, table)) =
            Tabled16off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS1,
                d16off,
                predict,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:761:1, end:761:2))"]
#[derive(Clone, Debug)]
struct brnz_instructionVar238 {
    predict: Tablepredict,
    d16off: Tabled16off,
    RS1: TableRS1,
}
impl brnz_instructionVar238 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("brnz"));
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.d16off
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d16off = if let Some((len, table)) =
            Tabled16off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                predict,
                d16off,
                RS1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:762:1, end:762:2))"]
#[derive(Clone, Debug)]
struct brgz_instructionVar239 {
    d16off: Tabled16off,
    RS1: TableRS1,
    predict: Tablepredict,
}
impl brgz_instructionVar239 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("brgz"));
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.d16off
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d16off = if let Some((len, table)) =
            Tabled16off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                d16off,
                RS1,
                predict,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:763:1, end:763:2))"]
#[derive(Clone, Debug)]
struct brgez_instructionVar240 {
    predict: Tablepredict,
    RS1: TableRS1,
    d16off: Tabled16off,
}
impl brgez_instructionVar240 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("brgez"));
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.d16off
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d16off = if let Some((len, table)) =
            Tabled16off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                predict,
                RS1,
                d16off,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:765:1, end:765:2))"]
#[derive(Clone, Debug)]
struct brz_instructionVar241 {
    d16off: Tabled16off,
    RS1: TableRS1,
    predict: Tablepredict,
}
impl brz_instructionVar241 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("brz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a")];
        display.extend_from_slice(&extend);
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.d16off
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d16off = if let Some((len, table)) =
            Tabled16off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                d16off,
                RS1,
                predict,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:766:1, end:766:2))"]
#[derive(Clone, Debug)]
struct brlez_instructionVar242 {
    RS1: TableRS1,
    predict: Tablepredict,
    d16off: Tabled16off,
}
impl brlez_instructionVar242 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("brlez"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a")];
        display.extend_from_slice(&extend);
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.d16off
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d16off = if let Some((len, table)) =
            Tabled16off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS1,
                predict,
                d16off,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:767:1, end:767:2))"]
#[derive(Clone, Debug)]
struct brlz_instructionVar243 {
    RS1: TableRS1,
    d16off: Tabled16off,
    predict: Tablepredict,
}
impl brlz_instructionVar243 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("brlz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a")];
        display.extend_from_slice(&extend);
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.d16off
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d16off = if let Some((len, table)) =
            Tabled16off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS1,
                d16off,
                predict,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:768:1, end:768:2))"]
#[derive(Clone, Debug)]
struct brnz_instructionVar244 {
    predict: Tablepredict,
    d16off: Tabled16off,
    RS1: TableRS1,
}
impl brnz_instructionVar244 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("brnz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a")];
        display.extend_from_slice(&extend);
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.d16off
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d16off = if let Some((len, table)) =
            Tabled16off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                predict,
                d16off,
                RS1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:769:1, end:769:2))"]
#[derive(Clone, Debug)]
struct brgz_instructionVar245 {
    predict: Tablepredict,
    RS1: TableRS1,
    d16off: Tabled16off,
}
impl brgz_instructionVar245 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("brgz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a")];
        display.extend_from_slice(&extend);
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.d16off
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d16off = if let Some((len, table)) =
            Tabled16off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                predict,
                RS1,
                d16off,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:770:1, end:770:2))"]
#[derive(Clone, Debug)]
struct brgez_instructionVar246 {
    d16off: Tabled16off,
    RS1: TableRS1,
    predict: Tablepredict,
}
impl brgez_instructionVar246 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("brgez"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a")];
        display.extend_from_slice(&extend);
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.d16off
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d16off = if let Some((len, table)) =
            Tabled16off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                d16off,
                RS1,
                predict,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:780:1, end:780:2))"]
#[derive(Clone, Debug)]
struct ba_instructionVar247 {
    reloff: Tablereloff,
}
impl ba_instructionVar247 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ba"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reloff
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reloff = if let Some((len, table)) =
            Tablereloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reloff }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:781:1, end:781:2))"]
#[derive(Clone, Debug)]
struct instructionVar248 {
    reloff: Tablereloff,
}
impl instructionVar248 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("ba,a"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.reloff
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reloff = if let Some((len, table)) =
            Tablereloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reloff }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:783:1, end:783:2))"]
#[derive(Clone, Debug)]
struct bn_instructionVar249 {
    reloff: Tablereloff,
}
impl bn_instructionVar249 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bn"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reloff
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reloff = if let Some((len, table)) =
            Tablereloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reloff }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:784:1, end:784:2))"]
#[derive(Clone, Debug)]
struct instructionVar250 {
    skip: Tableskip,
    reloff: Tablereloff,
}
impl instructionVar250 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("bn,a"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.reloff
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.skip
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reloff = if let Some((len, table)) =
            Tablereloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let skip = if let Some((len, table)) =
            Tableskip::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { skip, reloff }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:789:1, end:789:2))"]
#[derive(Clone, Debug)]
struct bpa_instructionVar251 {
    predict: Tablepredict,
    reloff64: Tablereloff64,
}
impl bpa_instructionVar251 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bpa"));
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reloff64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reloff64 = if let Some((len, table)) =
            Tablereloff64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { predict, reloff64 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:790:1, end:790:2))"]
#[derive(Clone, Debug)]
struct instructionVar252 {
    reloff64: Tablereloff64,
    predict: Tablepredict,
}
impl instructionVar252 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("bpa,a")];
        display.extend_from_slice(&extend);
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reloff64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reloff64 = if let Some((len, table)) =
            Tablereloff64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reloff64, predict }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:792:1, end:792:2))"]
#[derive(Clone, Debug)]
struct bpn_instructionVar253 {
    reloff64: Tablereloff64,
    predict: Tablepredict,
}
impl bpn_instructionVar253 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bpn"));
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reloff64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reloff64 = if let Some((len, table)) =
            Tablereloff64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reloff64, predict }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:793:1, end:793:2))"]
#[derive(Clone, Debug)]
struct instructionVar254 {
    skip: Tableskip,
    predict: Tablepredict,
    reloff64: Tablereloff64,
}
impl instructionVar254 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("bpn,a")];
        display.extend_from_slice(&extend);
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reloff64
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.skip
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reloff64 = if let Some((len, table)) =
            Tablereloff64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let skip = if let Some((len, table)) =
            Tableskip::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                skip,
                predict,
                reloff64,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1287:1, end:1287:2))"]
#[derive(Clone, Debug)]
struct fba_instructionVar255 {
    reloff: Tablereloff,
}
impl fba_instructionVar255 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fba"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reloff
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reloff = if let Some((len, table)) =
            Tablereloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reloff }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1288:1, end:1288:2))"]
#[derive(Clone, Debug)]
struct instructionVar256 {
    reloff: Tablereloff,
}
impl instructionVar256 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("fba,a"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.reloff
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reloff = if let Some((len, table)) =
            Tablereloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reloff }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1290:1, end:1290:2))"]
#[derive(Clone, Debug)]
struct fbn_instructionVar257 {
    reloff: Tablereloff,
}
impl fbn_instructionVar257 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fbn"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reloff
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reloff = if let Some((len, table)) =
            Tablereloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reloff }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1291:1, end:1291:2))"]
#[derive(Clone, Debug)]
struct instructionVar258 {
    skip: Tableskip,
    reloff: Tablereloff,
}
impl instructionVar258 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("fbn,a"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.reloff
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.skip
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reloff = if let Some((len, table)) =
            Tablereloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let skip = if let Some((len, table)) =
            Tableskip::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { skip, reloff }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:786:1, end:786:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar259 {
    icc: Tableicc,
    reloff: Tablereloff,
}
impl b_instructionVar259 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.icc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reloff
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let icc = if let Some((len, table)) =
            Tableicc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reloff = if let Some((len, table)) =
            Tablereloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { icc, reloff }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:787:1, end:787:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar260 {
    icc: Tableicc,
    reloff: Tablereloff,
}
impl b_instructionVar260 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.icc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",a"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.reloff
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let icc = if let Some((len, table)) =
            Tableicc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reloff = if let Some((len, table)) =
            Tablereloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { icc, reloff }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:795:1, end:795:2))"]
#[derive(Clone, Debug)]
struct bp_instructionVar261 {
    reloff64: Tablereloff64,
    cc: Tablecc,
    predict: Tablepredict,
    BCC: TableBCC,
}
impl bp_instructionVar261 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bp"));
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.reloff64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reloff64 = if let Some((len, table)) =
            Tablereloff64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BCC = if let Some((len, table)) =
            TableBCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cond = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                reloff64,
                cc,
                predict,
                BCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:796:1, end:796:2))"]
#[derive(Clone, Debug)]
struct bp_instructionVar262 {
    cc: Tablecc,
    predict: Tablepredict,
    BCC: TableBCC,
    reloff64: Tablereloff64,
}
impl bp_instructionVar262 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bp"));
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a")];
        display.extend_from_slice(&extend);
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.BCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.reloff64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reloff64 = if let Some((len, table)) =
            Tablereloff64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BCC = if let Some((len, table)) =
            TableBCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cond = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                cc,
                predict,
                BCC,
                reloff64,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:816:1, end:816:2))"]
#[derive(Clone, Debug)]
struct mulx_instructionVar263 {
    regorimm: Tableregorimm,
    RS1: TableRS1,
    RD: TableRD,
}
impl mulx_instructionVar263 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RS1, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:817:1, end:817:2))"]
#[derive(Clone, Debug)]
struct sdivx_instructionVar264 {
    RS1: TableRS1,
    RD: TableRD,
    regorimm: Tableregorimm,
}
impl sdivx_instructionVar264 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdivx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RD, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:818:1, end:818:2))"]
#[derive(Clone, Debug)]
struct udivx_instructionVar265 {
    RS1: TableRS1,
    RD: TableRD,
    regorimm: Tableregorimm,
}
impl udivx_instructionVar265 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("udivx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RD, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:822:1, end:822:2))"]
#[derive(Clone, Debug)]
struct umul_instructionVar266 {
    RD: TableRD,
    RS1: TableRS1,
    regorimm: Tableregorimm,
}
impl umul_instructionVar266 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("umul"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RS1, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:823:1, end:823:2))"]
#[derive(Clone, Debug)]
struct smul_instructionVar267 {
    RD: TableRD,
    regorimm: Tableregorimm,
    RS1: TableRS1,
}
impl smul_instructionVar267 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smul"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, regorimm, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:824:1, end:824:2))"]
#[derive(Clone, Debug)]
struct umulcc_instructionVar268 {
    RS1: TableRS1,
    RD: TableRD,
    regorimm: Tableregorimm,
}
impl umulcc_instructionVar268 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("umulcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RD, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:825:1, end:825:2))"]
#[derive(Clone, Debug)]
struct smulcc_instructionVar269 {
    RS1: TableRS1,
    regorimm: Tableregorimm,
    RD: TableRD,
}
impl smulcc_instructionVar269 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smulcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, regorimm, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:866:1, end:866:2))"]
#[derive(Clone, Debug)]
struct mulscc_instructionVar270 {
    RD: TableRD,
    regorimm: Tableregorimm,
    RS1: TableRS1,
}
impl mulscc_instructionVar270 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulscc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, regorimm, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:891:1, end:891:2))"]
#[derive(Clone, Debug)]
struct udiv_instructionVar271 {
    RS1: TableRS1,
    RD: TableRD,
    regorimm: Tableregorimm,
}
impl udiv_instructionVar271 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("udiv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RD, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:897:1, end:897:2))"]
#[derive(Clone, Debug)]
struct sdiv_instructionVar272 {
    RS1: TableRS1,
    RD: TableRD,
    regorimm: Tableregorimm,
}
impl sdiv_instructionVar272 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdiv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RD, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:904:1, end:904:2))"]
#[derive(Clone, Debug)]
struct udivcc_instructionVar273 {
    regorimm: Tableregorimm,
    RD: TableRD,
    RS1: TableRS1,
}
impl udivcc_instructionVar273 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("udivcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RD, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:915:1, end:915:2))"]
#[derive(Clone, Debug)]
struct sdivcc_instructionVar274 {
    regorimm: Tableregorimm,
    RD: TableRD,
    RS1: TableRS1,
}
impl sdivcc_instructionVar274 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sdivcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RD, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:973:1, end:973:2))"]
#[derive(Clone, Debug)]
struct wr_instructionVar275 {
    wrASR: TablewrASR,
    RS1: TableRS1,
    regorimm: Tableregorimm,
}
impl wr_instructionVar275 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.wrASR
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let wrASR = if let Some((len, table)) =
            TablewrASR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                wrASR,
                RS1,
                regorimm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:982:1, end:982:2))"]
#[derive(Clone, Debug)]
struct save_instructionVar276 {
    RS1: TableRS1,
    regorimm: Tableregorimm,
    RD: TableRD,
}
impl save_instructionVar276 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("save"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, regorimm, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:984:1, end:984:2))"]
#[derive(Clone, Debug)]
struct restore_instructionVar277 {
    RD: TableRD,
    RS1: TableRS1,
    regorimm: Tableregorimm,
}
impl restore_instructionVar277 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("restore"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RS1, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:987:1, end:987:2))"]
#[derive(Clone, Debug)]
struct return_instructionVar278 {
    retea: Tableretea,
}
impl return_instructionVar278 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("return"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.retea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let retea = if let Some((len, table)) =
            Tableretea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { retea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:989:1, end:989:2))"]
#[derive(Clone, Debug)]
struct jmpl_instructionVar279 {
    RD: TableRD,
    retea: Tableretea,
}
impl jmpl_instructionVar279 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jmpl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.retea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let retea = if let Some((len, table)) =
            Tableretea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, retea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1001:1, end:1001:2))"]
#[derive(Clone, Debug)]
struct casa_instructionVar280 {
    RD: TableRD,
    RS2: TableRS2,
    casa_ea: Tablecasa_ea,
}
impl casa_instructionVar280 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("casa"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.casa_ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let casa_ea = if let Some((len, table)) =
            Tablecasa_ea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, RS2, casa_ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1009:1, end:1009:2))"]
#[derive(Clone, Debug)]
struct casxa_instructionVar281 {
    RS2: TableRS2,
    RD: TableRD,
    casa_ea: Tablecasa_ea,
}
impl casxa_instructionVar281 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("casxa"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.casa_ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let casa_ea = if let Some((len, table)) =
            Tablecasa_ea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2, RD, casa_ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1018:1, end:1018:2))"]
#[derive(Clone, Debug)]
struct impdef1_instructionVar282 {}
impl impdef1_instructionVar282 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("impdef1"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1019:1, end:1019:2))"]
#[derive(Clone, Debug)]
struct impdef2_instructionVar283 {}
impl impdef2_instructionVar283 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("impdef2"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1021:1, end:1021:2))"]
#[derive(Clone, Debug)]
struct ldstub_instructionVar284 {
    ea: Tableea,
    RD: TableRD,
}
impl ldstub_instructionVar284 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldstub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1022:1, end:1022:2))"]
#[derive(Clone, Debug)]
struct ldstuba_instructionVar285 {
    RD: TableRD,
    ea_alt: Tableea_alt,
}
impl ldstuba_instructionVar285 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldstuba"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea_alt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1024:1, end:1024:2))"]
#[derive(Clone, Debug)]
struct swap_instructionVar286 {
    RD: TableRD,
    ea: Tableea,
}
impl swap_instructionVar286 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swap"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1025:1, end:1025:2))"]
#[derive(Clone, Debug)]
struct swapa_instructionVar287 {
    ea_alt: Tableea_alt,
    RD: TableRD,
}
impl swapa_instructionVar287 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swapa"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1027:1, end:1027:2))"]
#[derive(Clone, Debug)]
struct taddcc_instructionVar288 {
    RS1: TableRS1,
    regorimm: Tableregorimm,
    RD: TableRD,
}
impl taddcc_instructionVar288 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("taddcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, regorimm, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1033:1, end:1033:2))"]
#[derive(Clone, Debug)]
struct taddcctv_instructionVar289 {
    regorimm: Tableregorimm,
    RD: TableRD,
    RS1: TableRS1,
}
impl taddcctv_instructionVar289 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("taddcctv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RD, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1039:1, end:1039:2))"]
#[derive(Clone, Debug)]
struct tsubcc_instructionVar290 {
    regorimm: Tableregorimm,
    RS1: TableRS1,
    RD: TableRD,
}
impl tsubcc_instructionVar290 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tsubcc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm, RS1, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1045:1, end:1045:2))"]
#[derive(Clone, Debug)]
struct tsubcctv_instructionVar291 {
    RS1: TableRS1,
    RD: TableRD,
    regorimm: Tableregorimm,
}
impl tsubcctv_instructionVar291 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tsubcctv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, RD, regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1061:1, end:1061:2))"]
#[derive(Clone, Debug)]
struct t_instructionVar292 {
    trap: Tabletrap,
    TICC: TableTICC,
    tcc: Tabletcc,
}
impl t_instructionVar292 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("t"));
        self.tcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.TICC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.trap
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let tcc = if let Some((len, table)) =
            Tabletcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let TICC = if let Some((len, table)) =
            TableTICC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let trap = if let Some((len, table)) =
            Tabletrap::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { trap, TICC, tcc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1085:1, end:1085:2))"]
#[derive(Clone, Debug)]
struct rdpr_instructionVar293 {
    prs1: u8,
    RD: TableRD,
}
impl rdpr_instructionVar293 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rdpr"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.prs1),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let prs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RD, prs1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1091:1, end:1091:2))"]
#[derive(Clone, Debug)]
struct wrpr_instructionVar294 {
    prd: u8,
    RS1: TableRS1,
    regorimm: Tableregorimm,
}
impl wrpr_instructionVar294 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrpr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_4_display(self.prd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let prd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, regorimm, prd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1131:1, end:1131:2))"]
#[derive(Clone, Debug)]
struct flush_instructionVar295 {
    ea: Tableea,
}
impl flush_instructionVar295 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flush"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1142:1, end:1142:2))"]
#[derive(Clone, Debug)]
struct prefetch_instructionVar296 {
    fcn: u8,
    ea: Tableea,
}
impl prefetch_instructionVar296 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("prefetch"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.fcn as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, fcn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1143:1, end:1143:2))"]
#[derive(Clone, Debug)]
struct prefetcha_instructionVar297 {
    fcn: u8,
    ea_alt: Tableea_alt,
}
impl prefetcha_instructionVar297 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("prefetcha"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.fcn as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, fcn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1249:1, end:1249:2))"]
#[derive(Clone, Debug)]
struct ld_instructionVar298 {
    fsrd: u8,
    ea: Tableea,
}
impl ld_instructionVar298 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ld"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_5_display(self.fsrd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1250:1, end:1250:2))"]
#[derive(Clone, Debug)]
struct ldd_instructionVar299 {
    fdrd: u8,
    ea: Tableea,
}
impl ldd_instructionVar299 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_6_display(self.fdrd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1251:1, end:1251:2))"]
#[derive(Clone, Debug)]
struct ldq_instructionVar300 {
    fqrd: u8,
    ea: Tableea,
}
impl ldq_instructionVar300 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_7_display(self.fqrd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fqrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1255:1, end:1255:2))"]
#[derive(Clone, Debug)]
struct lda_instructionVar301 {
    fsrd: u8,
    ea_alt: Tableea_alt,
}
impl lda_instructionVar301 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lda"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_5_display(self.fsrd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1256:1, end:1256:2))"]
#[derive(Clone, Debug)]
struct ldda_instructionVar302 {
    fdrd: u8,
    ea_alt: Tableea_alt,
}
impl ldda_instructionVar302 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldda"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_6_display(self.fdrd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1257:1, end:1257:2))"]
#[derive(Clone, Debug)]
struct ldqa_instructionVar303 {
    fqrd: u8,
    ea_alt: Tableea_alt,
}
impl ldqa_instructionVar303 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldqa"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_7_display(self.fqrd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fqrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1259:1, end:1259:2))"]
#[derive(Clone, Debug)]
struct st_instructionVar304 {
    fsrd: u8,
    ea: Tableea,
}
impl st_instructionVar304 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("st"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1260:1, end:1260:2))"]
#[derive(Clone, Debug)]
struct std_instructionVar305 {
    fdrd: u8,
    ea: Tableea,
}
impl std_instructionVar305 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("std"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1261:1, end:1261:2))"]
#[derive(Clone, Debug)]
struct stq_instructionVar306 {
    fqrd: u8,
    ea: Tableea,
}
impl stq_instructionVar306 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stq"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ea
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea = if let Some((len, table)) =
            Tableea::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fqrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1265:1, end:1265:2))"]
#[derive(Clone, Debug)]
struct sta_instructionVar307 {
    fsrd: u8,
    ea_alt: Tableea_alt,
}
impl sta_instructionVar307 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sta"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.fsrd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fsrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, fsrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1266:1, end:1266:2))"]
#[derive(Clone, Debug)]
struct stda_instructionVar308 {
    fdrd: u8,
    ea_alt: Tableea_alt,
}
impl stda_instructionVar308 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stda"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fdrd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, fdrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1267:1, end:1267:2))"]
#[derive(Clone, Debug)]
struct stqa_instructionVar309 {
    fqrd: u8,
    ea_alt: Tableea_alt,
}
impl stqa_instructionVar309 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stqa"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.fqrd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ea_alt
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ea_alt = if let Some((len, table)) =
            Tableea_alt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fqrd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_alt, fqrd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1293:1, end:1293:2))"]
#[derive(Clone, Debug)]
struct fb_instructionVar310 {
    reloff: Tablereloff,
    fcc: Tablefcc,
}
impl fb_instructionVar310 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fb"));
        self.fcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reloff
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc = if let Some((len, table)) =
            Tablefcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reloff = if let Some((len, table)) =
            Tablereloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reloff, fcc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1294:1, end:1294:2))"]
#[derive(Clone, Debug)]
struct fb_instructionVar311 {
    fcc: Tablefcc,
    reloff: Tablereloff,
}
impl fb_instructionVar311 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fb"));
        self.fcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",a"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.reloff
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc = if let Some((len, table)) =
            Tablefcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reloff = if let Some((len, table)) =
            Tablereloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc, reloff }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1296:1, end:1296:2))"]
#[derive(Clone, Debug)]
struct fb_instructionVar312 {
    fccn: u8,
    reloff64: Tablereloff64,
    predict: Tablepredict,
    fcc: Tablefcc,
}
impl fb_instructionVar312 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fb"));
        self.fcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("%"),
            meaning_1_display(self.fccn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.reloff64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc = if let Some((len, table)) =
            Tablefcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reloff64 = if let Some((len, table)) =
            Tablereloff64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fccn = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                reloff64,
                predict,
                fcc,
                fccn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1297:1, end:1297:2))"]
#[derive(Clone, Debug)]
struct fb_instructionVar313 {
    fccn: u8,
    predict: Tablepredict,
    fcc: Tablefcc,
    reloff64: Tablereloff64,
}
impl fb_instructionVar313 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fb"));
        self.fcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",a")];
        display.extend_from_slice(&extend);
        self.predict
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("%"),
            meaning_1_display(self.fccn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.reloff64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc = if let Some((len, table)) =
            Tablefcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reloff64 = if let Some((len, table)) =
            Tablereloff64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let predict = if let Some((len, table)) =
            Tablepredict::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fccn = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                predict,
                fcc,
                reloff64,
                fccn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:978:1, end:978:2))"]
#[derive(Clone, Debug)]
struct sethi_instructionVar314 {
    sethidisp: Tablesethidisp,
    RD: TableRD,
}
impl sethi_instructionVar314 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sethi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.sethidisp
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RD = if let Some((len, table)) =
            TableRD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sethidisp = if let Some((len, table)) =
            Tablesethidisp::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sethidisp, RD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1136:1, end:1136:2))"]
#[derive(Clone, Debug)]
struct illtrap_instructionVar315 {
    const22: u32,
}
impl illtrap_instructionVar315 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("illtrap"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.const22 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let const22 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { const22 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:803:1, end:803:2))"]
#[derive(Clone, Debug)]
struct call_instructionVar316 {
    callreloff: Tablecallreloff,
}
impl call_instructionVar316 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("call"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.callreloff
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let callreloff = if let Some((len, table)) =
            Tablecallreloff::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { callreloff }))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(nop_instructionVar0),
    Var1(call_instructionVar1),
    Var2(ret_instructionVar2),
    Var3(retl_instructionVar3),
    Var4(membar_instructionVar4),
    Var5(stbar_instructionVar5),
    Var6(sir_instructionVar6),
    Var7(clrx_instructionVar7),
    Var8(clrd_instructionVar8),
    Var9(cmp_instructionVar9),
    Var10(rd_instructionVar10),
    Var11(mov_instructionVar11),
    Var12(popc_instructionVar12),
    Var13(rdpr_instructionVar13),
    Var14(rdpr_instructionVar14),
    Var15(rdpr_instructionVar15),
    Var16(rdpr_instructionVar16),
    Var17(rdhpr_instructionVar17),
    Var18(rdhpr_instructionVar18),
    Var19(rdhpr_instructionVar19),
    Var20(rdhpr_instructionVar20),
    Var21(rdhpr_instructionVar21),
    Var22(rdhpr_instructionVar22),
    Var23(rdhpr_instructionVar23),
    Var24(fmovs_instructionVar24),
    Var25(fmovd_instructionVar25),
    Var26(fmovq_instructionVar26),
    Var27(mov_instructionVar27),
    Var28(fcmps_instructionVar28),
    Var29(fcmpd_instructionVar29),
    Var30(fcmpq_instructionVar30),
    Var31(fcmpes_instructionVar31),
    Var32(fcmped_instructionVar32),
    Var33(fcmpeq_instructionVar33),
    Var34(fabss_instructionVar34),
    Var35(fabsd_instructionVar35),
    Var36(fabsq_instructionVar36),
    Var37(fadds_instructionVar37),
    Var38(faddd_instructionVar38),
    Var39(faddq_instructionVar39),
    Var40(fdivs_instructionVar40),
    Var41(fdivd_instructionVar41),
    Var42(fdivq_instructionVar42),
    Var43(fdmulq_instructionVar43),
    Var44(fsmuld_instructionVar44),
    Var45(fitos_instructionVar45),
    Var46(fitod_instructionVar46),
    Var47(fitoq_instructionVar47),
    Var48(fmovs_instructionVar48),
    Var49(fmovd_instructionVar49),
    Var50(fmovq_instructionVar50),
    Var51(fmuls_instructionVar51),
    Var52(fmuld_instructionVar52),
    Var53(fmulq_instructionVar53),
    Var54(fnegs_instructionVar54),
    Var55(fnegd_instructionVar55),
    Var56(fnegq_instructionVar56),
    Var57(fsubs_instructionVar57),
    Var58(fsubd_instructionVar58),
    Var59(fsubq_instructionVar59),
    Var60(fxtos_instructionVar60),
    Var61(fxtod_instructionVar61),
    Var62(fxtoq_instructionVar62),
    Var63(fstoi_instructionVar63),
    Var64(fdtoi_instructionVar64),
    Var65(fqtoi_instructionVar65),
    Var66(fstox_instructionVar66),
    Var67(fdtox_instructionVar67),
    Var68(fqtox_instructionVar68),
    Var69(fstod_instructionVar69),
    Var70(fstoq_instructionVar70),
    Var71(fdtos_instructionVar71),
    Var72(fdtoq_instructionVar72),
    Var73(fqtos_instructionVar73),
    Var74(fqtod_instructionVar74),
    Var75(fsqrts_instructionVar75),
    Var76(fsqrtd_instructionVar76),
    Var77(fsqrtq_instructionVar77),
    Var78(alignaddr_instructionVar78),
    Var79(alignaddrl_instructionVar79),
    Var80(array16_instructionVar80),
    Var81(array32_instructionVar81),
    Var82(array8_instructionVar82),
    Var83(edge16cc_instructionVar83),
    Var84(edge16lcc_instructionVar84),
    Var85(edge32cc_instructionVar85),
    Var86(edge32lcc_instructionVar86),
    Var87(edge8cc_instructionVar87),
    Var88(edge8lcc_instructionVar88),
    Var89(faligndata_instructionVar89),
    Var90(fandd_instructionVar90),
    Var91(fandnot1d_instructionVar91),
    Var92(fandnot1s_instructionVar92),
    Var93(fandnot2d_instructionVar93),
    Var94(fandnot2s_instructionVar94),
    Var95(fands_instructionVar95),
    Var96(fexpand_instructionVar96),
    Var97(fmul8sux16_instructionVar97),
    Var98(fmul8ulx16_instructionVar98),
    Var99(fmul8x16_instructionVar99),
    Var100(fmul8x16al_instructionVar100),
    Var101(fmul8x16au_instructionVar101),
    Var102(fmuld8sux16_instructionVar102),
    Var103(fmuld8ulx16_instructionVar103),
    Var104(fnandd_instructionVar104),
    Var105(fnands_instructionVar105),
    Var106(fnord_instructionVar106),
    Var107(fnors_instructionVar107),
    Var108(fnot1d_instructionVar108),
    Var109(fnot1s_instructionVar109),
    Var110(fnot2d_instructionVar110),
    Var111(fnot2s_instructionVar111),
    Var112(foned_instructionVar112),
    Var113(fones_instructionVar113),
    Var114(ford_instructionVar114),
    Var115(fornot1d_instructionVar115),
    Var116(fornot1s_instructionVar116),
    Var117(fornot2d_instructionVar117),
    Var118(fornot2s_instructionVar118),
    Var119(fors_instructionVar119),
    Var120(fpack16_instructionVar120),
    Var121(fpack32_instructionVar121),
    Var122(fpackfix_instructionVar122),
    Var123(fpadd16_instructionVar123),
    Var124(fpadd16s_instructionVar124),
    Var125(fpadd32_instructionVar125),
    Var126(fpadd32s_instructionVar126),
    Var127(fpcmpeq16_instructionVar127),
    Var128(fpcmpeq32_instructionVar128),
    Var129(fpcmpgt16_instructionVar129),
    Var130(fpcmpgt32_instructionVar130),
    Var131(fpcmple16_instructionVar131),
    Var132(fpcmple32_instructionVar132),
    Var133(fpcmpne16_instructionVar133),
    Var134(fpcmpne32_instructionVar134),
    Var135(fpmerge_instructionVar135),
    Var136(fpsub16_instructionVar136),
    Var137(fpsub16s_instructionVar137),
    Var138(fpsub32_instructionVar138),
    Var139(fpsub32s_instructionVar139),
    Var140(fsrc1d_instructionVar140),
    Var141(fsrc1s_instructionVar141),
    Var142(fsrc2d_instructionVar142),
    Var143(fsrc2s_instructionVar143),
    Var144(fxnord_instructionVar144),
    Var145(fxnors_instructionVar145),
    Var146(fxord_instructionVar146),
    Var147(fxors_instructionVar147),
    Var148(fzerod_instructionVar148),
    Var149(fzeros_instructionVar149),
    Var150(pdist_instructionVar150),
    Var151(sll_instructionVar151),
    Var152(srl_instructionVar152),
    Var153(sllx_instructionVar153),
    Var154(srlx_instructionVar154),
    Var155(sra_instructionVar155),
    Var156(srax_instructionVar156),
    Var157(fmovrs_instructionVar157),
    Var158(fmovrd_instructionVar158),
    Var159(fmovrq_instructionVar159),
    Var160(rd_instructionVar160),
    Var161(wr_instructionVar161),
    Var162(wr_instructionVar162),
    Var163(wr_instructionVar163),
    Var164(wr_instructionVar164),
    Var165(restore_instructionVar165),
    Var166(jmpl_instructionVar166),
    Var167(jmpl_instructionVar167),
    Var168(wrpr_instructionVar168),
    Var169(wrpr_instructionVar169),
    Var170(wrpr_instructionVar170),
    Var171(wrpr_instructionVar171),
    Var172(wrhpr_instructionVar172),
    Var173(wrhpr_instructionVar173),
    Var174(wrhpr_instructionVar174),
    Var175(wrhpr_instructionVar175),
    Var176(wrhpr_instructionVar176),
    Var177(wrhpr_instructionVar177),
    Var178(done_instructionVar178),
    Var179(retry_instructionVar179),
    Var180(flushw_instructionVar180),
    Var181(restored_instructionVar181),
    Var182(saved_instructionVar182),
    Var183(ld_instructionVar183),
    Var184(ldx_instructionVar184),
    Var185(st_instructionVar185),
    Var186(stx_instructionVar186),
    Var187(mov_instructionVar187),
    Var188(add_instructionVar188),
    Var189(addcc_instructionVar189),
    Var190(addc_instructionVar190),
    Var191(addccc_instructionVar191),
    Var192(and_instructionVar192),
    Var193(andcc_instructionVar193),
    Var194(andn_instructionVar194),
    Var195(andncc_instructionVar195),
    Var196(or_instructionVar196),
    Var197(orcc_instructionVar197),
    Var198(orn_instructionVar198),
    Var199(orncc_instructionVar199),
    Var200(xor_instructionVar200),
    Var201(xorcc_instructionVar201),
    Var202(xnor_instructionVar202),
    Var203(xnorcc_instructionVar203),
    Var204(ldsb_instructionVar204),
    Var205(ldsh_instructionVar205),
    Var206(ldsw_instructionVar206),
    Var207(ldub_instructionVar207),
    Var208(lduh_instructionVar208),
    Var209(lduw_instructionVar209),
    Var210(ldx_instructionVar210),
    Var211(ldd_instructionVar211),
    Var212(ldsba_instructionVar212),
    Var213(ldsha_instructionVar213),
    Var214(ldswa_instructionVar214),
    Var215(lduba_instructionVar215),
    Var216(lduha_instructionVar216),
    Var217(lduwa_instructionVar217),
    Var218(ldxa_instructionVar218),
    Var219(ldda_instructionVar219),
    Var220(stb_instructionVar220),
    Var221(sth_instructionVar221),
    Var222(stw_instructionVar222),
    Var223(stx_instructionVar223),
    Var224(std_instructionVar224),
    Var225(stba_instructionVar225),
    Var226(stha_instructionVar226),
    Var227(stwa_instructionVar227),
    Var228(stxa_instructionVar228),
    Var229(stda_instructionVar229),
    Var230(sub_instructionVar230),
    Var231(subcc_instructionVar231),
    Var232(subc_instructionVar232),
    Var233(subccc_instructionVar233),
    Var234(movr_instructionVar234),
    Var235(brz_instructionVar235),
    Var236(brlez_instructionVar236),
    Var237(brlz_instructionVar237),
    Var238(brnz_instructionVar238),
    Var239(brgz_instructionVar239),
    Var240(brgez_instructionVar240),
    Var241(brz_instructionVar241),
    Var242(brlez_instructionVar242),
    Var243(brlz_instructionVar243),
    Var244(brnz_instructionVar244),
    Var245(brgz_instructionVar245),
    Var246(brgez_instructionVar246),
    Var247(ba_instructionVar247),
    Var248(instructionVar248),
    Var249(bn_instructionVar249),
    Var250(instructionVar250),
    Var251(bpa_instructionVar251),
    Var252(instructionVar252),
    Var253(bpn_instructionVar253),
    Var254(instructionVar254),
    Var255(fba_instructionVar255),
    Var256(instructionVar256),
    Var257(fbn_instructionVar257),
    Var258(instructionVar258),
    Var259(b_instructionVar259),
    Var260(b_instructionVar260),
    Var261(bp_instructionVar261),
    Var262(bp_instructionVar262),
    Var263(mulx_instructionVar263),
    Var264(sdivx_instructionVar264),
    Var265(udivx_instructionVar265),
    Var266(umul_instructionVar266),
    Var267(smul_instructionVar267),
    Var268(umulcc_instructionVar268),
    Var269(smulcc_instructionVar269),
    Var270(mulscc_instructionVar270),
    Var271(udiv_instructionVar271),
    Var272(sdiv_instructionVar272),
    Var273(udivcc_instructionVar273),
    Var274(sdivcc_instructionVar274),
    Var275(wr_instructionVar275),
    Var276(save_instructionVar276),
    Var277(restore_instructionVar277),
    Var278(return_instructionVar278),
    Var279(jmpl_instructionVar279),
    Var280(casa_instructionVar280),
    Var281(casxa_instructionVar281),
    Var282(impdef1_instructionVar282),
    Var283(impdef2_instructionVar283),
    Var284(ldstub_instructionVar284),
    Var285(ldstuba_instructionVar285),
    Var286(swap_instructionVar286),
    Var287(swapa_instructionVar287),
    Var288(taddcc_instructionVar288),
    Var289(taddcctv_instructionVar289),
    Var290(tsubcc_instructionVar290),
    Var291(tsubcctv_instructionVar291),
    Var292(t_instructionVar292),
    Var293(rdpr_instructionVar293),
    Var294(wrpr_instructionVar294),
    Var295(flush_instructionVar295),
    Var296(prefetch_instructionVar296),
    Var297(prefetcha_instructionVar297),
    Var298(ld_instructionVar298),
    Var299(ldd_instructionVar299),
    Var300(ldq_instructionVar300),
    Var301(lda_instructionVar301),
    Var302(ldda_instructionVar302),
    Var303(ldqa_instructionVar303),
    Var304(st_instructionVar304),
    Var305(std_instructionVar305),
    Var306(stq_instructionVar306),
    Var307(sta_instructionVar307),
    Var308(stda_instructionVar308),
    Var309(stqa_instructionVar309),
    Var310(fb_instructionVar310),
    Var311(fb_instructionVar311),
    Var312(fb_instructionVar312),
    Var313(fb_instructionVar313),
    Var314(sethi_instructionVar314),
    Var315(illtrap_instructionVar315),
    Var316(call_instructionVar316),
}
impl Tableinstruction {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var35(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var36(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var37(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var38(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var39(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var40(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var41(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var42(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var43(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var44(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var45(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var46(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var47(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var48(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var49(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var50(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var51(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var52(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var53(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var54(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var55(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var56(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var57(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var58(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var59(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var60(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var61(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var62(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var63(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var64(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var65(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var66(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var67(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var68(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var69(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var70(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var71(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var72(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var73(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var74(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var75(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var76(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var77(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var78(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var79(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var80(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var81(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var82(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var83(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var84(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var85(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var86(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var87(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var88(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var89(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var90(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var91(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var92(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var93(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var94(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var95(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var96(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var97(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var98(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var99(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var100(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var101(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var102(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var103(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var104(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var105(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var106(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var107(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var108(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var109(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var110(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var111(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var112(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var113(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var114(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var115(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var116(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var117(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var118(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var119(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var120(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var121(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var122(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var123(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var124(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var125(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var126(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var127(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var128(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var129(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var130(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var131(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var132(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var133(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var134(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var135(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var136(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var137(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var138(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var139(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var140(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var141(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var142(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var143(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var144(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var145(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var146(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var147(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var148(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var149(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var150(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var151(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var152(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var153(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var154(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var155(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var156(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var157(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var158(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var159(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var160(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var161(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var162(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var163(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var164(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var165(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var166(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var167(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var168(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var169(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var170(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var171(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var172(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var173(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var174(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var175(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var176(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var177(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var178(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var179(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var180(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var181(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var182(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var183(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var184(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var185(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var186(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var187(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var188(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var189(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var190(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var191(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var192(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var193(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var194(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var195(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var196(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var197(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var198(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var199(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var200(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var201(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var202(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var203(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var204(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var205(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var206(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var207(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var208(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var209(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var210(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var211(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var212(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var213(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var214(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var215(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var216(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var217(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var218(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var219(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var220(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var221(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var222(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var223(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var224(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var225(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var226(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var227(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var228(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var229(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var230(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var231(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var232(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var233(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var234(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var235(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var236(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var237(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var238(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var239(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var240(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var241(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var242(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var243(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var244(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var245(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var246(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var247(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var248(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var249(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var250(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var251(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var252(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var253(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var254(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var255(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var256(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var257(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var258(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var259(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var260(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var261(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var262(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var263(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var264(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var265(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var266(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var267(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var268(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var269(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var270(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var271(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var272(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var273(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var274(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var275(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var276(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var277(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var278(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var279(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var280(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var281(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var282(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var283(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var284(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var285(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var286(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var287(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var288(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var289(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var290(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var291(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var292(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var293(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var294(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var295(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var296(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var297(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var298(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var299(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var300(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var301(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var302(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var303(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var304(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var305(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var306(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var307(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var308(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var309(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var310(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var311(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var312(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var313(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var314(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var315(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var316(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                nop_instructionVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 2
        {
            if let Some((inst_len, parsed)) =
                call_instructionVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 255) == 199
            && (tokens_param[2] & 255) == 224
            && (tokens_param[3] & 255) == 8
        {
            if let Some((inst_len, parsed)) =
                ret_instructionVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 255) == 195
            && (tokens_param[2] & 255) == 224
            && (tokens_param[3] & 255) == 8
        {
            if let Some((inst_len, parsed)) =
                retl_instructionVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 255) == 67
            && (tokens_param[2] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                membar_instructionVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 255) == 67
            && (tokens_param[2] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                stbar_instructionVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 159
            && (tokens_param[1] & 255) == 128
            && (tokens_param[2] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                sir_instructionVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 192
            && (tokens_param[1] & 248) == 112
        {
            if let Some((inst_len, parsed)) =
                clrx_instructionVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 192
            && (tokens_param[1] & 248) == 56
        {
            if let Some((inst_len, parsed)) =
                clrd_instructionVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 128
            && (tokens_param[1] & 248) == 160
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 64
            && (tokens_param[2] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                rd_instructionVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 112
            && (tokens_param[2] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                popc_instructionVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 80
            && (tokens_param[2] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                rdpr_instructionVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 80
            && (tokens_param[2] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                rdpr_instructionVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 80
            && (tokens_param[2] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                rdpr_instructionVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 80
            && (tokens_param[2] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                rdpr_instructionVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 72
            && (tokens_param[2] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                rdhpr_instructionVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 72
            && (tokens_param[2] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                rdhpr_instructionVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 72
            && (tokens_param[2] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                rdhpr_instructionVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 73
            && (tokens_param[2] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                rdhpr_instructionVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 73
            && (tokens_param[2] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                rdhpr_instructionVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 79
            && (tokens_param[2] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                rdhpr_instructionVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 255) == 79
            && (tokens_param[2] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                rdhpr_instructionVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 252) == 168
            && (tokens_param[2] & 7) == 0
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fmovs_instructionVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 252) == 168
            && (tokens_param[2] & 7) == 0
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fmovd_instructionVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 252) == 168
            && (tokens_param[2] & 7) == 0
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fmovq_instructionVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 252) == 100
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 249) == 129
            && (tokens_param[1] & 248) == 168
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fcmps_instructionVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 249) == 129
            && (tokens_param[1] & 248) == 168
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fcmpd_instructionVar29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 249) == 129
            && (tokens_param[1] & 248) == 168
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fcmpq_instructionVar30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 249) == 129
            && (tokens_param[1] & 248) == 168
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fcmpes_instructionVar31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 249) == 129
            && (tokens_param[1] & 248) == 168
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fcmped_instructionVar32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 249) == 129
            && (tokens_param[1] & 248) == 168
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                fcmpeq_instructionVar33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 1
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fabss_instructionVar34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 1
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fabsd_instructionVar35::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var35(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 1
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fabsq_instructionVar36::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var36(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 8
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fadds_instructionVar37::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var37(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 8
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                faddd_instructionVar38::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var38(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 8
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                faddq_instructionVar39::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var39(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 9
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fdivs_instructionVar40::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var40(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 9
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fdivd_instructionVar41::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var41(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 9
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                fdivq_instructionVar42::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var42(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 13
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fdmulq_instructionVar43::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var43(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 13
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fsmuld_instructionVar44::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var44(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 24
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                fitos_instructionVar45::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var45(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 25
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                fitod_instructionVar46::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var46(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 25
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                fitoq_instructionVar47::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var47(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 0
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fmovs_instructionVar48::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var48(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 0
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fmovd_instructionVar49::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var49(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 0
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fmovq_instructionVar50::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var50(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 9
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fmuls_instructionVar51::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var51(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 9
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fmuld_instructionVar52::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var52(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 9
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fmulq_instructionVar53::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var53(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 0
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fnegs_instructionVar54::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var54(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 0
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fnegd_instructionVar55::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var55(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 0
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                fnegq_instructionVar56::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var56(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 8
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fsubs_instructionVar57::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var57(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 8
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fsubd_instructionVar58::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var58(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 8
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                fsubq_instructionVar59::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var59(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 16
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                fxtos_instructionVar60::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var60(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 17
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                fxtod_instructionVar61::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var61(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 17
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                fxtoq_instructionVar62::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var62(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 26
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fstoi_instructionVar63::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var63(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 26
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fdtoi_instructionVar64::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var64(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 26
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fqtoi_instructionVar65::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var65(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 16
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fstox_instructionVar66::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var66(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 16
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fdtox_instructionVar67::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var67(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 16
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fqtox_instructionVar68::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var68(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 25
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fstod_instructionVar69::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var69(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 25
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fstoq_instructionVar70::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var70(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 24
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fdtos_instructionVar71::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var71(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 25
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fdtoq_instructionVar72::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var72(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 24
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                fqtos_instructionVar73::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var73(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 25
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fqtod_instructionVar74::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var74(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 5
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fsqrts_instructionVar75::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var75(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 5
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fsqrtd_instructionVar76::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var76(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 160
            && (tokens_param[2] & 63) == 5
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fsqrtq_instructionVar77::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var77(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 3
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                alignaddr_instructionVar78::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var78(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 3
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                alignaddrl_instructionVar79::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var79(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 2
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                array16_instructionVar80::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var80(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 2
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                array32_instructionVar81::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var81(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 2
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                array8_instructionVar82::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var82(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 0
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                edge16cc_instructionVar83::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var83(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 0
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                edge16lcc_instructionVar84::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var84(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 1
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                edge32cc_instructionVar85::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var85(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 1
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                edge32lcc_instructionVar86::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var86(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 0
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                edge8cc_instructionVar87::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var87(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 0
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                edge8lcc_instructionVar88::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var88(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 9
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                faligndata_instructionVar89::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var89(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 14
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                fandd_instructionVar90::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var90(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 13
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                fandnot1d_instructionVar91::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var91(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 13
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fandnot1s_instructionVar92::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var92(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 12
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                fandnot2d_instructionVar93::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var93(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 12
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fandnot2s_instructionVar94::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var94(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 14
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fands_instructionVar95::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var95(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 9
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fexpand_instructionVar96::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var96(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 6
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fmul8sux16_instructionVar97::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var97(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 6
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                fmul8ulx16_instructionVar98::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var98(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 6
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fmul8x16_instructionVar99::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var99(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 6
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fmul8x16al_instructionVar100::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var100(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 6
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fmul8x16au_instructionVar101::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var101(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 7
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                fmuld8sux16_instructionVar102::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var102(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 7
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fmuld8ulx16_instructionVar103::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var103(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 13
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fnandd_instructionVar104::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var104(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 13
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                fnands_instructionVar105::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var105(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 12
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fnord_instructionVar106::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var106(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 12
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fnors_instructionVar107::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var107(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 13
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fnot1d_instructionVar108::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var108(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 13
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fnot1s_instructionVar109::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var109(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 12
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fnot2d_instructionVar110::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var110(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 12
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                fnot2s_instructionVar111::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var111(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 15
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                foned_instructionVar112::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var112(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 15
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                fones_instructionVar113::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var113(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 15
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                ford_instructionVar114::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var114(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 15
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fornot1d_instructionVar115::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var115(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 15
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fornot1s_instructionVar116::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var116(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 14
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fornot2d_instructionVar117::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var117(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 14
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                fornot2s_instructionVar118::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var118(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 15
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fors_instructionVar119::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var119(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 7
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fpack16_instructionVar120::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var120(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 7
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fpack32_instructionVar121::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var121(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 7
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fpackfix_instructionVar122::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var122(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                fpadd16_instructionVar123::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var123(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fpadd16s_instructionVar124::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var124(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fpadd32_instructionVar125::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var125(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fpadd32s_instructionVar126::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var126(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 5
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fpcmpeq16_instructionVar127::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var127(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 5
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fpcmpeq32_instructionVar128::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var128(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 5
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                fpcmpgt16_instructionVar129::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var129(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 5
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                fpcmpgt32_instructionVar130::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var130(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 4
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                fpcmple16_instructionVar131::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var131(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 4
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                fpcmple32_instructionVar132::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var132(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 4
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fpcmpne16_instructionVar133::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var133(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 4
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fpcmpne32_instructionVar134::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var134(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 9
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fpmerge_instructionVar135::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var135(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                fpsub16_instructionVar136::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var136(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fpsub16s_instructionVar137::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var137(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fpsub32_instructionVar138::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var138(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 10
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                fpsub32s_instructionVar139::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var139(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 14
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                fsrc1d_instructionVar140::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var140(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 14
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fsrc1s_instructionVar141::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var141(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 15
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                fsrc2d_instructionVar142::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var142(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 15
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fsrc2s_instructionVar143::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var143(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 14
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                fxnord_instructionVar144::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var144(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 14
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                fxnors_instructionVar145::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var145(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 13
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                fxord_instructionVar146::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var146(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 13
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fxors_instructionVar147::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var147(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 12
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                fzerod_instructionVar148::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var148(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 12
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                fzeros_instructionVar149::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var149(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
            && (tokens_param[2] & 63) == 7
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                pdist_instructionVar150::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var150(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 40
            && (tokens_param[2] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                sll_instructionVar151::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var151(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 48
            && (tokens_param[2] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                srl_instructionVar152::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var152(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 40
            && (tokens_param[2] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                sllx_instructionVar153::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var153(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 48
            && (tokens_param[2] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                srlx_instructionVar154::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var154(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 56
            && (tokens_param[2] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                sra_instructionVar155::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var155(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 56
            && (tokens_param[2] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                srax_instructionVar156::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var156(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 168
            && (tokens_param[2] & 35) == 0
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                fmovrs_instructionVar157::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var157(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 168
            && (tokens_param[2] & 35) == 0
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                fmovrd_instructionVar158::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var158(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 168
            && (tokens_param[2] & 35) == 0
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                fmovrq_instructionVar159::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var159(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 64
            && (tokens_param[2] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                rd_instructionVar160::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var160(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 133
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                wr_instructionVar161::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var161(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 135
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                wr_instructionVar162::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var162(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 141
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                wr_instructionVar163::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var163(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                wr_instructionVar164::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var164(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                restore_instructionVar165::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var165(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 159
            && (tokens_param[1] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                jmpl_instructionVar166::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var166(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                jmpl_instructionVar167::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var167(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                wrpr_instructionVar168::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var168(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 131
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                wrpr_instructionVar169::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var169(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 133
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                wrpr_instructionVar170::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var170(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 135
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                wrpr_instructionVar171::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var171(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                wrhpr_instructionVar172::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var172(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 131
            && (tokens_param[1] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                wrhpr_instructionVar173::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var173(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 135
            && (tokens_param[1] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                wrhpr_instructionVar174::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var174(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 139
            && (tokens_param[1] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                wrhpr_instructionVar175::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var175(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 191
            && (tokens_param[1] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                wrhpr_instructionVar176::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var176(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 189
            && (tokens_param[1] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                wrhpr_instructionVar177::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var177(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 248) == 240
        {
            if let Some((inst_len, parsed)) =
                done_instructionVar178::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var178(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 131
            && (tokens_param[1] & 248) == 240
        {
            if let Some((inst_len, parsed)) =
                retry_instructionVar179::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var179(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 88
            && (tokens_param[2] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                flushw_instructionVar180::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var180(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 131
            && (tokens_param[1] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                restored_instructionVar181::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var181(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                saved_instructionVar182::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var182(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 193 && (tokens_param[1] & 248) == 8
        {
            if let Some((inst_len, parsed)) =
                ld_instructionVar183::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var183(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 195 && (tokens_param[1] & 248) == 8
        {
            if let Some((inst_len, parsed)) =
                ldx_instructionVar184::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var184(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 193
            && (tokens_param[1] & 248) == 40
        {
            if let Some((inst_len, parsed)) =
                st_instructionVar185::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var185(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 195
            && (tokens_param[1] & 248) == 40
        {
            if let Some((inst_len, parsed)) =
                stx_instructionVar186::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var186(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 252) == 96
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar187::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var187(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 193) == 128 && (tokens_param[1] & 248) == 0
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar188::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var188(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                addcc_instructionVar189::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var189(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 64
        {
            if let Some((inst_len, parsed)) =
                addc_instructionVar190::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var190(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                addccc_instructionVar191::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var191(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 193) == 128 && (tokens_param[1] & 248) == 8
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar192::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var192(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                andcc_instructionVar193::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var193(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 40
        {
            if let Some((inst_len, parsed)) =
                andn_instructionVar194::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var194(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 168
        {
            if let Some((inst_len, parsed)) =
                andncc_instructionVar195::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var195(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 16
        {
            if let Some((inst_len, parsed)) =
                or_instructionVar196::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var196(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                orcc_instructionVar197::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var197(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 48
        {
            if let Some((inst_len, parsed)) =
                orn_instructionVar198::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var198(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 176
        {
            if let Some((inst_len, parsed)) =
                orncc_instructionVar199::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var199(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 24
        {
            if let Some((inst_len, parsed)) =
                xor_instructionVar200::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var200(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                xorcc_instructionVar201::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var201(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 56
        {
            if let Some((inst_len, parsed)) =
                xnor_instructionVar202::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var202(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 184
        {
            if let Some((inst_len, parsed)) =
                xnorcc_instructionVar203::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var203(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 72
        {
            if let Some((inst_len, parsed)) =
                ldsb_instructionVar204::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var204(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 80
        {
            if let Some((inst_len, parsed)) =
                ldsh_instructionVar205::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var205(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 64
        {
            if let Some((inst_len, parsed)) =
                ldsw_instructionVar206::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var206(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 193) == 192 && (tokens_param[1] & 248) == 8
        {
            if let Some((inst_len, parsed)) =
                ldub_instructionVar207::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var207(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 16
        {
            if let Some((inst_len, parsed)) =
                lduh_instructionVar208::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var208(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 193) == 192 && (tokens_param[1] & 248) == 0
        {
            if let Some((inst_len, parsed)) =
                lduw_instructionVar209::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var209(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 88
        {
            if let Some((inst_len, parsed)) =
                ldx_instructionVar210::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var210(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 24
        {
            if let Some((inst_len, parsed)) =
                ldd_instructionVar211::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var211(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 200
        {
            if let Some((inst_len, parsed)) =
                ldsba_instructionVar212::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var212(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 208
        {
            if let Some((inst_len, parsed)) =
                ldsha_instructionVar213::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var213(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                ldswa_instructionVar214::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var214(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                lduba_instructionVar215::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var215(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                lduha_instructionVar216::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var216(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                lduwa_instructionVar217::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var217(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 216
        {
            if let Some((inst_len, parsed)) =
                ldxa_instructionVar218::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var218(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                ldda_instructionVar219::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var219(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 40
        {
            if let Some((inst_len, parsed)) =
                stb_instructionVar220::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var220(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 48
        {
            if let Some((inst_len, parsed)) =
                sth_instructionVar221::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var221(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 32
        {
            if let Some((inst_len, parsed)) =
                stw_instructionVar222::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var222(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 112
        {
            if let Some((inst_len, parsed)) =
                stx_instructionVar223::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var223(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 56
        {
            if let Some((inst_len, parsed)) =
                std_instructionVar224::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var224(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 168
        {
            if let Some((inst_len, parsed)) =
                stba_instructionVar225::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var225(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 176
        {
            if let Some((inst_len, parsed)) =
                stha_instructionVar226::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var226(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 160
        {
            if let Some((inst_len, parsed)) =
                stwa_instructionVar227::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var227(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 240
        {
            if let Some((inst_len, parsed)) =
                stxa_instructionVar228::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var228(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 184
        {
            if let Some((inst_len, parsed)) =
                stda_instructionVar229::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var229(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 32
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar230::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var230(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 160
        {
            if let Some((inst_len, parsed)) =
                subcc_instructionVar231::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var231(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 96
        {
            if let Some((inst_len, parsed)) =
                subc_instructionVar232::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var232(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 224
        {
            if let Some((inst_len, parsed)) =
                subccc_instructionVar233::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var233(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 120
        {
            if let Some((inst_len, parsed)) =
                movr_instructionVar234::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var234(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 2 && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                brz_instructionVar235::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var235(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 4 && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                brlez_instructionVar236::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var236(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 6 && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                brlz_instructionVar237::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var237(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                brnz_instructionVar238::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var238(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                brgz_instructionVar239::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var239(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                brgez_instructionVar240::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var240(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 34
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                brz_instructionVar241::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var241(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 36
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                brlez_instructionVar242::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var242(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 38
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                brlz_instructionVar243::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var243(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 42
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                brnz_instructionVar244::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var244(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 44
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                brgz_instructionVar245::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var245(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 46
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                brgez_instructionVar246::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var246(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                ba_instructionVar247::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var247(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                instructionVar248::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var248(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                bn_instructionVar249::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var249(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                instructionVar250::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var250(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 16 && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                bpa_instructionVar251::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var251(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 48 && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                instructionVar252::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var252(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                bpn_instructionVar253::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var253(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 32 && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                instructionVar254::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var254(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                fba_instructionVar255::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var255(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 49
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                instructionVar256::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var256(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 255) == 1 && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                fbn_instructionVar257::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var257(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                instructionVar258::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var258(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 225) == 0 && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar259::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var259(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 225) == 32
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar260::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var260(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 225) == 0 && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                bp_instructionVar261::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var261(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 225) == 32 && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                bp_instructionVar262::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var262(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 72
        {
            if let Some((inst_len, parsed)) =
                mulx_instructionVar263::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var263(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 104
        {
            if let Some((inst_len, parsed)) =
                sdivx_instructionVar264::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var264(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 104
        {
            if let Some((inst_len, parsed)) =
                udivx_instructionVar265::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var265(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 80
        {
            if let Some((inst_len, parsed)) =
                umul_instructionVar266::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var266(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 88
        {
            if let Some((inst_len, parsed)) =
                smul_instructionVar267::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var267(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 208
        {
            if let Some((inst_len, parsed)) =
                umulcc_instructionVar268::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var268(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 216
        {
            if let Some((inst_len, parsed)) =
                smulcc_instructionVar269::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var269(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 32
        {
            if let Some((inst_len, parsed)) =
                mulscc_instructionVar270::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var270(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 112
        {
            if let Some((inst_len, parsed)) =
                udiv_instructionVar271::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var271(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 120
        {
            if let Some((inst_len, parsed)) =
                sdiv_instructionVar272::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var272(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 240
        {
            if let Some((inst_len, parsed)) =
                udivcc_instructionVar273::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var273(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 128
            && (tokens_param[1] & 248) == 248
        {
            if let Some((inst_len, parsed)) =
                sdivcc_instructionVar274::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var274(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                wr_instructionVar275::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var275(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 224
        {
            if let Some((inst_len, parsed)) =
                save_instructionVar276::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var276(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                restore_instructionVar277::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var277(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 200
        {
            if let Some((inst_len, parsed)) =
                return_instructionVar278::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var278(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                jmpl_instructionVar279::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var279(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 224
        {
            if let Some((inst_len, parsed)) =
                casa_instructionVar280::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var280(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 240
        {
            if let Some((inst_len, parsed)) =
                casxa_instructionVar281::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var281(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 176
        {
            if let Some((inst_len, parsed)) =
                impdef1_instructionVar282::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var282(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 184
        {
            if let Some((inst_len, parsed)) =
                impdef2_instructionVar283::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var283(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 104
        {
            if let Some((inst_len, parsed)) =
                ldstub_instructionVar284::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var284(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                ldstuba_instructionVar285::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var285(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 120
        {
            if let Some((inst_len, parsed)) =
                swap_instructionVar286::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var286(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 192
            && (tokens_param[1] & 248) == 248
        {
            if let Some((inst_len, parsed)) =
                swapa_instructionVar287::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var287(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 193) == 129 && (tokens_param[1] & 248) == 0
        {
            if let Some((inst_len, parsed)) =
                taddcc_instructionVar288::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var288(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 16
        {
            if let Some((inst_len, parsed)) =
                taddcctv_instructionVar289::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var289(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 193) == 129 && (tokens_param[1] & 248) == 8
        {
            if let Some((inst_len, parsed)) =
                tsubcc_instructionVar290::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var290(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 24
        {
            if let Some((inst_len, parsed)) =
                tsubcctv_instructionVar291::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var291(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 208
        {
            if let Some((inst_len, parsed)) =
                t_instructionVar292::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var292(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 80
        {
            if let Some((inst_len, parsed)) =
                rdpr_instructionVar293::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var293(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                wrpr_instructionVar294::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var294(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 129
            && (tokens_param[1] & 248) == 216
        {
            if let Some((inst_len, parsed)) =
                flush_instructionVar295::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var295(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 104
        {
            if let Some((inst_len, parsed)) =
                prefetch_instructionVar296::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var296(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                prefetcha_instructionVar297::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var297(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 193) == 193 && (tokens_param[1] & 248) == 0
        {
            if let Some((inst_len, parsed)) =
                ld_instructionVar298::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var298(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 24
        {
            if let Some((inst_len, parsed)) =
                ldd_instructionVar299::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var299(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 16
        {
            if let Some((inst_len, parsed)) =
                ldq_instructionVar300::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var300(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                lda_instructionVar301::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var301(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                ldda_instructionVar302::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var302(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                ldqa_instructionVar303::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var303(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 32
        {
            if let Some((inst_len, parsed)) =
                st_instructionVar304::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var304(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 56
        {
            if let Some((inst_len, parsed)) =
                std_instructionVar305::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var305(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 48
        {
            if let Some((inst_len, parsed)) =
                stq_instructionVar306::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var306(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 160
        {
            if let Some((inst_len, parsed)) =
                sta_instructionVar307::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var307(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 184
        {
            if let Some((inst_len, parsed)) =
                stda_instructionVar308::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var308(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 193) == 193
            && (tokens_param[1] & 248) == 176
        {
            if let Some((inst_len, parsed)) =
                stqa_instructionVar309::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var309(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 225) == 1 && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                fb_instructionVar310::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var310(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 225) == 33
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                fb_instructionVar311::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var311(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 225) == 1 && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                fb_instructionVar312::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var312(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 225) == 33 && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                fb_instructionVar313::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var313(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 193) == 1 && (tokens_param[1] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                sethi_instructionVar314::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var314(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 193) == 0 && (tokens_param[1] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                illtrap_instructionVar315::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var315(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                call_instructionVar316::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var316(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:345:1, end:345:4))"]
#[derive(Clone, Debug)]
struct RS1Var0 {
    rs1: u8,
}
impl RS1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rs1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:346:1, end:346:4))"]
#[derive(Clone, Debug)]
struct RS1Var1 {
    rs1: u8,
}
impl RS1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rs1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs1 }))
    }
}
#[derive(Clone, Debug)]
enum TableRS1 {
    Var0(RS1Var0),
    Var1(RS1Var1),
}
impl TableRS1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 7) == 0 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                RS1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RS1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:348:1, end:348:4))"]
#[derive(Clone, Debug)]
struct RS2Var0 {
    rs2: u8,
}
impl RS2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rs2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:349:1, end:349:4))"]
#[derive(Clone, Debug)]
struct RS2Var1 {
    rs2: u8,
}
impl RS2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rs2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs2 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRS2 {
    Var0(RS2Var0),
    Var1(RS2Var1),
}
impl TableRS2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                RS2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RS2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:354:1, end:354:3))"]
#[derive(Clone, Debug)]
struct RDVar0 {
    rd: u8,
}
impl RDVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:355:1, end:355:3))"]
#[derive(Clone, Debug)]
struct RDVar1 {
    rd: u8,
}
impl RDVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.rd)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd }))
    }
}
#[derive(Clone, Debug)]
enum TableRD {
    Var0(RDVar0),
    Var1(RDVar1),
}
impl TableRD {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 62) == 0 {
            if let Some((inst_len, parsed)) =
                RDVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RDVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:357:1, end:357:9))"]
#[derive(Clone, Debug)]
struct regorimmVar0 {
    RS2: TableRS2,
}
impl regorimmVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:358:1, end:358:9))"]
#[derive(Clone, Debug)]
struct regorimmVar1 {
    simm13: u16,
}
impl regorimmVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Number(
            true,
            (if self.simm13 & 4096 != 0 {
                -1 & !4095
            } else {
                0
            } | self.simm13 as i16)
                .is_negative(),
            (if self.simm13 & 4096 != 0 {
                -1 & !4095
            } else {
                0
            } | self.simm13 as i16)
                .abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let simm13 = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm13 }))
    }
}
#[derive(Clone, Debug)]
enum Tableregorimm {
    Var0(regorimmVar0),
    Var1(regorimmVar1),
}
impl Tableregorimm {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                regorimmVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                regorimmVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:360:1, end:360:11))"]
#[derive(Clone, Debug)]
struct regorimm10Var0 {
    RS2: TableRS2,
}
impl regorimm10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:361:1, end:361:11))"]
#[derive(Clone, Debug)]
struct regorimm10Var1 {
    simm10: u16,
}
impl regorimm10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Number(
            true,
            (if self.simm10 & 512 != 0 { -1 & !511 } else { 0 } | self.simm10 as i16).is_negative(),
            (if self.simm10 & 512 != 0 { -1 & !511 } else { 0 } | self.simm10 as i16).abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let simm10 = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm10 }))
    }
}
#[derive(Clone, Debug)]
enum Tableregorimm10 {
    Var0(regorimm10Var0),
    Var1(regorimm10Var1),
}
impl Tableregorimm10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                regorimm10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                regorimm10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:363:1, end:363:11))"]
#[derive(Clone, Debug)]
struct regorimm11Var0 {
    RS2: TableRS2,
}
impl regorimm11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:364:1, end:364:11))"]
#[derive(Clone, Debug)]
struct regorimm11Var1 {
    simm11: u16,
}
impl regorimm11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Number(
            true,
            (if self.simm11 & 1024 != 0 {
                -1 & !1023
            } else {
                0
            } | self.simm11 as i16)
                .is_negative(),
            (if self.simm11 & 1024 != 0 {
                -1 & !1023
            } else {
                0
            } | self.simm11 as i16)
                .abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let simm11 = token_31(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm11 }))
    }
}
#[derive(Clone, Debug)]
enum Tableregorimm11 {
    Var0(regorimm11Var0),
    Var1(regorimm11Var1),
}
impl Tableregorimm11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                regorimm11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                regorimm11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:366:1, end:366:13))"]
#[derive(Clone, Debug)]
struct reg_or_shcntVar0 {
    RS2: TableRS2,
}
impl reg_or_shcntVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:367:1, end:367:13))"]
#[derive(Clone, Debug)]
struct reg_or_shcntVar1 {
    RS2: TableRS2,
}
impl reg_or_shcntVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:368:1, end:368:13))"]
#[derive(Clone, Debug)]
struct reg_or_shcntVar2 {
    RS2: TableRS2,
}
impl reg_or_shcntVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:370:1, end:370:13))"]
#[derive(Clone, Debug)]
struct reg_or_shcntVar3 {
    shcnt32: u8,
}
impl reg_or_shcntVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.shcnt32 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shcnt32 = token_28(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { shcnt32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:371:1, end:371:13))"]
#[derive(Clone, Debug)]
struct reg_or_shcntVar4 {
    shcnt64: u8,
}
impl reg_or_shcntVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.shcnt64 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shcnt64 = token_29(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { shcnt64 }))
    }
}
#[derive(Clone, Debug)]
enum Tablereg_or_shcnt {
    Var0(reg_or_shcntVar0),
    Var1(reg_or_shcntVar1),
    Var2(reg_or_shcntVar2),
    Var3(reg_or_shcntVar3),
    Var4(reg_or_shcntVar4),
}
impl Tablereg_or_shcnt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                reg_or_shcntVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 48) == 0 {
            if let Some((inst_len, parsed)) =
                reg_or_shcntVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 48) == 16 {
            if let Some((inst_len, parsed)) =
                reg_or_shcntVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 48) == 32 {
            if let Some((inst_len, parsed)) =
                reg_or_shcntVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 48) == 48 {
            if let Some((inst_len, parsed)) =
                reg_or_shcntVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:373:1, end:373:3))"]
#[derive(Clone, Debug)]
struct eaVar0 {
    regorimm: Tableregorimm,
}
impl eaVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:375:1, end:375:3))"]
#[derive(Clone, Debug)]
struct eaVar1 {
    RS1: TableRS1,
}
impl eaVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:374:1, end:374:3))"]
#[derive(Clone, Debug)]
struct eaVar2 {
    RS1: TableRS1,
    regorimm: Tableregorimm,
}
impl eaVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("+")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, regorimm }))
    }
}
#[derive(Clone, Debug)]
enum Tableea {
    Var0(eaVar0),
    Var1(eaVar1),
    Var2(eaVar2),
}
impl Tableea {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 7) == 0 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                eaVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 63) == 32 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                eaVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                eaVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:381:1, end:381:6))"]
#[derive(Clone, Debug)]
struct reteaVar0 {}
impl reteaVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs1 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:377:1, end:377:6))"]
#[derive(Clone, Debug)]
struct reteaVar1 {
    regorimm: Tableregorimm,
}
impl reteaVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:378:1, end:378:6))"]
#[derive(Clone, Debug)]
struct reteaVar2 {
    regorimm: Tableregorimm,
}
impl reteaVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regorimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:380:1, end:380:6))"]
#[derive(Clone, Debug)]
struct reteaVar3 {
    RS1: TableRS1,
}
impl reteaVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:379:1, end:379:6))"]
#[derive(Clone, Debug)]
struct reteaVar4 {
    RS1: TableRS1,
    regorimm: Tableregorimm,
}
impl reteaVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("+")];
        display.extend_from_slice(&extend);
        self.regorimm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regorimm = if let Some((len, table)) =
            Tableregorimm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, regorimm }))
    }
}
#[derive(Clone, Debug)]
enum Tableretea {
    Var0(reteaVar0),
    Var1(reteaVar1),
    Var2(reteaVar2),
    Var3(reteaVar3),
    Var4(reteaVar4),
}
impl Tableretea {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 255) == 224
            && (tokens_param[3] & 255) == 8
        {
            if let Some((inst_len, parsed)) =
                reteaVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 7) == 0 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                reteaVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 7) == 0 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                reteaVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 63) == 32 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                reteaVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                reteaVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:385:1, end:385:7))"]
#[derive(Clone, Debug)]
struct ea_altVar0 {
    RS1: TableRS1,
}
impl ea_altVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal("]"),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("%"),
            <DisplayElement>::Register(Register::ASI),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:383:1, end:383:7))"]
#[derive(Clone, Debug)]
struct ea_altVar1 {
    imm_asi: u8,
    RS2: TableRS2,
    RS1: TableRS1,
}
impl ea_altVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("+")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("]"),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.imm_asi as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let imm_asi = token_33(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2, RS1, imm_asi }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:384:1, end:384:7))"]
#[derive(Clone, Debug)]
struct ea_altVar2 {
    simm13: u16,
    RS1: TableRS1,
}
impl ea_altVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal("+"),
            DisplayElement::Number(
                true,
                (if self.simm13 & 4096 != 0 {
                    -1 & !4095
                } else {
                    0
                } | self.simm13 as i16)
                    .is_negative(),
                (if self.simm13 & 4096 != 0 {
                    -1 & !4095
                } else {
                    0
                } | self.simm13 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal("]"),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("%"),
            <DisplayElement>::Register(Register::ASI),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simm13 = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, simm13 }))
    }
}
#[derive(Clone, Debug)]
enum Tableea_alt {
    Var0(ea_altVar0),
    Var1(ea_altVar1),
    Var2(ea_altVar2),
}
impl Tableea_alt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 63) == 32 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                ea_altVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                ea_altVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                ea_altVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:649:1, end:649:6))"]
#[derive(Clone, Debug)]
struct RCONDVar0 {
    RS1: TableRS1,
}
impl RCONDVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("z")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:650:1, end:650:6))"]
#[derive(Clone, Debug)]
struct RCONDVar1 {
    RS1: TableRS1,
}
impl RCONDVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lez")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:651:1, end:651:6))"]
#[derive(Clone, Debug)]
struct RCONDVar2 {
    RS1: TableRS1,
}
impl RCONDVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lz")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:652:1, end:652:6))"]
#[derive(Clone, Debug)]
struct RCONDVar3 {
    RS1: TableRS1,
}
impl RCONDVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("nz")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:653:1, end:653:6))"]
#[derive(Clone, Debug)]
struct RCONDVar4 {
    RS1: TableRS1,
}
impl RCONDVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gz")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:654:1, end:654:6))"]
#[derive(Clone, Debug)]
struct RCONDVar5 {
    RS1: TableRS1,
}
impl RCONDVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gez")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[derive(Clone, Debug)]
enum TableRCOND {
    Var0(RCONDVar0),
    Var1(RCONDVar1),
    Var2(RCONDVar2),
    Var3(RCONDVar3),
    Var4(RCONDVar4),
    Var5(RCONDVar5),
}
impl TableRCOND {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 4 {
            if let Some((inst_len, parsed)) =
                RCONDVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 8 {
            if let Some((inst_len, parsed)) =
                RCONDVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 12 {
            if let Some((inst_len, parsed)) =
                RCONDVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 20 {
            if let Some((inst_len, parsed)) =
                RCONDVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 24 {
            if let Some((inst_len, parsed)) =
                RCONDVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 28 {
            if let Some((inst_len, parsed)) =
                RCONDVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:669:1, end:669:6))"]
#[derive(Clone, Debug)]
struct m_iccVar0 {}
impl m_iccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("a")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:670:1, end:670:6))"]
#[derive(Clone, Debug)]
struct m_iccVar1 {}
impl m_iccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("n")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:671:1, end:671:6))"]
#[derive(Clone, Debug)]
struct m_iccVar2 {}
impl m_iccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:672:1, end:672:6))"]
#[derive(Clone, Debug)]
struct m_iccVar3 {}
impl m_iccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("e")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:673:1, end:673:6))"]
#[derive(Clone, Debug)]
struct m_iccVar4 {}
impl m_iccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("g")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:674:1, end:674:6))"]
#[derive(Clone, Debug)]
struct m_iccVar5 {}
impl m_iccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:675:1, end:675:6))"]
#[derive(Clone, Debug)]
struct m_iccVar6 {}
impl m_iccVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:676:1, end:676:6))"]
#[derive(Clone, Debug)]
struct m_iccVar7 {}
impl m_iccVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("l")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:677:1, end:677:6))"]
#[derive(Clone, Debug)]
struct m_iccVar8 {}
impl m_iccVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gu")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:678:1, end:678:6))"]
#[derive(Clone, Debug)]
struct m_iccVar9 {}
impl m_iccVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("leu")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:679:1, end:679:6))"]
#[derive(Clone, Debug)]
struct m_iccVar10 {}
impl m_iccVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:680:1, end:680:6))"]
#[derive(Clone, Debug)]
struct m_iccVar11 {}
impl m_iccVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:681:1, end:681:6))"]
#[derive(Clone, Debug)]
struct m_iccVar12 {}
impl m_iccVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("pos")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:682:1, end:682:6))"]
#[derive(Clone, Debug)]
struct m_iccVar13 {}
impl m_iccVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("neg")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:683:1, end:683:6))"]
#[derive(Clone, Debug)]
struct m_iccVar14 {}
impl m_iccVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:684:1, end:684:6))"]
#[derive(Clone, Debug)]
struct m_iccVar15 {}
impl m_iccVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablem_icc {
    Var0(m_iccVar0),
    Var1(m_iccVar1),
    Var2(m_iccVar2),
    Var3(m_iccVar3),
    Var4(m_iccVar4),
    Var5(m_iccVar5),
    Var6(m_iccVar6),
    Var7(m_iccVar7),
    Var8(m_iccVar8),
    Var9(m_iccVar9),
    Var10(m_iccVar10),
    Var11(m_iccVar11),
    Var12(m_iccVar12),
    Var13(m_iccVar13),
    Var14(m_iccVar14),
    Var15(m_iccVar15),
}
impl Tablem_icc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                m_iccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                m_iccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                m_iccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                m_iccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                m_iccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                m_iccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                m_iccVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                m_iccVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                m_iccVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                m_iccVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                m_iccVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                m_iccVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                m_iccVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                m_iccVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                m_iccVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                m_iccVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:686:1, end:686:6))"]
#[derive(Clone, Debug)]
struct m_xccVar0 {}
impl m_xccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("a")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:687:1, end:687:6))"]
#[derive(Clone, Debug)]
struct m_xccVar1 {}
impl m_xccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("n")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:688:1, end:688:6))"]
#[derive(Clone, Debug)]
struct m_xccVar2 {}
impl m_xccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:689:1, end:689:6))"]
#[derive(Clone, Debug)]
struct m_xccVar3 {}
impl m_xccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("e")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:690:1, end:690:6))"]
#[derive(Clone, Debug)]
struct m_xccVar4 {}
impl m_xccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("g")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:691:1, end:691:6))"]
#[derive(Clone, Debug)]
struct m_xccVar5 {}
impl m_xccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:692:1, end:692:6))"]
#[derive(Clone, Debug)]
struct m_xccVar6 {}
impl m_xccVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:693:1, end:693:6))"]
#[derive(Clone, Debug)]
struct m_xccVar7 {}
impl m_xccVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("l")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:694:1, end:694:6))"]
#[derive(Clone, Debug)]
struct m_xccVar8 {}
impl m_xccVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gu")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:695:1, end:695:6))"]
#[derive(Clone, Debug)]
struct m_xccVar9 {}
impl m_xccVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("leu")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:696:1, end:696:6))"]
#[derive(Clone, Debug)]
struct m_xccVar10 {}
impl m_xccVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:697:1, end:697:6))"]
#[derive(Clone, Debug)]
struct m_xccVar11 {}
impl m_xccVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:698:1, end:698:6))"]
#[derive(Clone, Debug)]
struct m_xccVar12 {}
impl m_xccVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("pos")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:699:1, end:699:6))"]
#[derive(Clone, Debug)]
struct m_xccVar13 {}
impl m_xccVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("neg")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:700:1, end:700:6))"]
#[derive(Clone, Debug)]
struct m_xccVar14 {}
impl m_xccVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:701:1, end:701:6))"]
#[derive(Clone, Debug)]
struct m_xccVar15 {}
impl m_xccVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablem_xcc {
    Var0(m_xccVar0),
    Var1(m_xccVar1),
    Var2(m_xccVar2),
    Var3(m_xccVar3),
    Var4(m_xccVar4),
    Var5(m_xccVar5),
    Var6(m_xccVar6),
    Var7(m_xccVar7),
    Var8(m_xccVar8),
    Var9(m_xccVar9),
    Var10(m_xccVar10),
    Var11(m_xccVar11),
    Var12(m_xccVar12),
    Var13(m_xccVar13),
    Var14(m_xccVar14),
    Var15(m_xccVar15),
}
impl Tablem_xcc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                m_xccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                m_xccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                m_xccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                m_xccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                m_xccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                m_xccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                m_xccVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                m_xccVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                m_xccVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                m_xccVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                m_xccVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                m_xccVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                m_xccVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                m_xccVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                m_xccVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                m_xccVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:703:1, end:703:5))"]
#[derive(Clone, Debug)]
struct m_ccVar0 {
    m_icc: Tablem_icc,
}
impl m_ccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m_icc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let m_icc = if let Some((len, table)) =
            Tablem_icc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m_icc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:704:1, end:704:5))"]
#[derive(Clone, Debug)]
struct m_ccVar1 {
    m_xcc: Tablem_xcc,
}
impl m_ccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m_xcc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let m_xcc = if let Some((len, table)) =
            Tablem_xcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m_xcc }))
    }
}
#[derive(Clone, Debug)]
enum Tablem_cc {
    Var0(m_ccVar0),
    Var1(m_ccVar1),
}
impl Tablem_cc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 4) == 4 && (tokens_param[2] & 24) == 0 {
            if let Some((inst_len, parsed)) =
                m_ccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 4) == 4 && (tokens_param[2] & 24) == 16 {
            if let Some((inst_len, parsed)) =
                m_ccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:706:1, end:706:5))"]
#[derive(Clone, Debug)]
struct MICCVar0 {}
impl MICCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%icc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:707:1, end:707:5))"]
#[derive(Clone, Debug)]
struct MICCVar1 {}
impl MICCVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%xcc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableMICC {
    Var0(MICCVar0),
    Var1(MICCVar1),
}
impl TableMICC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 4) == 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                MICCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 4) == 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                MICCVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:718:1, end:718:4))"]
#[derive(Clone, Debug)]
struct iccVar0 {}
impl iccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("a")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:719:1, end:719:4))"]
#[derive(Clone, Debug)]
struct iccVar1 {}
impl iccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:720:1, end:720:4))"]
#[derive(Clone, Debug)]
struct iccVar2 {}
impl iccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("e")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:721:1, end:721:4))"]
#[derive(Clone, Debug)]
struct iccVar3 {}
impl iccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("g")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:722:1, end:722:4))"]
#[derive(Clone, Debug)]
struct iccVar4 {}
impl iccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:723:1, end:723:4))"]
#[derive(Clone, Debug)]
struct iccVar5 {}
impl iccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:724:1, end:724:4))"]
#[derive(Clone, Debug)]
struct iccVar6 {}
impl iccVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("l")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:725:1, end:725:4))"]
#[derive(Clone, Debug)]
struct iccVar7 {}
impl iccVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gu")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:726:1, end:726:4))"]
#[derive(Clone, Debug)]
struct iccVar8 {}
impl iccVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("leu")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:727:1, end:727:4))"]
#[derive(Clone, Debug)]
struct iccVar9 {}
impl iccVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:728:1, end:728:4))"]
#[derive(Clone, Debug)]
struct iccVar10 {}
impl iccVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:729:1, end:729:4))"]
#[derive(Clone, Debug)]
struct iccVar11 {}
impl iccVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("pos")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:730:1, end:730:4))"]
#[derive(Clone, Debug)]
struct iccVar12 {}
impl iccVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("neg")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:731:1, end:731:4))"]
#[derive(Clone, Debug)]
struct iccVar13 {}
impl iccVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:732:1, end:732:4))"]
#[derive(Clone, Debug)]
struct iccVar14 {}
impl iccVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tableicc {
    Var0(iccVar0),
    Var1(iccVar1),
    Var2(iccVar2),
    Var3(iccVar3),
    Var4(iccVar4),
    Var5(iccVar5),
    Var6(iccVar6),
    Var7(iccVar7),
    Var8(iccVar8),
    Var9(iccVar9),
    Var10(iccVar10),
    Var11(iccVar11),
    Var12(iccVar12),
    Var13(iccVar13),
    Var14(iccVar14),
}
impl Tableicc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 16 {
            if let Some((inst_len, parsed)) =
                iccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 18 {
            if let Some((inst_len, parsed)) =
                iccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 2 {
            if let Some((inst_len, parsed)) =
                iccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 20 {
            if let Some((inst_len, parsed)) =
                iccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 4 {
            if let Some((inst_len, parsed)) =
                iccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 22 {
            if let Some((inst_len, parsed)) =
                iccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 6 {
            if let Some((inst_len, parsed)) =
                iccVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 24 {
            if let Some((inst_len, parsed)) =
                iccVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 8 {
            if let Some((inst_len, parsed)) =
                iccVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 26 {
            if let Some((inst_len, parsed)) =
                iccVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 10 {
            if let Some((inst_len, parsed)) =
                iccVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 28 {
            if let Some((inst_len, parsed)) =
                iccVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 12 {
            if let Some((inst_len, parsed)) =
                iccVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 30 {
            if let Some((inst_len, parsed)) =
                iccVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 14 {
            if let Some((inst_len, parsed)) =
                iccVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:734:1, end:734:4))"]
#[derive(Clone, Debug)]
struct xccVar0 {}
impl xccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("a")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:735:1, end:735:4))"]
#[derive(Clone, Debug)]
struct xccVar1 {}
impl xccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:736:1, end:736:4))"]
#[derive(Clone, Debug)]
struct xccVar2 {}
impl xccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("e")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:737:1, end:737:4))"]
#[derive(Clone, Debug)]
struct xccVar3 {}
impl xccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("g")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:738:1, end:738:4))"]
#[derive(Clone, Debug)]
struct xccVar4 {}
impl xccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:739:1, end:739:4))"]
#[derive(Clone, Debug)]
struct xccVar5 {}
impl xccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:740:1, end:740:4))"]
#[derive(Clone, Debug)]
struct xccVar6 {}
impl xccVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("l")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:741:1, end:741:4))"]
#[derive(Clone, Debug)]
struct xccVar7 {}
impl xccVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gu")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:742:1, end:742:4))"]
#[derive(Clone, Debug)]
struct xccVar8 {}
impl xccVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("leu")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:743:1, end:743:4))"]
#[derive(Clone, Debug)]
struct xccVar9 {}
impl xccVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:744:1, end:744:4))"]
#[derive(Clone, Debug)]
struct xccVar10 {}
impl xccVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:745:1, end:745:4))"]
#[derive(Clone, Debug)]
struct xccVar11 {}
impl xccVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("pos")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:746:1, end:746:4))"]
#[derive(Clone, Debug)]
struct xccVar12 {}
impl xccVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("neg")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:747:1, end:747:4))"]
#[derive(Clone, Debug)]
struct xccVar13 {}
impl xccVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:748:1, end:748:4))"]
#[derive(Clone, Debug)]
struct xccVar14 {}
impl xccVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablexcc {
    Var0(xccVar0),
    Var1(xccVar1),
    Var2(xccVar2),
    Var3(xccVar3),
    Var4(xccVar4),
    Var5(xccVar5),
    Var6(xccVar6),
    Var7(xccVar7),
    Var8(xccVar8),
    Var9(xccVar9),
    Var10(xccVar10),
    Var11(xccVar11),
    Var12(xccVar12),
    Var13(xccVar13),
    Var14(xccVar14),
}
impl Tablexcc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 16 {
            if let Some((inst_len, parsed)) =
                xccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 18 {
            if let Some((inst_len, parsed)) =
                xccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 2 {
            if let Some((inst_len, parsed)) =
                xccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 20 {
            if let Some((inst_len, parsed)) =
                xccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 4 {
            if let Some((inst_len, parsed)) =
                xccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 22 {
            if let Some((inst_len, parsed)) =
                xccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 6 {
            if let Some((inst_len, parsed)) =
                xccVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 24 {
            if let Some((inst_len, parsed)) =
                xccVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 8 {
            if let Some((inst_len, parsed)) =
                xccVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 26 {
            if let Some((inst_len, parsed)) =
                xccVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 10 {
            if let Some((inst_len, parsed)) =
                xccVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 28 {
            if let Some((inst_len, parsed)) =
                xccVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 12 {
            if let Some((inst_len, parsed)) =
                xccVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 30 {
            if let Some((inst_len, parsed)) =
                xccVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 14 {
            if let Some((inst_len, parsed)) =
                xccVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:750:1, end:750:3))"]
#[derive(Clone, Debug)]
struct ccVar0 {
    icc: Tableicc,
}
impl ccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.icc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let icc = if let Some((len, table)) =
            Tableicc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { icc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:751:1, end:751:3))"]
#[derive(Clone, Debug)]
struct ccVar1 {
    xcc: Tablexcc,
}
impl ccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.xcc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let xcc = if let Some((len, table)) =
            Tablexcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { xcc }))
    }
}
#[derive(Clone, Debug)]
enum Tablecc {
    Var0(ccVar0),
    Var1(ccVar1),
}
impl Tablecc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 48) == 0 {
            if let Some((inst_len, parsed)) =
                ccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 48) == 32 {
            if let Some((inst_len, parsed)) =
                ccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:753:1, end:753:7))"]
#[derive(Clone, Debug)]
struct d16offVar0 {
    d16hi: u8,
    d16lo: u16,
}
impl d16offVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start).unwrap().wrapping_add(
            4i128.wrapping_mul(
                (u32::try_from(14i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(
                            (if self.d16hi & 2 != 0 { -1 & !1 } else { 0 } | self.d16hi as i8),
                        )
                        .unwrap()
                        .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | i128::try_from(self.d16lo).unwrap()),
            ),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = i128::try_from(inst_start).unwrap().wrapping_add(
            4i128.wrapping_mul(
                (u32::try_from(14i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(token_6(tokens_current))
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | i128::try_from(token_5(tokens_current)).unwrap()),
            ),
        );
        let d16hi = token_6(tokens_current);
        let d16lo = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16hi, d16lo }))
    }
}
#[derive(Clone, Debug)]
enum Tabled16off {
    Var0(d16offVar0),
}
impl Tabled16off {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                d16offVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:755:1, end:755:8))"]
#[derive(Clone, Debug)]
struct predictVar0 {}
impl predictVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",pt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:756:1, end:756:8))"]
#[derive(Clone, Debug)]
struct predictVar1 {}
impl predictVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",pn")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablepredict {
    Var0(predictVar0),
    Var1(predictVar1),
}
impl Tablepredict {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                predictVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                predictVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:772:1, end:772:4))"]
#[derive(Clone, Debug)]
struct BCCVar0 {}
impl BCCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%icc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:773:1, end:773:4))"]
#[derive(Clone, Debug)]
struct BCCVar1 {}
impl BCCVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%xcc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableBCC {
    Var0(BCCVar0),
    Var1(BCCVar1),
}
impl TableBCC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 48) == 0 {
            if let Some((inst_len, parsed)) =
                BCCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 48) == 32 {
            if let Some((inst_len, parsed)) =
                BCCVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:775:1, end:775:7))"]
#[derive(Clone, Debug)]
struct reloffVar0 {
    disp22: u32,
}
impl reloffVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start).unwrap().wrapping_add(
            4i128.wrapping_mul(
                i128::try_from(
                    (if self.disp22 & 2097152 != 0 {
                        -1 & !2097151
                    } else {
                        0
                    } | self.disp22 as i32),
                )
                .unwrap(),
            ),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128.wrapping_mul(i128::try_from(token_3(tokens_current)).unwrap()));
        let disp22 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { disp22 }))
    }
}
#[derive(Clone, Debug)]
enum Tablereloff {
    Var0(reloffVar0),
}
impl Tablereloff {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                reloffVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:776:1, end:776:9))"]
#[derive(Clone, Debug)]
struct reloff64Var0 {
    disp19: u32,
}
impl reloff64Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start).unwrap().wrapping_add(
            4i128.wrapping_mul(
                i128::try_from(
                    (if self.disp19 & 262144 != 0 {
                        -1 & !262143
                    } else {
                        0
                    } | self.disp19 as i32),
                )
                .unwrap(),
            ),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128.wrapping_mul(i128::try_from(token_4(tokens_current)).unwrap()));
        let disp19 = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { disp19 }))
    }
}
#[derive(Clone, Debug)]
enum Tablereloff64 {
    Var0(reloff64Var0),
}
impl Tablereloff64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                reloff64Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:778:1, end:778:5))"]
#[derive(Clone, Debug)]
struct skipVar0 {}
impl skipVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start).unwrap().wrapping_add(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 0;
        calc_reloc = i128::try_from(inst_start).unwrap().wrapping_add(8i128);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tableskip {
    Var0(skipVar0),
}
impl Tableskip {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                skipVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:801:1, end:801:11))"]
#[derive(Clone, Debug)]
struct callreloffVar0 {
    disp30: u32,
}
impl callreloffVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start).unwrap().wrapping_add(
            4i128.wrapping_mul(
                i128::try_from(
                    (if self.disp30 & 536870912 != 0 {
                        -1 & !536870911
                    } else {
                        0
                    } | self.disp30 as i32),
                )
                .unwrap(),
            ),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128.wrapping_mul(i128::try_from(token_2(tokens_current)).unwrap()));
        let disp30 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { disp30 }))
    }
}
#[derive(Clone, Debug)]
enum Tablecallreloff {
    Var0(callreloffVar0),
}
impl Tablecallreloff {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                callreloffVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:945:1, end:945:6))"]
#[derive(Clone, Debug)]
struct rsASRVar0 {}
impl rsASRVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("%"),
            <DisplayElement>::Register(Register::ASI),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:946:1, end:946:6))"]
#[derive(Clone, Debug)]
struct rsASRVar1 {}
impl rsASRVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("%"),
            <DisplayElement>::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:947:1, end:947:6))"]
#[derive(Clone, Debug)]
struct rsASRVar2 {}
impl rsASRVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("%"),
            <DisplayElement>::Register(Register::FPRS),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:948:1, end:948:6))"]
#[derive(Clone, Debug)]
struct rsASRVar3 {
    rs_asr: u8,
}
impl rsASRVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("%"),
            meaning_2_display(self.rs_asr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs_asr = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs_asr }))
    }
}
#[derive(Clone, Debug)]
enum TablersASR {
    Var0(rsASRVar0),
    Var1(rsASRVar1),
    Var2(rsASRVar2),
    Var3(rsASRVar3),
}
impl TablersASR {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 7) == 0 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                rsASRVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 7) == 1 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                rsASRVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 7) == 1 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                rsASRVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                rsASRVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:961:1, end:961:4))"]
#[derive(Clone, Debug)]
struct wrYVar0 {}
impl wrYVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("%"),
            <DisplayElement>::Register(Register::Y),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablewrY {
    Var0(wrYVar0),
}
impl TablewrY {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 62) == 0 {
            if let Some((inst_len, parsed)) =
                wrYVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:962:1, end:962:6))"]
#[derive(Clone, Debug)]
struct wrCCRVar0 {}
impl wrCCRVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("%"),
            <DisplayElement>::Register(Register::CCR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablewrCCR {
    Var0(wrCCRVar0),
}
impl TablewrCCR {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 62) == 4 {
            if let Some((inst_len, parsed)) =
                wrCCRVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:963:1, end:963:6))"]
#[derive(Clone, Debug)]
struct wrASIVar0 {}
impl wrASIVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("%"),
            <DisplayElement>::Register(Register::ASI),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablewrASI {
    Var0(wrASIVar0),
}
impl TablewrASI {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 62) == 6 {
            if let Some((inst_len, parsed)) =
                wrASIVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:964:1, end:964:7))"]
#[derive(Clone, Debug)]
struct wrFPRSVar0 {}
impl wrFPRSVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("%"),
            <DisplayElement>::Register(Register::FPRS),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablewrFPRS {
    Var0(wrFPRSVar0),
}
impl TablewrFPRS {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 62) == 12 {
            if let Some((inst_len, parsed)) =
                wrFPRSVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:965:1, end:965:6))"]
#[derive(Clone, Debug)]
struct wrASRVar0 {
    rd_asr: u8,
}
impl wrASRVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("%"),
            meaning_3_display(self.rd_asr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rd_asr = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rd_asr }))
    }
}
#[derive(Clone, Debug)]
enum TablewrASR {
    Var0(wrASRVar0),
}
impl TablewrASR {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                wrASRVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:976:1, end:976:10))"]
#[derive(Clone, Debug)]
struct sethidispVar0 {
    udisp22: u32,
}
impl sethidispVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_hi: i128 = 0;
        calc_hi = u32::try_from(10i128)
            .ok()
            .and_then(|shl| i128::try_from(self.udisp22).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("%hi("),
            <DisplayElement>::Number(true, calc_hi.is_negative(), calc_hi.abs() as u64),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_hi: i128 = 0;
        let mut block_0_len = 4;
        calc_hi = u32::try_from(10i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_3(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let udisp22 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { udisp22 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesethidisp {
    Var0(sethidispVar0),
}
impl Tablesethidisp {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                sethidispVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:998:1, end:998:8))"]
#[derive(Clone, Debug)]
struct casa_eaVar0 {
    imm_asi: u8,
    RS1: TableRS1,
}
impl casa_eaVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("]"),
            DisplayElement::Number(true, false, self.imm_asi as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let imm_asi = token_33(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, imm_asi }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:999:1, end:999:8))"]
#[derive(Clone, Debug)]
struct casa_eaVar1 {
    RS1: TableRS1,
}
impl casa_eaVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("]%"),
            <DisplayElement>::Register(Register::ASI),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablecasa_ea {
    Var0(casa_eaVar0),
    Var1(casa_eaVar1),
}
impl Tablecasa_ea {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                casa_eaVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                casa_eaVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1052:1, end:1052:4))"]
#[derive(Clone, Debug)]
struct tccVar0 {
    icc: Tableicc,
}
impl tccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.icc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let icc = if let Some((len, table)) =
            Tableicc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { icc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1053:1, end:1053:4))"]
#[derive(Clone, Debug)]
struct tccVar1 {
    xcc: Tablexcc,
}
impl tccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.xcc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let xcc = if let Some((len, table)) =
            Tablexcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { xcc }))
    }
}
#[derive(Clone, Debug)]
enum Tabletcc {
    Var0(tccVar0),
    Var1(tccVar1),
}
impl Tabletcc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 24) == 0 {
            if let Some((inst_len, parsed)) =
                tccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 24) == 16 {
            if let Some((inst_len, parsed)) =
                tccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1055:1, end:1055:5))"]
#[derive(Clone, Debug)]
struct TICCVar0 {}
impl TICCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%icc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1056:1, end:1056:5))"]
#[derive(Clone, Debug)]
struct TICCVar1 {}
impl TICCVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%xcc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableTICC {
    Var0(TICCVar0),
    Var1(TICCVar1),
}
impl TableTICC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 24) == 0 {
            if let Some((inst_len, parsed)) =
                TICCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 24) == 16 {
            if let Some((inst_len, parsed)) =
                TICCVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1058:1, end:1058:5))"]
#[derive(Clone, Debug)]
struct trapVar0 {
    RS2: TableRS2,
    RS1: TableRS1,
}
impl trapVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("+")];
        display.extend_from_slice(&extend);
        self.RS2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RS2 = if let Some((len, table)) =
            TableRS2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS2, RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1059:1, end:1059:5))"]
#[derive(Clone, Debug)]
struct trapVar1 {
    swtrap: u8,
    RS1: TableRS1,
}
impl trapVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.RS1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("+"),
            DisplayElement::Number(true, false, self.swtrap as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let swtrap = token_40(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1, swtrap }))
    }
}
#[derive(Clone, Debug)]
enum Tabletrap {
    Var0(trapVar0),
    Var1(trapVar1),
}
impl Tabletrap {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                trapVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                trapVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1063:1, end:1063:12))"]
#[derive(Clone, Debug)]
struct membar_maskVar0 {}
impl membar_maskVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let cmask = token_34(tokens_current);
        let mmask = token_35(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablemembar_mask {
    Var0(membar_maskVar0),
}
impl Tablemembar_mask {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                membar_maskVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1075:1, end:1075:5))"]
#[derive(Clone, Debug)]
struct tnpcVar0 {}
impl tnpcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%tnpc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tabletnpc {
    Var0(tnpcVar0),
}
impl Tabletnpc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                tnpcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1077:1, end:1077:4))"]
#[derive(Clone, Debug)]
struct tpcVar0 {}
impl tpcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%tpc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tabletpc {
    Var0(tpcVar0),
}
impl Tabletpc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                tpcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1079:1, end:1079:3))"]
#[derive(Clone, Debug)]
struct ttVar0 {}
impl ttVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%tt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablett {
    Var0(ttVar0),
}
impl Tablett {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                ttVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1081:1, end:1081:7))"]
#[derive(Clone, Debug)]
struct tstateVar0 {}
impl tstateVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%tstate")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tabletstate {
    Var0(tstateVar0),
}
impl Tabletstate {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                tstateVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1097:1, end:1097:8))"]
#[derive(Clone, Debug)]
struct hpstateVar0 {}
impl hpstateVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%hpstate")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablehpstate {
    Var0(hpstateVar0),
}
impl Tablehpstate {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                hpstateVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1099:1, end:1099:8))"]
#[derive(Clone, Debug)]
struct htstateVar0 {}
impl htstateVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%htstate")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablehtstate {
    Var0(htstateVar0),
}
impl Tablehtstate {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                htstateVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1101:1, end:1101:6))"]
#[derive(Clone, Debug)]
struct hintpVar0 {}
impl hintpVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%hintp")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablehintp {
    Var0(hintpVar0),
}
impl Tablehintp {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                hintpVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1103:1, end:1103:5))"]
#[derive(Clone, Debug)]
struct htbaVar0 {}
impl htbaVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%htba")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablehtba {
    Var0(htbaVar0),
}
impl Tablehtba {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                htbaVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1105:1, end:1105:5))"]
#[derive(Clone, Debug)]
struct hverVar0 {}
impl hverVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%hver")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablehver {
    Var0(hverVar0),
}
impl Tablehver {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                hverVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1107:1, end:1107:15))"]
#[derive(Clone, Debug)]
struct hsys_tick_cmprVar0 {}
impl hsys_tick_cmprVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%hstick_cmpr")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablehsys_tick_cmpr {
    Var0(hsys_tick_cmprVar0),
}
impl Tablehsys_tick_cmpr {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                hsys_tick_cmprVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1109:1, end:1109:7))"]
#[derive(Clone, Debug)]
struct resv30Var0 {}
impl resv30Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%resv30")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcn = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tableresv30 {
    Var0(resv30Var0),
}
impl Tableresv30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                resv30Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1269:1, end:1269:13))"]
#[derive(Clone, Debug)]
struct fcc0_or_fccnVar0 {}
impl fcc0_or_fccnVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1270:1, end:1270:13))"]
#[derive(Clone, Debug)]
struct fcc0_or_fccnVar1 {}
impl fcc0_or_fccnVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefcc0_or_fccn {
    Var0(fcc0_or_fccnVar0),
    Var1(fcc0_or_fccnVar1),
}
impl Tablefcc0_or_fccn {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                fcc0_or_fccnVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                fcc0_or_fccnVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1272:1, end:1272:4))"]
#[derive(Clone, Debug)]
struct fccVar0 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("u")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1273:1, end:1273:4))"]
#[derive(Clone, Debug)]
struct fccVar1 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("g")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1274:1, end:1274:4))"]
#[derive(Clone, Debug)]
struct fccVar2 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ug")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1275:1, end:1275:4))"]
#[derive(Clone, Debug)]
struct fccVar3 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("l")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1276:1, end:1276:4))"]
#[derive(Clone, Debug)]
struct fccVar4 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ul")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1277:1, end:1277:4))"]
#[derive(Clone, Debug)]
struct fccVar5 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lg")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1278:1, end:1278:4))"]
#[derive(Clone, Debug)]
struct fccVar6 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1279:1, end:1279:4))"]
#[derive(Clone, Debug)]
struct fccVar7 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("e")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1280:1, end:1280:4))"]
#[derive(Clone, Debug)]
struct fccVar8 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ue")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1281:1, end:1281:4))"]
#[derive(Clone, Debug)]
struct fccVar9 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1282:1, end:1282:4))"]
#[derive(Clone, Debug)]
struct fccVar10 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("uge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1283:1, end:1283:4))"]
#[derive(Clone, Debug)]
struct fccVar11 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1284:1, end:1284:4))"]
#[derive(Clone, Debug)]
struct fccVar12 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ule")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1285:1, end:1285:4))"]
#[derive(Clone, Debug)]
struct fccVar13 {
    fcc0_or_fccn: Tablefcc0_or_fccn,
}
impl fccVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("o")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fcc0_or_fccn = if let Some((len, table)) =
            Tablefcc0_or_fccn::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc0_or_fccn }))
    }
}
#[derive(Clone, Debug)]
enum Tablefcc {
    Var0(fccVar0),
    Var1(fccVar1),
    Var2(fccVar2),
    Var3(fccVar3),
    Var4(fccVar4),
    Var5(fccVar5),
    Var6(fccVar6),
    Var7(fccVar7),
    Var8(fccVar8),
    Var9(fccVar9),
    Var10(fccVar10),
    Var11(fccVar11),
    Var12(fccVar12),
    Var13(fccVar13),
}
impl Tablefcc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 14 {
            if let Some((inst_len, parsed)) =
                fccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 12 {
            if let Some((inst_len, parsed)) =
                fccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 10 {
            if let Some((inst_len, parsed)) =
                fccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 8 {
            if let Some((inst_len, parsed)) =
                fccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 6 {
            if let Some((inst_len, parsed)) =
                fccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 4 {
            if let Some((inst_len, parsed)) =
                fccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 2 {
            if let Some((inst_len, parsed)) =
                fccVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 18 {
            if let Some((inst_len, parsed)) =
                fccVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 20 {
            if let Some((inst_len, parsed)) =
                fccVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 22 {
            if let Some((inst_len, parsed)) =
                fccVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 24 {
            if let Some((inst_len, parsed)) =
                fccVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 26 {
            if let Some((inst_len, parsed)) =
                fccVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 28 {
            if let Some((inst_len, parsed)) =
                fccVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 30) == 30 {
            if let Some((inst_len, parsed)) =
                fccVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1316:1, end:1316:2))"]
#[derive(Clone, Debug)]
struct ZVar0 {}
impl ZVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1317:1, end:1317:2))"]
#[derive(Clone, Debug)]
struct ZVar1 {}
impl ZVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableZ {
    Var0(ZVar0),
    Var1(ZVar1),
}
impl TableZ {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 56) == 32 {
            if let Some((inst_len, parsed)) =
                ZVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 56) == 48 {
            if let Some((inst_len, parsed)) =
                ZVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1319:1, end:1319:2))"]
#[derive(Clone, Debug)]
struct CVar0 {}
impl CVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1320:1, end:1320:2))"]
#[derive(Clone, Debug)]
struct CVar1 {}
impl CVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableC {
    Var0(CVar0),
    Var1(CVar1),
}
impl TableC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 56) == 32 {
            if let Some((inst_len, parsed)) =
                CVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 56) == 48 {
            if let Some((inst_len, parsed)) =
                CVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1322:1, end:1322:2))"]
#[derive(Clone, Debug)]
struct NVar0 {}
impl NVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1323:1, end:1323:2))"]
#[derive(Clone, Debug)]
struct NVar1 {}
impl NVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableN {
    Var0(NVar0),
    Var1(NVar1),
}
impl TableN {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 56) == 32 {
            if let Some((inst_len, parsed)) =
                NVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 56) == 48 {
            if let Some((inst_len, parsed)) =
                NVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1325:1, end:1325:2))"]
#[derive(Clone, Debug)]
struct VVar0 {}
impl VVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1326:1, end:1326:2))"]
#[derive(Clone, Debug)]
struct VVar1 {}
impl VVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableV {
    Var0(VVar0),
    Var1(VVar1),
}
impl TableV {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 56) == 32 {
            if let Some((inst_len, parsed)) =
                VVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 56) == 48 {
            if let Some((inst_len, parsed)) =
                VVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1329:1, end:1329:6))"]
#[derive(Clone, Debug)]
struct fmiccVar0 {}
impl fmiccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("a")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1330:1, end:1330:6))"]
#[derive(Clone, Debug)]
struct fmiccVar1 {}
impl fmiccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("n")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1331:1, end:1331:6))"]
#[derive(Clone, Debug)]
struct fmiccVar2 {
    Z: TableZ,
}
impl fmiccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Z = if let Some((len, table)) =
            TableZ::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Z }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1332:1, end:1332:6))"]
#[derive(Clone, Debug)]
struct fmiccVar3 {
    Z: TableZ,
}
impl fmiccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("e")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Z = if let Some((len, table)) =
            TableZ::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Z }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1333:1, end:1333:6))"]
#[derive(Clone, Debug)]
struct fmiccVar4 {
    Z: TableZ,
    N: TableN,
    V: TableV,
}
impl fmiccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("g")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Z = if let Some((len, table)) =
            TableZ::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let N = if let Some((len, table)) =
            TableN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let V = if let Some((len, table)) =
            TableV::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Z, N, V }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1334:1, end:1334:6))"]
#[derive(Clone, Debug)]
struct fmiccVar5 {
    Z: TableZ,
    V: TableV,
    N: TableN,
}
impl fmiccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Z = if let Some((len, table)) =
            TableZ::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let N = if let Some((len, table)) =
            TableN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let V = if let Some((len, table)) =
            TableV::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Z, V, N }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1335:1, end:1335:6))"]
#[derive(Clone, Debug)]
struct fmiccVar6 {
    N: TableN,
    V: TableV,
}
impl fmiccVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let N = if let Some((len, table)) =
            TableN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let V = if let Some((len, table)) =
            TableV::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { N, V }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1336:1, end:1336:6))"]
#[derive(Clone, Debug)]
struct fmiccVar7 {
    V: TableV,
    N: TableN,
}
impl fmiccVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("l")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let N = if let Some((len, table)) =
            TableN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let V = if let Some((len, table)) =
            TableV::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { V, N }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1337:1, end:1337:6))"]
#[derive(Clone, Debug)]
struct fmiccVar8 {
    Z: TableZ,
    C: TableC,
}
impl fmiccVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gu")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let C = if let Some((len, table)) =
            TableC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Z = if let Some((len, table)) =
            TableZ::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Z, C }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1338:1, end:1338:6))"]
#[derive(Clone, Debug)]
struct fmiccVar9 {
    Z: TableZ,
    C: TableC,
}
impl fmiccVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("leu")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let C = if let Some((len, table)) =
            TableC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Z = if let Some((len, table)) =
            TableZ::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Z, C }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1339:1, end:1339:6))"]
#[derive(Clone, Debug)]
struct fmiccVar10 {
    C: TableC,
}
impl fmiccVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let C = if let Some((len, table)) =
            TableC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { C }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1340:1, end:1340:6))"]
#[derive(Clone, Debug)]
struct fmiccVar11 {
    C: TableC,
}
impl fmiccVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let C = if let Some((len, table)) =
            TableC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { C }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1341:1, end:1341:6))"]
#[derive(Clone, Debug)]
struct fmiccVar12 {
    N: TableN,
}
impl fmiccVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("pos")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let N = if let Some((len, table)) =
            TableN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { N }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1342:1, end:1342:6))"]
#[derive(Clone, Debug)]
struct fmiccVar13 {
    N: TableN,
}
impl fmiccVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("neg")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let N = if let Some((len, table)) =
            TableN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { N }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1343:1, end:1343:6))"]
#[derive(Clone, Debug)]
struct fmiccVar14 {
    V: TableV,
}
impl fmiccVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let V = if let Some((len, table)) =
            TableV::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { V }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1344:1, end:1344:6))"]
#[derive(Clone, Debug)]
struct fmiccVar15 {
    V: TableV,
}
impl fmiccVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let V = if let Some((len, table)) =
            TableV::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { V }))
    }
}
#[derive(Clone, Debug)]
enum Tablefmicc {
    Var0(fmiccVar0),
    Var1(fmiccVar1),
    Var2(fmiccVar2),
    Var3(fmiccVar3),
    Var4(fmiccVar4),
    Var5(fmiccVar5),
    Var6(fmiccVar6),
    Var7(fmiccVar7),
    Var8(fmiccVar8),
    Var9(fmiccVar9),
    Var10(fmiccVar10),
    Var11(fmiccVar11),
    Var12(fmiccVar12),
    Var13(fmiccVar13),
    Var14(fmiccVar14),
    Var15(fmiccVar15),
}
impl Tablefmicc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                fmiccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                fmiccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                fmiccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                fmiccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                fmiccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                fmiccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                fmiccVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                fmiccVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                fmiccVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                fmiccVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                fmiccVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                fmiccVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                fmiccVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                fmiccVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                fmiccVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                fmiccVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1347:1, end:1347:6))"]
#[derive(Clone, Debug)]
struct fmfccVar0 {}
impl fmfccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("a")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1348:1, end:1348:6))"]
#[derive(Clone, Debug)]
struct fmfccVar1 {}
impl fmfccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("n")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1349:1, end:1349:6))"]
#[derive(Clone, Debug)]
struct fmfccVar2 {}
impl fmfccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("u")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1350:1, end:1350:6))"]
#[derive(Clone, Debug)]
struct fmfccVar3 {}
impl fmfccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("g")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1351:1, end:1351:6))"]
#[derive(Clone, Debug)]
struct fmfccVar4 {}
impl fmfccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ug")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1352:1, end:1352:6))"]
#[derive(Clone, Debug)]
struct fmfccVar5 {}
impl fmfccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("l")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1353:1, end:1353:6))"]
#[derive(Clone, Debug)]
struct fmfccVar6 {}
impl fmfccVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ul")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1354:1, end:1354:6))"]
#[derive(Clone, Debug)]
struct fmfccVar7 {}
impl fmfccVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lg")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1355:1, end:1355:6))"]
#[derive(Clone, Debug)]
struct fmfccVar8 {}
impl fmfccVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1356:1, end:1356:6))"]
#[derive(Clone, Debug)]
struct fmfccVar9 {}
impl fmfccVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("e")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1357:1, end:1357:6))"]
#[derive(Clone, Debug)]
struct fmfccVar10 {}
impl fmfccVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ue")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1358:1, end:1358:6))"]
#[derive(Clone, Debug)]
struct fmfccVar11 {}
impl fmfccVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1359:1, end:1359:6))"]
#[derive(Clone, Debug)]
struct fmfccVar12 {}
impl fmfccVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("uge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1360:1, end:1360:6))"]
#[derive(Clone, Debug)]
struct fmfccVar13 {}
impl fmfccVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1361:1, end:1361:6))"]
#[derive(Clone, Debug)]
struct fmfccVar14 {}
impl fmfccVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ule")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1362:1, end:1362:6))"]
#[derive(Clone, Debug)]
struct fmfccVar15 {}
impl fmfccVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("o")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefmfcc {
    Var0(fmfccVar0),
    Var1(fmfccVar1),
    Var2(fmfccVar2),
    Var3(fmfccVar3),
    Var4(fmfccVar4),
    Var5(fmfccVar5),
    Var6(fmfccVar6),
    Var7(fmfccVar7),
    Var8(fmfccVar8),
    Var9(fmfccVar9),
    Var10(fmfccVar10),
    Var11(fmfccVar11),
    Var12(fmfccVar12),
    Var13(fmfccVar13),
    Var14(fmfccVar14),
    Var15(fmfccVar15),
}
impl Tablefmfcc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                fmfccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                fmfccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                fmfccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                fmfccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                fmfccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 1 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                fmfccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                fmfccVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                fmfccVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 0 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                fmfccVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                fmfccVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                fmfccVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 2 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                fmfccVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                fmfccVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                fmfccVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                fmfccVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 3) == 3 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                fmfccVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1364:1, end:1364:15))"]
#[derive(Clone, Debug)]
struct fmfcc_or_fmiccVar0 {
    fmfcc: Tablefmfcc,
}
impl fmfcc_or_fmiccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fmfcc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmfcc = if let Some((len, table)) =
            Tablefmfcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmfcc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1365:1, end:1365:15))"]
#[derive(Clone, Debug)]
struct fmfcc_or_fmiccVar1 {
    fmicc: Tablefmicc,
}
impl fmfcc_or_fmiccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fmicc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fmicc = if let Some((len, table)) =
            Tablefmicc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fmicc }))
    }
}
#[derive(Clone, Debug)]
enum Tablefmfcc_or_fmicc {
    Var0(fmfcc_or_fmiccVar0),
    Var1(fmfcc_or_fmiccVar1),
}
impl Tablefmfcc_or_fmicc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                fmfcc_or_fmiccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                fmfcc_or_fmiccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1368:1, end:1368:12))"]
#[derive(Clone, Debug)]
struct fcc_icc_xccVar0 {}
impl fcc_icc_xccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%icc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1369:1, end:1369:12))"]
#[derive(Clone, Debug)]
struct fcc_icc_xccVar1 {}
impl fcc_icc_xccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("%xcc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1367:1, end:1367:12))"]
#[derive(Clone, Debug)]
struct fcc_icc_xccVar2 {
    fccn_4: u8,
}
impl fcc_icc_xccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("%"),
            meaning_1_display(self.fccn_4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fccn_4 = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fccn_4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefcc_icc_xcc {
    Var0(fcc_icc_xccVar0),
    Var1(fcc_icc_xccVar1),
    Var2(fcc_icc_xccVar2),
}
impl Tablefcc_icc_xcc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 56) == 32 {
            if let Some((inst_len, parsed)) =
                fcc_icc_xccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 56) == 48 {
            if let Some((inst_len, parsed)) =
                fcc_icc_xccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                fcc_icc_xccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1386:1, end:1386:8))"]
#[derive(Clone, Debug)]
struct fmovrccVar0 {
    RS1: TableRS1,
}
impl fmovrccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("z")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1387:1, end:1387:8))"]
#[derive(Clone, Debug)]
struct fmovrccVar1 {
    RS1: TableRS1,
}
impl fmovrccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lez")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1388:1, end:1388:8))"]
#[derive(Clone, Debug)]
struct fmovrccVar2 {
    RS1: TableRS1,
}
impl fmovrccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lz")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1389:1, end:1389:8))"]
#[derive(Clone, Debug)]
struct fmovrccVar3 {
    RS1: TableRS1,
}
impl fmovrccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("nz")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1390:1, end:1390:8))"]
#[derive(Clone, Debug)]
struct fmovrccVar4 {
    RS1: TableRS1,
}
impl fmovrccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gz")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/Sparc/data/languages/SparcV9.sinc, start:1391:1, end:1391:8))"]
#[derive(Clone, Debug)]
struct fmovrccVar5 {
    RS1: TableRS1,
}
impl fmovrccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gez")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS1 = if let Some((len, table)) =
            TableRS1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RS1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefmovrcc {
    Var0(fmovrccVar0),
    Var1(fmovrccVar1),
    Var2(fmovrccVar2),
    Var3(fmovrccVar3),
    Var4(fmovrccVar4),
    Var5(fmovrccVar5),
}
impl Tablefmovrcc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 4 {
            if let Some((inst_len, parsed)) =
                fmovrccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 8 {
            if let Some((inst_len, parsed)) =
                fmovrccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 12 {
            if let Some((inst_len, parsed)) =
                fmovrccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 20 {
            if let Some((inst_len, parsed)) =
                fmovrccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 24 {
            if let Some((inst_len, parsed)) =
                fmovrccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 28 {
            if let Some((inst_len, parsed)) =
                fmovrccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        None
    }
}
pub fn parse_instruction(
    tokens: &[u8],
    context: &mut ContextMemory,
    inst_start: AddrType,
    global_set: &mut GlobalSet,
) -> Option<(u64, Vec<DisplayElement>)> {
    let (inst_len, instruction) = Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(&mut display, context, inst_start, inst_next, global_set);
    Some((inst_next, display))
}
