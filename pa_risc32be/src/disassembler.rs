pub type AddrType = u32;
#[derive(Clone, Copy, Debug)]
pub enum Register {
    r0,
    r1,
    rp,
    r3,
    r4,
    r5,
    r6,
    r7,
    r8,
    r9,
    r10,
    r11,
    r12,
    r13,
    r14,
    r15,
    r16,
    r17,
    r18,
    r19,
    r20,
    r21,
    r22,
    r23,
    r24,
    r25,
    r26,
    dp,
    r28,
    r29,
    sp,
    r31,
    fr0,
    fpe23,
    fpe45,
    fpe67,
    fr4,
    fr5,
    fr6,
    fr7,
    fr8,
    fr9,
    fr10,
    fr11,
    fr12,
    fr13,
    fr14,
    fr15,
    fr16,
    fr17,
    fr18,
    fr19,
    fr20,
    fr21,
    fr22,
    fr23,
    fr24,
    fr25,
    fr26,
    fr27,
    fr28,
    fr29,
    fr30,
    fr31,
    fr0R,
    fr0L,
    fpe2,
    fpe3,
    fpe4,
    fpe5,
    fpe6,
    fpe7,
    fr4L,
    fr4R,
    fr5L,
    fr5R,
    fr6L,
    fr6R,
    fr7L,
    fr7R,
    fr8L,
    fr8R,
    fr9L,
    fr9R,
    fr10L,
    fr10R,
    fr11L,
    fr11R,
    fr12L,
    fr12R,
    fr13L,
    fr13R,
    fr14L,
    fr14R,
    fr15L,
    fr15R,
    fr16L,
    fr16R,
    fr17L,
    fr17R,
    fr18L,
    fr18R,
    fr19L,
    fr19R,
    fr20L,
    fr20R,
    fr21L,
    fr21R,
    fr22L,
    fr22R,
    fr23L,
    fr23R,
    fr24L,
    fr24R,
    fr25L,
    fr25R,
    fr26L,
    fr26R,
    fr27L,
    fr27R,
    fr28L,
    fr28R,
    fr29L,
    fr29R,
    fr30L,
    fr30R,
    fr31L,
    fr31R,
    compareBit,
    compareQueue,
    shr0,
    shr1,
    shr2,
    shr3,
    shr4,
    shr5,
    shr6,
    sr0,
    sr1,
    sr2,
    sr3,
    sr4,
    sr5,
    sr6,
    sr7,
    pswY,
    pswZ,
    pswE,
    pswS,
    pswT,
    pswH,
    pswL,
    pswN,
    pswX,
    pswB,
    pswC,
    pswV,
    pswM,
    pswCB,
    pswG,
    pswF,
    pswR,
    pswQ,
    pswP,
    pswD,
    pswI,
    cr0,
    cr1,
    cr2,
    cr3,
    cr4,
    cr5,
    cr6,
    cr7,
    cr8,
    cr9,
    cr10,
    sar,
    cr12,
    cr13,
    cr14,
    cr15,
    cr16,
    cr17,
    cr18,
    cr19,
    cr20,
    cr21,
    cr22,
    cr23,
    cr24,
    cr25,
    cr26,
    cr27,
    cr28,
    cr29,
    cr30,
    cr31,
    iasq_front,
    iasq_back,
    iaoq_front,
    iaoq_back,
    nullifyCond,
    nullifyNextCond,
    branchCond,
    branchExecuted,
    branchIndDest,
    nullifyCondResult,
    contextreg,
}
impl Register {
    fn as_str(&self) -> &'static str {
        match self {
            Self::r0 => "r0",
            Self::r1 => "r1",
            Self::rp => "rp",
            Self::r3 => "r3",
            Self::r4 => "r4",
            Self::r5 => "r5",
            Self::r6 => "r6",
            Self::r7 => "r7",
            Self::r8 => "r8",
            Self::r9 => "r9",
            Self::r10 => "r10",
            Self::r11 => "r11",
            Self::r12 => "r12",
            Self::r13 => "r13",
            Self::r14 => "r14",
            Self::r15 => "r15",
            Self::r16 => "r16",
            Self::r17 => "r17",
            Self::r18 => "r18",
            Self::r19 => "r19",
            Self::r20 => "r20",
            Self::r21 => "r21",
            Self::r22 => "r22",
            Self::r23 => "r23",
            Self::r24 => "r24",
            Self::r25 => "r25",
            Self::r26 => "r26",
            Self::dp => "dp",
            Self::r28 => "r28",
            Self::r29 => "r29",
            Self::sp => "sp",
            Self::r31 => "r31",
            Self::fr0 => "fr0",
            Self::fpe23 => "fpe23",
            Self::fpe45 => "fpe45",
            Self::fpe67 => "fpe67",
            Self::fr4 => "fr4",
            Self::fr5 => "fr5",
            Self::fr6 => "fr6",
            Self::fr7 => "fr7",
            Self::fr8 => "fr8",
            Self::fr9 => "fr9",
            Self::fr10 => "fr10",
            Self::fr11 => "fr11",
            Self::fr12 => "fr12",
            Self::fr13 => "fr13",
            Self::fr14 => "fr14",
            Self::fr15 => "fr15",
            Self::fr16 => "fr16",
            Self::fr17 => "fr17",
            Self::fr18 => "fr18",
            Self::fr19 => "fr19",
            Self::fr20 => "fr20",
            Self::fr21 => "fr21",
            Self::fr22 => "fr22",
            Self::fr23 => "fr23",
            Self::fr24 => "fr24",
            Self::fr25 => "fr25",
            Self::fr26 => "fr26",
            Self::fr27 => "fr27",
            Self::fr28 => "fr28",
            Self::fr29 => "fr29",
            Self::fr30 => "fr30",
            Self::fr31 => "fr31",
            Self::fr0R => "fr0R",
            Self::fr0L => "fr0L",
            Self::fpe2 => "fpe2",
            Self::fpe3 => "fpe3",
            Self::fpe4 => "fpe4",
            Self::fpe5 => "fpe5",
            Self::fpe6 => "fpe6",
            Self::fpe7 => "fpe7",
            Self::fr4L => "fr4L",
            Self::fr4R => "fr4R",
            Self::fr5L => "fr5L",
            Self::fr5R => "fr5R",
            Self::fr6L => "fr6L",
            Self::fr6R => "fr6R",
            Self::fr7L => "fr7L",
            Self::fr7R => "fr7R",
            Self::fr8L => "fr8L",
            Self::fr8R => "fr8R",
            Self::fr9L => "fr9L",
            Self::fr9R => "fr9R",
            Self::fr10L => "fr10L",
            Self::fr10R => "fr10R",
            Self::fr11L => "fr11L",
            Self::fr11R => "fr11R",
            Self::fr12L => "fr12L",
            Self::fr12R => "fr12R",
            Self::fr13L => "fr13L",
            Self::fr13R => "fr13R",
            Self::fr14L => "fr14L",
            Self::fr14R => "fr14R",
            Self::fr15L => "fr15L",
            Self::fr15R => "fr15R",
            Self::fr16L => "fr16L",
            Self::fr16R => "fr16R",
            Self::fr17L => "fr17L",
            Self::fr17R => "fr17R",
            Self::fr18L => "fr18L",
            Self::fr18R => "fr18R",
            Self::fr19L => "fr19L",
            Self::fr19R => "fr19R",
            Self::fr20L => "fr20L",
            Self::fr20R => "fr20R",
            Self::fr21L => "fr21L",
            Self::fr21R => "fr21R",
            Self::fr22L => "fr22L",
            Self::fr22R => "fr22R",
            Self::fr23L => "fr23L",
            Self::fr23R => "fr23R",
            Self::fr24L => "fr24L",
            Self::fr24R => "fr24R",
            Self::fr25L => "fr25L",
            Self::fr25R => "fr25R",
            Self::fr26L => "fr26L",
            Self::fr26R => "fr26R",
            Self::fr27L => "fr27L",
            Self::fr27R => "fr27R",
            Self::fr28L => "fr28L",
            Self::fr28R => "fr28R",
            Self::fr29L => "fr29L",
            Self::fr29R => "fr29R",
            Self::fr30L => "fr30L",
            Self::fr30R => "fr30R",
            Self::fr31L => "fr31L",
            Self::fr31R => "fr31R",
            Self::compareBit => "compareBit",
            Self::compareQueue => "compareQueue",
            Self::shr0 => "shr0",
            Self::shr1 => "shr1",
            Self::shr2 => "shr2",
            Self::shr3 => "shr3",
            Self::shr4 => "shr4",
            Self::shr5 => "shr5",
            Self::shr6 => "shr6",
            Self::sr0 => "sr0",
            Self::sr1 => "sr1",
            Self::sr2 => "sr2",
            Self::sr3 => "sr3",
            Self::sr4 => "sr4",
            Self::sr5 => "sr5",
            Self::sr6 => "sr6",
            Self::sr7 => "sr7",
            Self::pswY => "pswY",
            Self::pswZ => "pswZ",
            Self::pswE => "pswE",
            Self::pswS => "pswS",
            Self::pswT => "pswT",
            Self::pswH => "pswH",
            Self::pswL => "pswL",
            Self::pswN => "pswN",
            Self::pswX => "pswX",
            Self::pswB => "pswB",
            Self::pswC => "pswC",
            Self::pswV => "pswV",
            Self::pswM => "pswM",
            Self::pswCB => "pswCB",
            Self::pswG => "pswG",
            Self::pswF => "pswF",
            Self::pswR => "pswR",
            Self::pswQ => "pswQ",
            Self::pswP => "pswP",
            Self::pswD => "pswD",
            Self::pswI => "pswI",
            Self::cr0 => "cr0",
            Self::cr1 => "cr1",
            Self::cr2 => "cr2",
            Self::cr3 => "cr3",
            Self::cr4 => "cr4",
            Self::cr5 => "cr5",
            Self::cr6 => "cr6",
            Self::cr7 => "cr7",
            Self::cr8 => "cr8",
            Self::cr9 => "cr9",
            Self::cr10 => "cr10",
            Self::sar => "sar",
            Self::cr12 => "cr12",
            Self::cr13 => "cr13",
            Self::cr14 => "cr14",
            Self::cr15 => "cr15",
            Self::cr16 => "cr16",
            Self::cr17 => "cr17",
            Self::cr18 => "cr18",
            Self::cr19 => "cr19",
            Self::cr20 => "cr20",
            Self::cr21 => "cr21",
            Self::cr22 => "cr22",
            Self::cr23 => "cr23",
            Self::cr24 => "cr24",
            Self::cr25 => "cr25",
            Self::cr26 => "cr26",
            Self::cr27 => "cr27",
            Self::cr28 => "cr28",
            Self::cr29 => "cr29",
            Self::cr30 => "cr30",
            Self::cr31 => "cr31",
            Self::iasq_front => "iasq_front",
            Self::iasq_back => "iasq_back",
            Self::iaoq_front => "iaoq_front",
            Self::iaoq_back => "iaoq_back",
            Self::nullifyCond => "nullifyCond",
            Self::nullifyNextCond => "nullifyNextCond",
            Self::branchCond => "branchCond",
            Self::branchExecuted => "branchExecuted",
            Self::branchIndDest => "branchIndDest",
            Self::nullifyCondResult => "nullifyCondResult",
            Self::contextreg => "contextreg",
        }
    }
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::rp,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::r13,
        14 => Register::r14,
        15 => Register::r15,
        16 => Register::r16,
        17 => Register::r17,
        18 => Register::r18,
        19 => Register::r19,
        20 => Register::r20,
        21 => Register::r21,
        22 => Register::r22,
        23 => Register::r23,
        24 => Register::r24,
        25 => Register::r25,
        26 => Register::r26,
        27 => Register::dp,
        28 => Register::r28,
        29 => Register::r29,
        30 => Register::sp,
        31 => Register::r31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fr0,
        1 => Register::fpe23,
        2 => Register::fpe45,
        3 => Register::fpe67,
        4 => Register::fr4,
        5 => Register::fr5,
        6 => Register::fr6,
        7 => Register::fr7,
        8 => Register::fr8,
        9 => Register::fr9,
        10 => Register::fr10,
        11 => Register::fr11,
        12 => Register::fr12,
        13 => Register::fr13,
        14 => Register::fr14,
        15 => Register::fr15,
        16 => Register::fr16,
        17 => Register::fr17,
        18 => Register::fr18,
        19 => Register::fr19,
        20 => Register::fr20,
        21 => Register::fr21,
        22 => Register::fr22,
        23 => Register::fr23,
        24 => Register::fr24,
        25 => Register::fr25,
        26 => Register::fr26,
        27 => Register::fr27,
        28 => Register::fr28,
        29 => Register::fr29,
        30 => Register::fr30,
        31 => Register::fr31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fr0L,
        1 => Register::fpe2,
        2 => Register::fpe4,
        3 => Register::fpe6,
        4 => Register::fr4L,
        5 => Register::fr5L,
        6 => Register::fr6L,
        7 => Register::fr7L,
        8 => Register::fr8L,
        9 => Register::fr9L,
        10 => Register::fr10L,
        11 => Register::fr11L,
        12 => Register::fr12L,
        13 => Register::fr13L,
        14 => Register::fr14L,
        15 => Register::fr15L,
        16 => Register::fr16L,
        17 => Register::fr17L,
        18 => Register::fr18L,
        19 => Register::fr19L,
        20 => Register::fr20L,
        21 => Register::fr21L,
        22 => Register::fr22L,
        23 => Register::fr23L,
        24 => Register::fr24L,
        25 => Register::fr25L,
        26 => Register::fr26L,
        27 => Register::fr27L,
        28 => Register::fr28L,
        29 => Register::fr29L,
        30 => Register::fr30L,
        31 => Register::fr31L,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fr16L,
        1 => Register::fr17L,
        2 => Register::fr18L,
        3 => Register::fr19L,
        4 => Register::fr20L,
        5 => Register::fr21L,
        6 => Register::fr22L,
        7 => Register::fr23L,
        8 => Register::fr24L,
        9 => Register::fr25L,
        10 => Register::fr26L,
        11 => Register::fr27L,
        12 => Register::fr28L,
        13 => Register::fr29L,
        14 => Register::fr30L,
        15 => Register::fr31L,
        16 => Register::fr16R,
        17 => Register::fr17R,
        18 => Register::fr18R,
        19 => Register::fr19R,
        20 => Register::fr20R,
        21 => Register::fr21R,
        22 => Register::fr22R,
        23 => Register::fr23R,
        24 => Register::fr24R,
        25 => Register::fr25R,
        26 => Register::fr26R,
        27 => Register::fr27R,
        28 => Register::fr28R,
        29 => Register::fr29R,
        30 => Register::fr30R,
        31 => Register::fr31R,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        4 => Register::cr4,
        5 => Register::cr5,
        6 => Register::cr6,
        7 => Register::cr7,
        8 => Register::cr8,
        9 => Register::cr9,
        10 => Register::cr10,
        11 => Register::sar,
        12 => Register::cr12,
        13 => Register::cr13,
        14 => Register::cr14,
        15 => Register::cr15,
        16 => Register::cr16,
        17 => Register::cr17,
        18 => Register::cr18,
        19 => Register::cr19,
        20 => Register::cr20,
        21 => Register::cr21,
        22 => Register::cr22,
        23 => Register::cr23,
        24 => Register::cr24,
        25 => Register::cr25,
        26 => Register::cr26,
        27 => Register::cr27,
        28 => Register::cr28,
        29 => Register::cr29,
        30 => Register::cr30,
        31 => Register::cr31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("RCTR"),
        1 => <DisplayElement>::Literal("CR1"),
        2 => <DisplayElement>::Literal("CR2"),
        3 => <DisplayElement>::Literal("CR3"),
        4 => <DisplayElement>::Literal("CR4"),
        5 => <DisplayElement>::Literal("CR5"),
        6 => <DisplayElement>::Literal("CR6"),
        7 => <DisplayElement>::Literal("CR7"),
        8 => <DisplayElement>::Literal("PID1"),
        9 => <DisplayElement>::Literal("PID2"),
        10 => <DisplayElement>::Literal("CCR"),
        11 => <DisplayElement>::Literal("SAR"),
        12 => <DisplayElement>::Literal("PID3"),
        13 => <DisplayElement>::Literal("PID4"),
        14 => <DisplayElement>::Literal("IVA"),
        15 => <DisplayElement>::Literal("EIEM"),
        16 => <DisplayElement>::Literal("ITMR"),
        17 => <DisplayElement>::Literal("IIASQ"),
        18 => <DisplayElement>::Literal("IIAOQ"),
        19 => <DisplayElement>::Literal("IIR"),
        20 => <DisplayElement>::Literal("ISR"),
        21 => <DisplayElement>::Literal("IOR"),
        22 => <DisplayElement>::Literal("IPSW"),
        23 => <DisplayElement>::Literal("EIRR"),
        24 => <DisplayElement>::Literal("TMP0"),
        25 => <DisplayElement>::Literal("TMP1"),
        26 => <DisplayElement>::Literal("TMP2"),
        27 => <DisplayElement>::Literal("TMP3"),
        28 => <DisplayElement>::Literal("TMP4"),
        29 => <DisplayElement>::Literal("TMP5"),
        30 => <DisplayElement>::Literal("TMP6"),
        31 => <DisplayElement>::Literal("TMP7"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("none"),
        1 => <DisplayElement>::Literal("resv"),
        2 => <DisplayElement>::Literal("sl"),
        3 => <DisplayElement>::Literal("resv"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("none"),
        1 => <DisplayElement>::Literal("BC"),
        2 => <DisplayElement>::Literal("SL"),
        3 => <DisplayElement>::Literal("resv"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("none"),
        1 => <DisplayElement>::Literal("CO"),
        2 => <DisplayElement>::Literal("resv"),
        3 => <DisplayElement>::Literal("resv"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(""),
        1 => <DisplayElement>::Literal(",="),
        2 => <DisplayElement>::Literal(",&lt;"),
        3 => <DisplayElement>::Literal(",OD"),
        4 => <DisplayElement>::Literal(",TR"),
        5 => <DisplayElement>::Literal(",&lt;&gt;"),
        6 => <DisplayElement>::Literal(",&gt;="),
        7 => <DisplayElement>::Literal(",EV"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_10_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(""),
        2 => <DisplayElement>::Literal(",SBZ"),
        3 => <DisplayElement>::Literal(",SHZ"),
        4 => <DisplayElement>::Literal(",SDC"),
        6 => <DisplayElement>::Literal(",SBC"),
        7 => <DisplayElement>::Literal(",SHC"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_11_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(""),
        2 => <DisplayElement>::Literal(",NBZ"),
        3 => <DisplayElement>::Literal(",NHZ"),
        4 => <DisplayElement>::Literal(",NDC"),
        6 => <DisplayElement>::Literal(",NBC"),
        7 => <DisplayElement>::Literal(",NHC"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_12_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(""),
        1 => <DisplayElement>::Literal(",="),
        2 => <DisplayElement>::Literal(",&lt;"),
        3 => <DisplayElement>::Literal(",&lt;="),
        7 => <DisplayElement>::Literal(",OD"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_13_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(""),
        1 => <DisplayElement>::Literal(",&lt;&gt;"),
        2 => <DisplayElement>::Literal(",&gt;="),
        3 => <DisplayElement>::Literal(",&gt;"),
        7 => <DisplayElement>::Literal(",EV"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_14_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(""),
        1 => <DisplayElement>::Literal(",="),
        2 => <DisplayElement>::Literal(",&lt;"),
        3 => <DisplayElement>::Literal(",&lt;="),
        4 => <DisplayElement>::Literal(",NUV"),
        5 => <DisplayElement>::Literal(",ZNV"),
        6 => <DisplayElement>::Literal(",SV"),
        7 => <DisplayElement>::Literal(",OD"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_15_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(""),
        1 => <DisplayElement>::Literal(",&lt;&gt;"),
        2 => <DisplayElement>::Literal(",&gt;="),
        3 => <DisplayElement>::Literal(",&gt;"),
        4 => <DisplayElement>::Literal(",UV"),
        5 => <DisplayElement>::Literal(",VNZ"),
        6 => <DisplayElement>::Literal(",NSV"),
        7 => <DisplayElement>::Literal(",EV"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_16_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(""),
        1 => <DisplayElement>::Literal(",="),
        2 => <DisplayElement>::Literal(",&lt;"),
        3 => <DisplayElement>::Literal(",&lt;="),
        4 => <DisplayElement>::Literal(",&lt;&lt;"),
        5 => <DisplayElement>::Literal(",&lt;&lt;="),
        6 => <DisplayElement>::Literal(",SV"),
        7 => <DisplayElement>::Literal(",OD"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_17_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(""),
        1 => <DisplayElement>::Literal(",&lt;&gt;"),
        2 => <DisplayElement>::Literal(",&gt;="),
        3 => <DisplayElement>::Literal(",&gt;"),
        4 => <DisplayElement>::Literal(",&gt;&gt;="),
        5 => <DisplayElement>::Literal(",&gt;&gt;"),
        6 => <DisplayElement>::Literal(",NSV"),
        7 => <DisplayElement>::Literal(",EV"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_18_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(""),
        1 => <DisplayElement>::Literal("ACC"),
        2 => <DisplayElement>::Literal("REJ"),
        5 => <DisplayElement>::Literal("ACC8"),
        6 => <DisplayElement>::Literal("REJ8"),
        9 => <DisplayElement>::Literal("ACC6"),
        13 => <DisplayElement>::Literal("ACC4"),
        17 => <DisplayElement>::Literal("ACC2"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_19_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(",SGL"),
        1 => <DisplayElement>::Literal(",DBL"),
        2 => <DisplayElement>::Literal(",QUAD"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_20_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(",SGL"),
        1 => <DisplayElement>::Literal(",DBL"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_21_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(",UW"),
        1 => <DisplayElement>::Literal(",UD"),
        2 => <DisplayElement>::Literal(",UQ"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_22_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal(",DBL"),
        1 => <DisplayElement>::Literal(",SGL"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, bool, u64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(true, false, value) => {
                write!(f, "0x{:x}", value)
            }
            Self::Number(true, true, value) => {
                write!(f, "-0x{:x}", value)
            }
            Self::Number(false, false, value) => value.fmt(f),
            Self::Number(false, true, value) => {
                write!(f, "-{:x}", value)
            }
        }
    }
}
#[doc = "Create token_fields: fpc1sub2 highIm5less16"]
fn token_4(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 15) as u8)
}
#[doc = "Create token_fields: im21_1_12 im11less0"]
fn token_51(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 2047) as u16)
}
#[doc = "Create token_fields: pmuop"]
fn token_26(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 31) as u8)
}
#[doc = "Create token_fields: fptx bit6"]
fn token_38(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 1) as u8)
}
#[doc = "Create token_fields: bit10"]
fn token_24(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 1) as u8)
}
#[doc = "Create token_fields: sysopshiftedshort"]
fn token_35(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 127) as u8)
}
#[doc = "Create token_fields: fusedfmt bit5 m spn"]
fn token_42(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 1) as u8)
}
#[doc = "Create token_fields: fpr2x"]
fn token_31(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 1) as u8)
}
#[doc = "Create token_fields: specop fpclass"]
fn token_27(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 3) as u8)
}
#[doc = "Create token_fields: srbit0"]
fn token_11(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 14) & 1) as u8)
}
#[doc = "Create token_fields: bit8 fpx"]
fn token_29(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 1) as u8)
}
#[doc = "Create token_fields: s im21_14_16"]
fn token_10(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 14) & 3) as u8)
}
#[doc = "Create token_fields: sopim10"]
fn token_19(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 1023) as u16)
}
#[doc = "Create token_fields: i2"]
fn token_40(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 127) as u8)
}
#[doc = "Create token_fields: cc ldcc stcc ldcwcc"]
fn token_23(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 3) as u8)
}
#[doc = "Create token_fields: cr crname2 freg2 freg2sgl fr2half fusedr2 reg2 b bboffset crname1"]
fn token_2(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 31) as u8)
}
#[doc = "Create token_fields: sopim5 fpta fusedta"]
fn token_20(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 31) as u8)
}
#[doc = "Create token_fields: op"]
fn token_36(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 63) as u8)
}
#[doc = "Create token_fields: ext4 C subop"]
fn token_33(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 15) as u8)
}
#[doc = "Create token_fields: im15"]
fn token_18(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 32767) as u16)
}
#[doc = "Create token_fields: opfam"]
fn token_1(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 26) & 63) as u8)
}
#[doc = "Create token_fields: bits59 cp"]
fn token_41(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 31) as u8)
}
#[doc = "Create token_fields: w2_2"]
fn token_44(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 2) & 1) as u8)
}
#[doc = "Create token_fields: bit20"]
fn token_3(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 1) as u8)
}
#[doc = "Create token_fields: im14less0"]
fn token_53(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 8191) as u16)
}
#[doc = "Create token_fields: im13"]
fn token_12(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 8191) as u16)
}
#[doc = "Create token_fields: im5less0"]
fn token_56(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 15) as u8)
}
#[doc = "Create token_fields: sopim17"]
fn token_25(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 131071) as u32)
}
#[doc = "Create token_fields: w2"]
fn token_43(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 2) & 2047) as u16)
}
#[doc = "Create token_fields: w2less2"]
fn token_45(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 1023) as u16)
}
#[doc = "Create token_fields: fpsf fpsfraw fpfmt"]
fn token_21(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 3) as u8)
}
#[doc = "Create token_fields: im21less0"]
fn token_50(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 1048575) as u32)
}
#[doc = "Create token_fields: sim5 im5 fpcond fptest fpt fptsgl fusedrt fpthalf crnamet t"]
fn token_55(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 31) as u8)
}
#[doc = "Create token_fields: fpc1sub"]
fn token_8(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 15) & 3) as u8)
}
#[doc = "Create token_fields: highIm10"]
fn token_5(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 1023) as u16)
}
#[doc = "Create token_fields: SEDCondSym RegUnitCondSym InvUnitCondSym RegLogicCondSym InvLogicCondSym RegAddCondSym InvAddCondSym RegCSCondSym InvCSCondSym c fpsub"]
fn token_13(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 7) as u8)
}
#[doc = "Create token_fields: sim21"]
fn token_48(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 2097151) as u32)
}
#[doc = "Create token_fields: im21_12_14"]
fn token_52(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 12) & 3) as u8)
}
#[doc = "Create token_fields: sfu fp0czero"]
fn token_37(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 7) as u8)
}
#[doc = "Create token_fields: bit0 w"]
fn token_57(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 1) as u8)
}
#[doc = "Create token_fields: srbit1"]
fn token_9(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 15) & 1) as u8)
}
#[doc = "Create token_fields: subop1012"]
fn token_17(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 7) as u8)
}
#[doc = "Create token_fields: sysopshifted"]
fn token_34(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 255) as u8)
}
#[doc = "Create token_fields: im26"]
fn token_47(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 67108863) as u32)
}
#[doc = "Create token_fields: fpra fusedra"]
fn token_32(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 31) as u8)
}
#[doc = "Create token_fields: bits78"]
fn token_30(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 3) as u8)
}
#[doc = "Create token_fields: sim14 im14"]
fn token_49(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 16383) as u16)
}
#[doc = "Create token_fields: fpdf fixeddf fpdfraw fixedsf"]
fn token_15(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 3) as u8)
}
#[doc = "Create token_fields: fpfmt1bit bit11"]
fn token_22(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 1) as u8)
}
#[doc = "Create token_fields: srbit2 a u"]
fn token_14(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 1) as u8)
}
#[doc = "Create token_fields: bit9"]
fn token_28(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 1) as u8)
}
#[doc = "Create token_fields: fpr1x f fv zero one"]
fn token_16(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 12) & 1) as u8)
}
#[doc = "Create token_fields: sysop"]
fn token_39(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 255) as u8)
}
#[doc = "Create token_fields: n"]
fn token_46(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 1) as u8)
}
#[doc = "Create token_fields: im11"]
fn token_54(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 2047) as u16)
}
#[doc = "Create token_fields: reg1 fusedr1 freg1 freg1sgl fr1half r highIm5 tr x w1 im21_16_21"]
fn token_6(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 31) as u8)
}
#[doc = "Create token_fields: bit16"]
fn token_7(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 1) as u8)
}
#[derive(Clone, Copy, Default)]
pub struct ContextMemory(pub u128);
impl ContextMemory {
    pub fn read_phase(&self) -> u8 {
        (((self.0.reverse_bits() >> 125) & 7) as u8)
    }
    pub fn write_phase(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(7 << 125)) | ((value as u128 & 7) << 125)).reverse_bits();
    }
    pub fn read_temp1(&self) -> u8 {
        (((self.0.reverse_bits() >> 124) & 1) as u8)
    }
    pub fn write_temp1(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(1 << 124)) | ((value as u128 & 1) << 124)).reverse_bits();
    }
    pub fn read_nullifyEnable(&self) -> u8 {
        (((self.0.reverse_bits() >> 123) & 1) as u8)
    }
    pub fn write_nullifyEnable(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(1 << 123)) | ((value as u128 & 1) << 123)).reverse_bits();
    }
    pub fn read_branchCouldBeNullified(&self) -> u8 {
        (((self.0.reverse_bits() >> 122) & 1) as u8)
    }
    pub fn write_branchCouldBeNullified(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(1 << 122)) | ((value as u128 & 1) << 122)).reverse_bits();
    }
    pub fn read_branchEnable(&self) -> u8 {
        (((self.0.reverse_bits() >> 121) & 1) as u8)
    }
    pub fn write_branchEnable(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(1 << 121)) | ((value as u128 & 1) << 121)).reverse_bits();
    }
    pub fn read_branchType(&self) -> u8 {
        (((self.0.reverse_bits() >> 118) & 7) as u8)
    }
    pub fn write_branchType(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(7 << 118)) | ((value as u128 & 7) << 118)).reverse_bits();
    }
    pub fn read_branchIsReturn(&self) -> u8 {
        (((self.0.reverse_bits() >> 117) & 1) as u8)
    }
    pub fn write_branchIsReturn(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(1 << 117)) | ((value as u128 & 1) << 117)).reverse_bits();
    }
    pub fn read_padding(&self) -> u32 {
        (((self.0.reverse_bits() >> 96) & 4194303) as u32)
    }
    pub fn write_padding(&mut self, value: u32) {
        self.0 = ((self.0.reverse_bits() & !(4194303 << 96)) | ((value as u128 & 4194303) << 96))
            .reverse_bits();
    }
    pub fn read_branchImmDest(&self) -> u32 {
        (((self.0.reverse_bits() >> 64) & 4294967295) as u32)
    }
    pub fn write_branchImmDest(&mut self, value: u32) {
        self.0 = ((self.0.reverse_bits() & !(4294967295 << 64))
            | ((value as u128 & 4294967295) << 64))
            .reverse_bits();
    }
    pub fn read_temp32(&self) -> u32 {
        (((self.0.reverse_bits() >> 32) & 4294967295) as u32)
    }
    pub fn write_temp32(&mut self, value: u32) {
        self.0 = ((self.0.reverse_bits() & !(4294967295 << 32))
            | ((value as u128 & 4294967295) << 32))
            .reverse_bits();
    }
}
#[derive(Clone)]
pub struct GlobalSet {
    default: ContextMemory,
    branches: std::collections::HashMap<AddrType, ContextMemory>,
}
impl GlobalSet {
    pub fn new(default: ContextMemory) -> Self {
        Self {
            default,
            branches: std::collections::HashMap::new(),
        }
    }
    pub fn set(&mut self, address: Option<AddrType>, set: impl FnOnce(&mut ContextMemory)) {
        let Some (address) = address else { return } ;
        let entry = self
            .branches
            .entry(address)
            .or_insert_with(|| self.default.clone());
        set(entry);
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:587:1, end:587:2))"]
#[derive(Clone, Debug)]
struct instructionVar0 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:595:1, end:595:2))"]
#[derive(Clone, Debug)]
struct instructionVar1 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:463:1, end:463:2))"]
#[derive(Clone, Debug)]
struct instructionVar2 {
    immediateDest: TableimmediateDest,
    instruction: Box<Tableinstruction>,
}
impl instructionVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                immediateDest,
                instruction,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:476:1, end:476:2))"]
#[derive(Clone, Debug)]
struct instructionVar3 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:487:1, end:487:2))"]
#[derive(Clone, Debug)]
struct instructionVar4 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:503:1, end:503:2))"]
#[derive(Clone, Debug)]
struct instructionVar5 {
    immediateDest: TableimmediateDest,
    instruction: Box<Tableinstruction>,
}
impl instructionVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                immediateDest,
                instruction,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:515:1, end:515:2))"]
#[derive(Clone, Debug)]
struct instructionVar6 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:531:1, end:531:2))"]
#[derive(Clone, Debug)]
struct instructionVar7 {
    immediateDest: TableimmediateDest,
    instruction: Box<Tableinstruction>,
}
impl instructionVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                immediateDest,
                instruction,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:542:1, end:542:2))"]
#[derive(Clone, Debug)]
struct instructionVar8 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:556:1, end:556:2))"]
#[derive(Clone, Debug)]
struct instructionVar9 {
    immediateDest: TableimmediateDest,
    instruction: Box<Tableinstruction>,
}
impl instructionVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                immediateDest,
                instruction,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:571:1, end:571:2))"]
#[derive(Clone, Debug)]
struct instructionVar10 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:605:1, end:605:2))"]
#[derive(Clone, Debug)]
struct instructionVar11 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:618:1, end:618:2))"]
#[derive(Clone, Debug)]
struct instructionVar12 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:629:1, end:629:2))"]
#[derive(Clone, Debug)]
struct instructionVar13 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:646:1, end:646:2))"]
#[derive(Clone, Debug)]
struct instructionVar14 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:660:1, end:660:2))"]
#[derive(Clone, Debug)]
struct instructionVar15 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:675:1, end:675:2))"]
#[derive(Clone, Debug)]
struct instructionVar16 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:693:1, end:693:2))"]
#[derive(Clone, Debug)]
struct instructionVar17 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:707:1, end:707:2))"]
#[derive(Clone, Debug)]
struct instructionVar18 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:719:1, end:719:2))"]
#[derive(Clone, Debug)]
struct instructionVar19 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:735:1, end:735:2))"]
#[derive(Clone, Debug)]
struct instructionVar20 {
    immediateDest: TableimmediateDest,
    instruction: Box<Tableinstruction>,
}
impl instructionVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                immediateDest,
                instruction,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:747:1, end:747:2))"]
#[derive(Clone, Debug)]
struct instructionVar21 {
    immediateDest: TableimmediateDest,
    instruction: Box<Tableinstruction>,
}
impl instructionVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                immediateDest,
                instruction,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:763:1, end:763:2))"]
#[derive(Clone, Debug)]
struct instructionVar22 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:778:1, end:778:2))"]
#[derive(Clone, Debug)]
struct instructionVar23 {
    immediateDest: TableimmediateDest,
    instruction: Box<Tableinstruction>,
}
impl instructionVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                immediateDest,
                instruction,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:795:1, end:795:2))"]
#[derive(Clone, Debug)]
struct instructionVar24 {
    immediateDest: TableimmediateDest,
    instruction: Box<Tableinstruction>,
}
impl instructionVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                immediateDest,
                instruction,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:811:1, end:811:2))"]
#[derive(Clone, Debug)]
struct instructionVar25 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:827:1, end:827:2))"]
#[derive(Clone, Debug)]
struct instructionVar26 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:839:1, end:839:2))"]
#[derive(Clone, Debug)]
struct instructionVar27 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:855:1, end:855:2))"]
#[derive(Clone, Debug)]
struct instructionVar28 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:867:1, end:867:2))"]
#[derive(Clone, Debug)]
struct instructionVar29 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:885:1, end:885:2))"]
#[derive(Clone, Debug)]
struct instructionVar30 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:902:1, end:902:2))"]
#[derive(Clone, Debug)]
struct instructionVar31 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:919:1, end:919:2))"]
#[derive(Clone, Debug)]
struct instructionVar32 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:433:1, end:433:2))"]
#[derive(Clone, Debug)]
struct instructionVar33 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:440:1, end:440:2))"]
#[derive(Clone, Debug)]
struct instructionVar34 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_phase(u8::try_from(1i128 & 7).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1012:1, end:1012:2))"]
#[derive(Clone, Debug)]
struct NOP_instructionVar35 {}
impl NOP_instructionVar35 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("NOP"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1876:1, end:1876:2))"]
#[derive(Clone, Debug)]
struct COPR_0_0_instructionVar36 {}
impl COPR_0_0_instructionVar36 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("COPR.0.0"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1007:1, end:1007:2))"]
#[derive(Clone, Debug)]
struct COPY_instructionVar37 {
    R1: TableR1,
    RT: TableRT,
}
impl COPY_instructionVar37 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("COPY"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1399:1, end:1399:2))"]
#[derive(Clone, Debug)]
struct SYNC_instructionVar38 {}
impl SYNC_instructionVar38 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SYNC"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1400:1, end:1400:2))"]
#[derive(Clone, Debug)]
struct SYNCDMA_instructionVar39 {}
impl SYNCDMA_instructionVar39 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SYNCDMA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1359:1, end:1359:2))"]
#[derive(Clone, Debug)]
struct MTSM_instructionVar40 {
    R1: TableR1,
}
impl MTSM_instructionVar40 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MTSM"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1428:1, end:1428:2))"]
#[derive(Clone, Debug)]
struct IITLBT_instructionVar41 {
    R1: TableR1,
    R2: TableR2,
}
impl IITLBT_instructionVar41 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("IITLBT"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1327:1, end:1327:2))"]
#[derive(Clone, Debug)]
struct SSM_instructionVar42 {
    highIm10: u16,
    RT: TableRT,
}
impl SSM_instructionVar42 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SSM"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.highIm10 as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highIm10 = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, highIm10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1343:1, end:1343:2))"]
#[derive(Clone, Debug)]
struct RSM_instructionVar43 {
    highIm10: u16,
    RT: TableRT,
}
impl RSM_instructionVar43 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RSM"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.highIm10 as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highIm10 = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, highIm10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1665:1, end:1665:2))"]
#[derive(Clone, Debug)]
struct FCNVXF_instructionVar44 {
    fixedsf: u8,
    fpdf: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNVXF_instructionVar44 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNVXF"));
        let extend: [DisplayElement; 3usize] = [
            meaning_21_display(self.fixedsf),
            meaning_19_display(self.fpdf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fptsgl = token_55(tokens_current);
        let fpdf = token_15(tokens_current);
        let fixedsf = token_15(tokens_current);
        let freg2sgl = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fixedsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1669:1, end:1669:2))"]
#[derive(Clone, Debug)]
struct FCNVXF_instructionVar45 {
    fixedsf: u8,
    fpdf: u8,
    FPRT64: TableFPRT64,
    FPR264: TableFPR264,
}
impl FCNVXF_instructionVar45 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNVXF"));
        let extend: [DisplayElement; 3usize] = [
            meaning_21_display(self.fixedsf),
            meaning_19_display(self.fpdf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fixedsf = token_15(tokens_current);
        let fpdf = token_15(tokens_current);
        let freg2sgl = token_2(tokens_current);
        let fptsgl = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT64,
                FPR264,
                fixedsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1673:1, end:1673:2))"]
#[derive(Clone, Debug)]
struct FCNVXF_instructionVar46 {
    fixedsf: u8,
    fpdf: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNVXF_instructionVar46 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNVXF"));
        let extend: [DisplayElement; 3usize] = [
            meaning_21_display(self.fixedsf),
            meaning_19_display(self.fpdf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fptsgl = token_55(tokens_current);
        let freg2sgl = token_2(tokens_current);
        let fpdf = token_15(tokens_current);
        let fixedsf = token_15(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fixedsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1677:1, end:1677:2))"]
#[derive(Clone, Debug)]
struct FCNVXF_instructionVar47 {
    fixedsf: u8,
    fpdf: u8,
    FPRT64: TableFPRT64,
    FPR264: TableFPR264,
}
impl FCNVXF_instructionVar47 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNVXF"));
        let extend: [DisplayElement; 3usize] = [
            meaning_21_display(self.fixedsf),
            meaning_19_display(self.fpdf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fixedsf = token_15(tokens_current);
        let fpdf = token_15(tokens_current);
        let fptsgl = token_55(tokens_current);
        let freg2sgl = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT64,
                FPR264,
                fixedsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:80:1, end:80:2))"]
#[derive(Clone, Debug)]
struct LDWAX_instructionVar48 {
    RX: TableRX,
    RB: TableRB,
    SRRB: TableSRRB,
    loadCC: TableloadCC,
    RT: TableRT,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
}
impl LDWAX_instructionVar48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDWAX"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("),")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                RB,
                SRRB,
                loadCC,
                RT,
                indexedWordAccessCmplt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:193:1, end:193:2))"]
#[derive(Clone, Debug)]
struct COPY_instructionVar49 {
    R1dst: TableR1dst,
    RB: TableRB,
}
impl COPY_instructionVar49 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("COPY"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1dst, RB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1424:1, end:1424:2))"]
#[derive(Clone, Debug)]
struct IDTLBA_instructionVar50 {
    SRRB: TableSRRB,
    R1: TableR1,
    SPCBASE: TableSPCBASE,
}
impl IDTLBA_instructionVar50 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("IDTLBA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SRRB, R1, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1426:1, end:1426:2))"]
#[derive(Clone, Debug)]
struct IDTLBP_instructionVar51 {
    SPCBASE: TableSPCBASE,
    R1: TableR1,
    SRRB: TableSRRB,
}
impl IDTLBP_instructionVar51 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("IDTLBP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, R1, SRRB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1431:1, end:1431:2))"]
#[derive(Clone, Debug)]
struct PDC_instructionVar52 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    RX: TableRX,
}
impl PDC_instructionVar52 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PDC"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                SRRB,
                SPCBASE,
                RX,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1432:1, end:1432:2))"]
#[derive(Clone, Debug)]
struct PDC_instructionVar53 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    SRRB: TableSRRB,
}
impl PDC_instructionVar53 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PDC"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                RB,
                SPCBASE,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1369:1, end:1369:2))"]
#[derive(Clone, Debug)]
struct LDSID_instructionVar54 {
    RT: TableRT,
    SR: TableSR,
    SRRB: TableSRRB,
    SRVAL: TableSRVAL,
}
impl LDSID_instructionVar54 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDSID"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR = if let Some((len, table)) =
            TableSR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRVAL = if let Some((len, table)) =
            TableSRVAL::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                SR,
                SRRB,
                SRVAL,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1402:1, end:1402:2))"]
#[derive(Clone, Debug)]
struct PROBER_instructionVar55 {
    RT: TableRT,
    SPCBASE: TableSPCBASE,
    SRRB: TableSRRB,
    R1: TableR1,
}
impl PROBER_instructionVar55 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PROBER"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                SPCBASE,
                SRRB,
                R1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1403:1, end:1403:2))"]
#[derive(Clone, Debug)]
struct PROBERI_instructionVar56 {
    highIm5: u8,
    RT: TableRT,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
}
impl PROBERI_instructionVar56 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PROBERI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.highIm5 & 16 != 0 { -1 & !15 } else { 0 } | self.highIm5 as i8)
                    .is_negative(),
                (if self.highIm5 & 16 != 0 { -1 & !15 } else { 0 } | self.highIm5 as i8).abs()
                    as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highIm5 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                SRRB,
                SPCBASE,
                highIm5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1404:1, end:1404:2))"]
#[derive(Clone, Debug)]
struct PROBEW_instructionVar57 {
    R1: TableR1,
    SRRB: TableSRRB,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl PROBEW_instructionVar57 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PROBEW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                SRRB,
                RT,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1405:1, end:1405:2))"]
#[derive(Clone, Debug)]
struct PROBEWI_instructionVar58 {
    highIm5: u8,
    SRRB: TableSRRB,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl PROBEWI_instructionVar58 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PROBEWI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.highIm5 & 16 != 0 { -1 & !15 } else { 0 } | self.highIm5 as i8)
                    .is_negative(),
                (if self.highIm5 & 16 != 0 { -1 & !15 } else { 0 } | self.highIm5 as i8).abs()
                    as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highIm5 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SPCBASE,
                highIm5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1409:1, end:1409:2))"]
#[derive(Clone, Debug)]
struct LCI_instructionVar59 {
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    RT: TableRT,
}
impl LCI_instructionVar59 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LCI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB,
                SPCBASE,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1411:1, end:1411:2))"]
#[derive(Clone, Debug)]
struct PDTLB_instructionVar60 {
    SPCBASE: TableSPCBASE,
    SRRB3bit: TableSRRB3bit,
    RX: TableRX,
    sysCmplt: TablesysCmplt,
}
impl PDTLB_instructionVar60 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PDTLB"));
        self.sysCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) =
            TableSRRB3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) =
            TablesysCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SPCBASE,
                SRRB3bit,
                RX,
                sysCmplt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1412:1, end:1412:2))"]
#[derive(Clone, Debug)]
struct PDTLB_instructionVar61 {
    RB: TableRB,
    sysCmplt: TablesysCmplt,
    SRRB3bit: TableSRRB3bit,
    SPCBASE: TableSPCBASE,
    RX: TableRX,
}
impl PDTLB_instructionVar61 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PDTLB"));
        self.sysCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) =
            TableSRRB3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) =
            TablesysCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                sysCmplt,
                SRRB3bit,
                SPCBASE,
                RX,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1414:1, end:1414:2))"]
#[derive(Clone, Debug)]
struct PITLB_instructionVar62 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
}
impl PITLB_instructionVar62 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PITLB"));
        self.sysCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) =
            TableSRRB3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) =
            TablesysCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1415:1, end:1415:2))"]
#[derive(Clone, Debug)]
struct PITLB_instructionVar63 {
    RX: TableRX,
    RB: TableRB,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
}
impl PITLB_instructionVar63 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PITLB"));
        self.sysCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) =
            TableSRRB3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) =
            TablesysCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                RB,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1417:1, end:1417:2))"]
#[derive(Clone, Debug)]
struct PDTLBE_instructionVar64 {
    sysCmplt: TablesysCmplt,
    SRRB3bit: TableSRRB3bit,
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl PDTLBE_instructionVar64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PDTLBE"));
        self.sysCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) =
            TableSRRB3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) =
            TablesysCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                sysCmplt,
                SRRB3bit,
                RX,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1418:1, end:1418:2))"]
#[derive(Clone, Debug)]
struct PDTLBE_instructionVar65 {
    SPCBASE: TableSPCBASE,
    RX: TableRX,
    RB: TableRB,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
}
impl PDTLBE_instructionVar65 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PDTLBE"));
        self.sysCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) =
            TableSRRB3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) =
            TablesysCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SPCBASE,
                RX,
                RB,
                SRRB3bit,
                sysCmplt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1420:1, end:1420:2))"]
#[derive(Clone, Debug)]
struct PITLBE_instructionVar66 {
    sysCmplt: TablesysCmplt,
    RX: TableRX,
    SPCBASE: TableSPCBASE,
    SRRB3bit: TableSRRB3bit,
}
impl PITLBE_instructionVar66 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PITLBE"));
        self.sysCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) =
            TableSRRB3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) =
            TablesysCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                sysCmplt,
                RX,
                SPCBASE,
                SRRB3bit,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1421:1, end:1421:2))"]
#[derive(Clone, Debug)]
struct PITLBE_instructionVar67 {
    SPCBASE: TableSPCBASE,
    RB: TableRB,
    RX: TableRX,
    sysCmplt: TablesysCmplt,
    SRRB3bit: TableSRRB3bit,
}
impl PITLBE_instructionVar67 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PITLBE"));
        self.sysCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) =
            TableSRRB3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) =
            TablesysCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SPCBASE,
                RB,
                RX,
                sysCmplt,
                SRRB3bit,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1434:1, end:1434:2))"]
#[derive(Clone, Debug)]
struct FDC_instructionVar68 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
}
impl FDC_instructionVar68 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FDC"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1435:1, end:1435:2))"]
#[derive(Clone, Debug)]
struct FDC_instructionVar69 {
    RX: TableRX,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    SRRB: TableSRRB,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl FDC_instructionVar69 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FDC"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                indexedWordAccessCmplt,
                SRRB,
                RB,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1440:1, end:1440:2))"]
#[derive(Clone, Debug)]
struct FDCE_instructionVar70 {
    SRRB: TableSRRB,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    SPCBASE: TableSPCBASE,
    RX: TableRX,
}
impl FDCE_instructionVar70 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FDCE"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                indexedWordAccessCmplt,
                SPCBASE,
                RX,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1441:1, end:1441:2))"]
#[derive(Clone, Debug)]
struct FDCE_instructionVar71 {
    SPCBASE: TableSPCBASE,
    SRRB: TableSRRB,
    RX: TableRX,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RB: TableRB,
}
impl FDCE_instructionVar71 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FDCE"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SPCBASE,
                SRRB,
                RX,
                indexedWordAccessCmplt,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1881:1, end:1881:2))"]
#[derive(Clone, Debug)]
struct PMENB_instructionVar72 {}
impl PMENB_instructionVar72 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PMENB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1882:1, end:1882:2))"]
#[derive(Clone, Debug)]
struct PMDIS_instructionVar73 {}
impl PMDIS_instructionVar73 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PMDIS"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1407:1, end:1407:2))"]
#[derive(Clone, Debug)]
struct LPA_instructionVar74 {
    SPCBASE: TableSPCBASE,
    RX: TableRX,
    SRRB: TableSRRB,
    sysCmplt: TablesysCmplt,
    RT: TableRT,
}
impl LPA_instructionVar74 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LPA"));
        self.sysCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sysCmplt = if let Some((len, table)) =
            TablesysCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SPCBASE,
                RX,
                SRRB,
                sysCmplt,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1498:1, end:1498:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar75 {
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT64: TableFPRT64,
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadCC: TableloadCC,
    SPCBASE: TableSPCBASE,
}
impl FLDD_instructionVar75 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDD"));
        self.indexedDoublewordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RX,
                FPRT64,
                indexedDoublewordAccessCmplt,
                loadCC,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1503:1, end:1503:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar76 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
}
impl FLDD_instructionVar76 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDD"));
        self.indexedDoublewordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                FPRT64,
                SPCBASE,
                loadCC,
                SRRB,
                RX,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1508:1, end:1508:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar77 {
    SPCBASE: TableSPCBASE,
    SRRB: TableSRRB,
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    RX: TableRX,
    RB: TableRB,
    loadCC: TableloadCC,
    FPRT64: TableFPRT64,
}
impl FLDD_instructionVar77 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDD"));
        self.indexedDoublewordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SPCBASE,
                SRRB,
                indexedDoublewordAccessCmplt,
                RX,
                RB,
                loadCC,
                FPRT64,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1514:1, end:1514:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar78 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    RB: TableRB,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
    RX: TableRX,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
}
impl FLDD_instructionVar78 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDD"));
        self.indexedDoublewordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                RB,
                FPRT64,
                SPCBASE,
                RX,
                loadCC,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1592:1, end:1592:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar79 {
    FPRT64: TableFPRT64,
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    highlse5: Tablehighlse5,
}
impl FLDD_instructionVar79 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDD"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT64,
                shortDispCmplt,
                loadCC,
                SRRB,
                RB,
                SPCBASE,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1598:1, end:1598:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar80 {
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    loadCC: TableloadCC,
    shortDispCmplt: TableshortDispCmplt,
    highlse5: Tablehighlse5,
    FPRT64: TableFPRT64,
    SRRB: TableSRRB,
}
impl FLDD_instructionVar80 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDD"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                SPCBASE,
                loadCC,
                shortDispCmplt,
                highlse5,
                FPRT64,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1626:1, end:1626:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar81 {
    shortDispCmplt: TableshortDispCmplt,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    storeCC: TablestoreCC,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
    SRRB: TableSRRB,
}
impl FSTD_instructionVar81 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTD"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                RB,
                SPCBASE,
                storeCC,
                FPRT64,
                highlse5,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1632:1, end:1632:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar82 {
    SRRB: TableSRRB,
    highlse5: Tablehighlse5,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    FPRT64: TableFPRT64,
}
impl FSTD_instructionVar82 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTD"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                highlse5,
                RB,
                SPCBASE,
                shortDispCmplt,
                storeCC,
                FPRT64,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:144:1, end:144:2))"]
#[derive(Clone, Debug)]
struct STBYS_instructionVar83 {
    lse5: Tablelse5,
    storeBytesShortCmplt: TablestoreBytesShortCmplt,
    SRRB: TableSRRB,
    RR: TableRR,
    storeCC: TablestoreCC,
}
impl STBYS_instructionVar83 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("STBYS"));
        self.storeBytesShortCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let storeBytesShortCmplt = if let Some((len, table)) =
            TablestoreBytesShortCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse5,
                storeBytesShortCmplt,
                SRRB,
                RR,
                storeCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:164:1, end:164:2))"]
#[derive(Clone, Debug)]
struct STBYS_instructionVar84 {
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    lse5: Tablelse5,
    RR: TableRR,
    storeBytesShortCmplt: TablestoreBytesShortCmplt,
}
impl STBYS_instructionVar84 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("STBYS"));
        self.storeBytesShortCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let storeBytesShortCmplt = if let Some((len, table)) =
            TablestoreBytesShortCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeCC,
                SRRB,
                lse5,
                RR,
                storeBytesShortCmplt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1381:1, end:1381:2))"]
#[derive(Clone, Debug)]
struct MTSAR_instructionVar85 {
    R1: TableR1,
}
impl MTSAR_instructionVar85 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MTSAR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let crname2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1296:1, end:1296:2))"]
#[derive(Clone, Debug)]
struct RFI_instructionVar86 {}
impl RFI_instructionVar86 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RFI"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1307:1, end:1307:2))"]
#[derive(Clone, Debug)]
struct RFI_instructionVar87 {}
impl RFI_instructionVar87 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RFI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1373:1, end:1373:2))"]
#[derive(Clone, Debug)]
struct MTSP_instructionVar88 {
    R1: TableR1,
    SR3bit: TableSR3bit,
}
impl MTSP_instructionVar88 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MTSP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SR3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, SR3bit }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1377:1, end:1377:2))"]
#[derive(Clone, Debug)]
struct MTCTL_instructionVar89 {
    crname2: u8,
    R1: TableR1,
}
impl MTCTL_instructionVar89 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MTCTL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.crname2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let crname2 = token_2(tokens_current);
        let cr = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, crname2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1643:1, end:1643:2))"]
#[derive(Clone, Debug)]
struct FCNV_instructionVar90 {
    fpsf: u8,
    fpdf: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNV_instructionVar90 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNV"));
        let extend: [DisplayElement; 3usize] = [
            meaning_19_display(self.fpsf),
            meaning_19_display(self.fpdf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fptsgl = token_55(tokens_current);
        let fpsf = token_21(tokens_current);
        let fpdf = token_15(tokens_current);
        let freg2sgl = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1651:1, end:1651:2))"]
#[derive(Clone, Debug)]
struct FCNV_instructionVar91 {
    fpsf: u8,
    fpdf: u8,
    FPRT64: TableFPRT64,
    FPR264: TableFPR264,
}
impl FCNV_instructionVar91 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNV"));
        let extend: [DisplayElement; 3usize] = [
            meaning_19_display(self.fpsf),
            meaning_19_display(self.fpdf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let freg2sgl = token_2(tokens_current);
        let fpdf = token_15(tokens_current);
        let fptsgl = token_55(tokens_current);
        let fpsf = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT64,
                FPR264,
                fpsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1385:1, end:1385:2))"]
#[derive(Clone, Debug)]
struct MFSP_instructionVar92 {
    SR3bit: TableSR3bit,
    RT: TableRT,
}
impl MFSP_instructionVar92 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MFSP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.SR3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR3bit, RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1389:1, end:1389:2))"]
#[derive(Clone, Debug)]
struct MFCTL_instructionVar93 {
    crname2: u8,
    RT: TableRT,
}
impl MFCTL_instructionVar93 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MFCTL"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.crname2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cr = token_2(tokens_current);
        let crname2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, crname2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1394:1, end:1394:2))"]
#[derive(Clone, Debug)]
struct MFIA_instructionVar94 {
    RT: TableRT,
}
impl MFIA_instructionVar94 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MFIA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1425:1, end:1425:2))"]
#[derive(Clone, Debug)]
struct IITLBA_instructionVar95 {
    RB: TableRB,
    SR3bit: TableSR3bit,
    R1: TableR1,
}
impl IITLBA_instructionVar95 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("IITLBA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",(")];
        display.extend_from_slice(&extend);
        self.SR3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB, SR3bit, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1427:1, end:1427:2))"]
#[derive(Clone, Debug)]
struct IITLBP_instructionVar96 {
    SR3bit: TableSR3bit,
    RB: TableRB,
    R1: TableR1,
}
impl IITLBP_instructionVar96 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("IITLBP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",(")];
        display.extend_from_slice(&extend);
        self.SR3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR3bit, RB, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1125:1, end:1125:2))"]
#[derive(Clone, Debug)]
struct SHRPW_instructionVar97 {
    SEDCondSym: u8,
    RT: TableRT,
    R1: TableR1,
    ShiftCondNullify: TableShiftCondNullify,
    SAR: TableSAR,
    R2: TableR2,
}
impl SHRPW_instructionVar97 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SHRPW"));
        let extend: [DisplayElement; 2usize] = [
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ShiftCondNullify = if let Some((len, table)) =
            TableShiftCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                R1,
                ShiftCondNullify,
                SAR,
                R2,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1147:1, end:1147:2))"]
#[derive(Clone, Debug)]
struct EXTRW_instructionVar98 {
    SEDCondSym: u8,
    SAR: TableSAR,
    shiftCLen: TableshiftCLen,
    R1dst: TableR1dst,
    ExtrCondNullify: TableExtrCondNullify,
    R2: TableR2,
}
impl EXTRW_instructionVar98 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXTRW"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",U"),
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) =
            TableshiftCLen::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ExtrCondNullify = if let Some((len, table)) =
            TableExtrCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SAR,
                shiftCLen,
                R1dst,
                ExtrCondNullify,
                R2,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1157:1, end:1157:2))"]
#[derive(Clone, Debug)]
struct EXTRW_instructionVar99 {
    SEDCondSym: u8,
    R2: TableR2,
    R1dst: TableR1dst,
    SAR: TableSAR,
    shiftCLen: TableshiftCLen,
    ExtrCondNullify: TableExtrCondNullify,
}
impl EXTRW_instructionVar99 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXTRW"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",S"),
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) =
            TableshiftCLen::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ExtrCondNullify = if let Some((len, table)) =
            TableExtrCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                R1dst,
                SAR,
                shiftCLen,
                ExtrCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1187:1, end:1187:2))"]
#[derive(Clone, Debug)]
struct DEPW_instructionVar100 {
    SEDCondSym: u8,
    R2: TableR2,
    shiftCLen: TableshiftCLen,
    DepCondNullify: TableDepCondNullify,
    SAR: TableSAR,
    R1: TableR1,
    R2dst: TableR2dst,
}
impl DEPW_instructionVar100 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEPW"));
        let extend: [DisplayElement; 2usize] = [
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) =
            TableshiftCLen::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                shiftCLen,
                DepCondNullify,
                SAR,
                R1,
                R2dst,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1214:1, end:1214:2))"]
#[derive(Clone, Debug)]
struct DEPWI_instructionVar101 {
    SEDCondSym: u8,
    DepCondNullify: TableDepCondNullify,
    shiftCLen: TableshiftCLen,
    SAR: TableSAR,
    R2dst: TableR2dst,
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl DEPWI_instructionVar101 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEPWI"));
        let extend: [DisplayElement; 2usize] = [
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shiftCLen = if let Some((len, table)) =
            TableshiftCLen::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DepCondNullify,
                shiftCLen,
                SAR,
                R2dst,
                highlse5,
                R2,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1243:1, end:1243:2))"]
#[derive(Clone, Debug)]
struct DEPW_instructionVar102 {
    SEDCondSym: u8,
    DepCondNullify: TableDepCondNullify,
    R2: TableR2,
    shiftCLen: TableshiftCLen,
    R2dst: TableR2dst,
    SAR: TableSAR,
    R1: TableR1,
}
impl DEPW_instructionVar102 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEPW"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",Z"),
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) =
            TableshiftCLen::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DepCondNullify,
                R2,
                shiftCLen,
                R2dst,
                SAR,
                R1,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1263:1, end:1263:2))"]
#[derive(Clone, Debug)]
struct DEPWI_instructionVar103 {
    SEDCondSym: u8,
    shiftCLen: TableshiftCLen,
    highlse5: Tablehighlse5,
    R2dst: TableR2dst,
    SAR: TableSAR,
    DepCondNullify: TableDepCondNullify,
}
impl DEPWI_instructionVar103 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEPWI"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",Z"),
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) =
            TableshiftCLen::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftCLen,
                highlse5,
                R2dst,
                SAR,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1294:1, end:1294:2))"]
#[derive(Clone, Debug)]
struct BREAK_instructionVar104 {
    im5: u8,
    im13: u16,
}
impl BREAK_instructionVar104 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BREAK"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.im5 as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.im13 & 4096 != 0 { -1 & !4095 } else { 0 } | self.im13 as i16)
                    .is_negative(),
                (if self.im13 & 4096 != 0 { -1 & !4095 } else { 0 } | self.im13 as i16).abs()
                    as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let im5 = token_55(tokens_current);
        let im13 = token_12(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im5, im13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1437:1, end:1437:2))"]
#[derive(Clone, Debug)]
struct FIC_instructionVar105 {
    RX: TableRX,
    RB: TableRB,
    SR3bit: TableSR3bit,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
}
impl FIC_instructionVar105 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FIC"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                RB,
                SR3bit,
                indexedWordAccessCmplt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1438:1, end:1438:2))"]
#[derive(Clone, Debug)]
struct FIC_instructionVar106 {
    RB: TableRB,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    SR3bit: TableSR3bit,
    RX: TableRX,
}
impl FIC_instructionVar106 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FIC"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                indexedWordAccessCmplt,
                SR3bit,
                RX,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1443:1, end:1443:2))"]
#[derive(Clone, Debug)]
struct FICE_instructionVar107 {
    RX: TableRX,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    SR3bit: TableSR3bit,
    RB: TableRB,
}
impl FICE_instructionVar107 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FICE"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                indexedWordAccessCmplt,
                SR3bit,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1444:1, end:1444:2))"]
#[derive(Clone, Debug)]
struct FICE_instructionVar108 {
    SR3bit: TableSR3bit,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RB: TableRB,
    RX: TableRX,
}
impl FICE_instructionVar108 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FICE"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SR3bit,
                indexedWordAccessCmplt,
                RB,
                RX,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1587:1, end:1587:2))"]
#[derive(Clone, Debug)]
struct FLDD_instructionVar109 {
    loadCC: TableloadCC,
    highlse5: Tablehighlse5,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    shortDispCmplt: TableshortDispCmplt,
    SRRB: TableSRRB,
}
impl FLDD_instructionVar109 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDD"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                loadCC,
                highlse5,
                SPCBASE,
                FPRT64,
                shortDispCmplt,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1621:1, end:1621:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar110 {
    storeCC: TablestoreCC,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
    SPCBASE: TableSPCBASE,
    shortDispCmplt: TableshortDispCmplt,
    SRRB: TableSRRB,
}
impl FSTD_instructionVar110 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTD"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeCC,
                FPRT64,
                highlse5,
                SPCBASE,
                shortDispCmplt,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1686:1, end:1686:2))"]
#[derive(Clone, Debug)]
struct FCNVFX_instructionVar111 {
    fpsf: u8,
    fixeddf: u8,
    FPRT64: TableFPRT64,
    FPR264: TableFPR264,
}
impl FCNVFX_instructionVar111 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNVFX"));
        let extend: [DisplayElement; 3usize] = [
            meaning_19_display(self.fpsf),
            meaning_21_display(self.fixeddf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let freg2sgl = token_2(tokens_current);
        let fpsf = token_21(tokens_current);
        let fixeddf = token_15(tokens_current);
        let fptsgl = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT64,
                FPR264,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1692:1, end:1692:2))"]
#[derive(Clone, Debug)]
struct FCNVFX_instructionVar112 {
    fpsf: u8,
    fixeddf: u8,
    FPRT64: TableFPRT64,
    FPR264: TableFPR264,
}
impl FCNVFX_instructionVar112 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNVFX"));
        let extend: [DisplayElement; 3usize] = [
            meaning_19_display(self.fpsf),
            meaning_21_display(self.fixeddf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpsf = token_21(tokens_current);
        let freg2sgl = token_2(tokens_current);
        let fixeddf = token_15(tokens_current);
        let fptsgl = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT64,
                FPR264,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1702:1, end:1702:2))"]
#[derive(Clone, Debug)]
struct FCNVFXT_instructionVar113 {
    fpsf: u8,
    fixeddf: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNVFXT_instructionVar113 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNVFXT"));
        let extend: [DisplayElement; 3usize] = [
            meaning_19_display(self.fpsf),
            meaning_21_display(self.fixeddf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpsfraw = token_21(tokens_current);
        let fpsf = token_21(tokens_current);
        let fptsgl = token_55(tokens_current);
        let freg2sgl = token_2(tokens_current);
        let fixeddf = token_15(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1707:1, end:1707:2))"]
#[derive(Clone, Debug)]
struct FCNVFXT_instructionVar114 {
    fpsf: u8,
    fixeddf: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCNVFXT_instructionVar114 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNVFXT"));
        let extend: [DisplayElement; 3usize] = [
            meaning_19_display(self.fpsf),
            meaning_21_display(self.fixeddf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpsf = token_21(tokens_current);
        let fpsfraw = token_21(tokens_current);
        let fptsgl = token_55(tokens_current);
        let fixeddf = token_15(tokens_current);
        let freg2sgl = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:62:1, end:62:2))"]
#[derive(Clone, Debug)]
struct LDW_instructionVar115 {
    RX: TableRX,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    SRRB: TableSRRB,
    loadCC: TableloadCC,
    RT: TableRT,
}
impl LDW_instructionVar115 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDW"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                indexedWordAccessCmplt,
                SRRB,
                loadCC,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:68:1, end:68:2))"]
#[derive(Clone, Debug)]
struct LDH_instructionVar116 {
    RX: TableRX,
    RT: TableRT,
    SRRB: TableSRRB,
    loadCC: TableloadCC,
    indexedHalfwordAccessCmplt: TableindexedHalfwordAccessCmplt,
}
impl LDH_instructionVar116 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDH"));
        self.indexedHalfwordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedHalfwordAccessCmplt = if let Some((len, table)) =
            TableindexedHalfwordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                RT,
                SRRB,
                loadCC,
                indexedHalfwordAccessCmplt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:74:1, end:74:2))"]
#[derive(Clone, Debug)]
struct LDB_instructionVar117 {
    RX: TableRX,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RT: TableRT,
    indexedByteAccessCmplt: TableindexedByteAccessCmplt,
}
impl LDB_instructionVar117 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDB"));
        self.indexedByteAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedByteAccessCmplt = if let Some((len, table)) =
            TableindexedByteAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                loadCC,
                SRRB,
                RT,
                indexedByteAccessCmplt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:85:1, end:85:2))"]
#[derive(Clone, Debug)]
struct LDCWX_instructionVar118 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    RT: TableRT,
    RX: TableRX,
    loadClearCC: TableloadClearCC,
    SRRB: TableSRRB,
}
impl LDCWX_instructionVar118 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDCWX"));
        self.indexedDoublewordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadClearCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadClearCC = if let Some((len, table)) =
            TableloadClearCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                RT,
                RX,
                loadClearCC,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:92:1, end:92:2))"]
#[derive(Clone, Debug)]
struct LDW_instructionVar119 {
    RT: TableRT,
    SRRB: TableSRRB,
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    highlse5: Tablehighlse5,
}
impl LDW_instructionVar119 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDW"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                SRRB,
                shortDispCmplt,
                loadCC,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:98:1, end:98:2))"]
#[derive(Clone, Debug)]
struct LDH_instructionVar120 {
    shortDispCmplt: TableshortDispCmplt,
    RT: TableRT,
    highlse5: Tablehighlse5,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
}
impl LDH_instructionVar120 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDH"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                RT,
                highlse5,
                loadCC,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:104:1, end:104:2))"]
#[derive(Clone, Debug)]
struct LDB_instructionVar121 {
    SRRB: TableSRRB,
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    highlse5: Tablehighlse5,
    RT: TableRT,
}
impl LDB_instructionVar121 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDB"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                shortDispCmplt,
                loadCC,
                highlse5,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:110:1, end:110:2))"]
#[derive(Clone, Debug)]
struct STW_instructionVar122 {
    lse5: Tablelse5,
    SRRB: TableSRRB,
    storeCC: TablestoreCC,
    storeShortDispCmplt: TablestoreShortDispCmplt,
    RR: TableRR,
}
impl STW_instructionVar122 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("STW"));
        self.storeShortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let storeShortDispCmplt = if let Some((len, table)) =
            TablestoreShortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse5,
                SRRB,
                storeCC,
                storeShortDispCmplt,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:116:1, end:116:2))"]
#[derive(Clone, Debug)]
struct STH_instructionVar123 {
    RR: TableRR,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    storeShortDispCmplt: TablestoreShortDispCmplt,
    SRRB: TableSRRB,
}
impl STH_instructionVar123 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("STH"));
        self.storeShortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let storeShortDispCmplt = if let Some((len, table)) =
            TablestoreShortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RR,
                storeCC,
                lse5,
                storeShortDispCmplt,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:122:1, end:122:2))"]
#[derive(Clone, Debug)]
struct STB_instructionVar124 {
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    storeShortDispCmplt: TablestoreShortDispCmplt,
    SRRB: TableSRRB,
    RR: TableRR,
}
impl STB_instructionVar124 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("STB"));
        self.storeShortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let storeShortDispCmplt = if let Some((len, table)) =
            TablestoreShortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeCC,
                lse5,
                storeShortDispCmplt,
                SRRB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:127:1, end:127:2))"]
#[derive(Clone, Debug)]
struct LDWAS_instructionVar125 {
    RB: TableRB,
    RT: TableRT,
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    highlse5: Tablehighlse5,
}
impl LDWAS_instructionVar125 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDWAS"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("),")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                RT,
                shortDispCmplt,
                loadCC,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:132:1, end:132:2))"]
#[derive(Clone, Debug)]
struct LDCWS_instructionVar126 {
    shortDispCmplt: TableshortDispCmplt,
    RT: TableRT,
    loadClearCC: TableloadClearCC,
    SRRB: TableSRRB,
    highlse5: Tablehighlse5,
}
impl LDCWS_instructionVar126 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDCWS"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadClearCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadClearCC = if let Some((len, table)) =
            TableloadClearCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                RT,
                loadClearCC,
                SRRB,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:138:1, end:138:2))"]
#[derive(Clone, Debug)]
struct STWAS_instructionVar127 {
    RR: TableRR,
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    RB: TableRB,
}
impl STWAS_instructionVar127 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("STWAS"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RR,
                shortDispCmplt,
                storeCC,
                lse5,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:247:1, end:247:2))"]
#[derive(Clone, Debug)]
struct B_instructionVar128 {
    nullifyForBranch: TablenullifyForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl B_instructionVar128 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("B"));
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:264:1, end:264:2))"]
#[derive(Clone, Debug)]
struct B_instructionVar129 {
    nullifySymForBranch: TablenullifySymForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl B_instructionVar129 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("B"));
        self.nullifySymForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let nullifySymForBranch = if let Some((len, table)) =
            TablenullifySymForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifySymForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:197:1, end:197:2))"]
#[derive(Clone, Debug)]
struct LDI_instructionVar130 {
    R1dst: TableR1dst,
    lse14: Tablelse14,
}
impl LDI_instructionVar130 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse14
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1dst, lse14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:430:1, end:430:2))"]
#[derive(Clone, Debug)]
struct BV_instructionVar131 {
    nullifyForBranch: TablenullifyForBranch,
    ReturnTarget: TableReturnTarget,
    RB: TableRB,
}
impl BV_instructionVar131 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchIsReturn(
                u8::try_from(i128::try_from(context.read_branchIsReturn()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("BV"));
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ReturnTarget = if let Some((len, table)) =
            TableReturnTarget::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                ReturnTarget,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:447:1, end:447:2))"]
#[derive(Clone, Debug)]
struct BV_instructionVar132 {
    nullifyForBranch: TablenullifyForBranch,
    ReturnTarget: TableReturnTarget,
    RB: TableRB,
}
impl BV_instructionVar132 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BV"));
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ReturnTarget = if let Some((len, table)) =
            TableReturnTarget::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                ReturnTarget,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:409:1, end:409:2))"]
#[derive(Clone, Debug)]
struct BV_instructionVar133 {
    RB: TableRB,
    RX: TableRX,
    IndexedTarget: TableIndexedTarget,
    nullifyForBranch: TablenullifyForBranch,
}
impl BV_instructionVar133 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("BV"));
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let IndexedTarget = if let Some((len, table)) =
            TableIndexedTarget::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                RX,
                IndexedTarget,
                nullifyForBranch,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:423:1, end:423:2))"]
#[derive(Clone, Debug)]
struct BV_instructionVar134 {
    RB: TableRB,
    nullifySymForBranch: TablenullifySymForBranch,
    RX: TableRX,
    IndexedTarget: TableIndexedTarget,
}
impl BV_instructionVar134 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BV"));
        self.nullifySymForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifySymForBranch = if let Some((len, table)) =
            TablenullifySymForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let IndexedTarget = if let Some((len, table)) =
            TableIndexedTarget::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                nullifySymForBranch,
                RX,
                IndexedTarget,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:219:1, end:219:2))"]
#[derive(Clone, Debug)]
struct B_instructionVar135 {
    branchTarget3W: TablebranchTarget3W,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
}
impl B_instructionVar135 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("B"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",L")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                branchTarget3W,
                R2dst,
                nullifyForBranch,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:235:1, end:235:2))"]
#[derive(Clone, Debug)]
struct B_instructionVar136 {
    nullifySymForBranch: TablenullifySymForBranch,
    R2dst: TableR2dst,
    branchTarget3W: TablebranchTarget3W,
}
impl B_instructionVar136 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("B"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",L")];
        display.extend_from_slice(&extend);
        self.nullifySymForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifySymForBranch = if let Some((len, table)) =
            TablenullifySymForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifySymForBranch,
                R2dst,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:387:1, end:387:2))"]
#[derive(Clone, Debug)]
struct BLR_instructionVar137 {
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    IPRelativeIndexedTarget: TableIPRelativeIndexedTarget,
    RR: TableRR,
}
impl BLR_instructionVar137 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("BLR"));
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let IPRelativeIndexedTarget = if let Some((len, table)) =
            TableIPRelativeIndexedTarget::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                IPRelativeIndexedTarget,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:402:1, end:402:2))"]
#[derive(Clone, Debug)]
struct BLR_instructionVar138 {
    nullifySymForBranch: TablenullifySymForBranch,
    IPRelativeIndexedTarget: TableIPRelativeIndexedTarget,
    RR: TableRR,
    R2dst: TableR2dst,
}
impl BLR_instructionVar138 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BLR"));
        self.nullifySymForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifySymForBranch = if let Some((len, table)) =
            TablenullifySymForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let IPRelativeIndexedTarget = if let Some((len, table)) =
            TableIPRelativeIndexedTarget::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifySymForBranch,
                IPRelativeIndexedTarget,
                RR,
                R2dst,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:762:1, end:762:2))"]
#[derive(Clone, Debug)]
struct B_instructionVar139 {
    nullifyForBranch: TablenullifyForBranch,
    R2dst: TableR2dst,
    branchTarget3W: TablebranchTarget3W,
}
impl B_instructionVar139 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("B"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",GATE")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                R2dst,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:776:1, end:776:2))"]
#[derive(Clone, Debug)]
struct B_instructionVar140 {
    branchTarget3W: TablebranchTarget3W,
    nullifyForBranch: TablenullifyForBranch,
    R2dst: TableR2dst,
}
impl B_instructionVar140 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("B"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",GATE")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                branchTarget3W,
                nullifyForBranch,
                R2dst,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:272:1, end:272:2))"]
#[derive(Clone, Debug)]
struct CMPBT_instructionVar141 {
    RegCSCondSym: u8,
    RegCSCond: TableRegCSCond,
    R1: TableR1,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    R2: TableR2,
}
impl CMPBT_instructionVar141 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("CMPBT"));
        let extend: [DisplayElement; 1usize] = [meaning_16_display(self.RegCSCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCond = if let Some((len, table)) =
            TableRegCSCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RegCSCond,
                R1,
                nullifyForBranch,
                branchTarget2W,
                R2,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:285:2, end:285:3))"]
#[derive(Clone, Debug)]
struct CMPBT_instructionVar142 {
    RegCSCondSym: u8,
    nullifyForBranch: TablenullifyForBranch,
    R1: TableR1,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegCSCond: TableRegCSCond,
    R2: TableR2,
}
impl CMPBT_instructionVar142 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("CMPBT"));
        let extend: [DisplayElement; 1usize] = [meaning_16_display(self.RegCSCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCond = if let Some((len, table)) =
            TableRegCSCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                R1,
                branchTarget2W,
                displacement2W,
                RegCSCond,
                R2,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:299:1, end:299:2))"]
#[derive(Clone, Debug)]
struct CMPBF_instructionVar143 {
    RegCSCondSym: u8,
    R1: TableR1,
    RegCSCond: TableRegCSCond,
    nullifyForBranch: TablenullifyForBranch,
    R2: TableR2,
    branchTarget2W: TablebranchTarget2W,
}
impl CMPBF_instructionVar143 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("CMPBF"));
        let extend: [DisplayElement; 1usize] = [meaning_16_display(self.RegCSCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCond = if let Some((len, table)) =
            TableRegCSCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                RegCSCond,
                nullifyForBranch,
                R2,
                branchTarget2W,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:312:1, end:312:2))"]
#[derive(Clone, Debug)]
struct CMPBF_instructionVar144 {
    RegCSCondSym: u8,
    R1: TableR1,
    RegCSCond: TableRegCSCond,
    nullifyForBranch: TablenullifyForBranch,
    displacement2W: Tabledisplacement2W,
    R2: TableR2,
    branchTarget2W: TablebranchTarget2W,
}
impl CMPBF_instructionVar144 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("CMPBF"));
        let extend: [DisplayElement; 1usize] = [meaning_16_display(self.RegCSCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCond = if let Some((len, table)) =
            TableRegCSCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                RegCSCond,
                nullifyForBranch,
                displacement2W,
                R2,
                branchTarget2W,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:329:1, end:329:2))"]
#[derive(Clone, Debug)]
struct CMPIBT_instructionVar145 {
    RegCSCondSym: u8,
    R2: TableR2,
    highlse5: Tablehighlse5,
    branchTarget2W: TablebranchTarget2W,
    RegCSCondI: TableRegCSCondI,
    nullifyForBranch: TablenullifyForBranch,
}
impl CMPIBT_instructionVar145 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("CMPIBT"));
        let extend: [DisplayElement; 1usize] = [meaning_16_display(self.RegCSCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCondI = if let Some((len, table)) =
            TableRegCSCondI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                highlse5,
                branchTarget2W,
                RegCSCondI,
                nullifyForBranch,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:342:1, end:342:2))"]
#[derive(Clone, Debug)]
struct CMPIBT_instructionVar146 {
    RegCSCondSym: u8,
    R2: TableR2,
    highlse5: Tablehighlse5,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegCSCondI: TableRegCSCondI,
    displacement2W: Tabledisplacement2W,
}
impl CMPIBT_instructionVar146 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("CMPIBT"));
        let extend: [DisplayElement; 1usize] = [meaning_16_display(self.RegCSCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCondI = if let Some((len, table)) =
            TableRegCSCondI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                highlse5,
                nullifyForBranch,
                branchTarget2W,
                RegCSCondI,
                displacement2W,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:356:1, end:356:2))"]
#[derive(Clone, Debug)]
struct CMPIBF_instructionVar147 {
    RegCSCondSym: u8,
    R2: TableR2,
    branchTarget2W: TablebranchTarget2W,
    RegCSCondI: TableRegCSCondI,
    nullifyForBranch: TablenullifyForBranch,
    highlse5: Tablehighlse5,
}
impl CMPIBF_instructionVar147 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("CMPIBF"));
        let extend: [DisplayElement; 1usize] = [meaning_16_display(self.RegCSCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCondI = if let Some((len, table)) =
            TableRegCSCondI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                branchTarget2W,
                RegCSCondI,
                nullifyForBranch,
                highlse5,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:369:1, end:369:2))"]
#[derive(Clone, Debug)]
struct CMPIBF_instructionVar148 {
    RegCSCondSym: u8,
    R2: TableR2,
    branchTarget2W: TablebranchTarget2W,
    RegCSCondI: TableRegCSCondI,
    highlse5: Tablehighlse5,
    nullifyForBranch: TablenullifyForBranch,
    displacement2W: Tabledisplacement2W,
}
impl CMPIBF_instructionVar148 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("CMPIBF"));
        let extend: [DisplayElement; 1usize] = [meaning_16_display(self.RegCSCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCondI = if let Some((len, table)) =
            TableRegCSCondI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                branchTarget2W,
                RegCSCondI,
                highlse5,
                nullifyForBranch,
                displacement2W,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:456:1, end:456:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar149 {
    SEDCondSym: u8,
    DepCond: TableDepCond,
    branchTarget2W: TablebranchTarget2W,
    R1: TableR1,
    nullifyForBranch: TablenullifyForBranch,
    R2dst: TableR2dst,
}
impl MOVB_instructionVar149 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("MOVB"));
        let extend: [DisplayElement; 1usize] = [meaning_9_display(self.SEDCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DepCond = if let Some((len, table)) =
            TableDepCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DepCond,
                branchTarget2W,
                R1,
                nullifyForBranch,
                R2dst,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:472:1, end:472:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar150 {
    SEDCondSym: u8,
    R1: TableR1,
    displacement2W: Tabledisplacement2W,
    R2dst: TableR2dst,
    DepCond: TableDepCond,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
}
impl MOVB_instructionVar150 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("MOVB"));
        let extend: [DisplayElement; 1usize] = [meaning_9_display(self.SEDCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DepCond = if let Some((len, table)) =
            TableDepCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                displacement2W,
                R2dst,
                DepCond,
                nullifyForBranch,
                branchTarget2W,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:493:1, end:493:2))"]
#[derive(Clone, Debug)]
struct MOVIB_instructionVar151 {
    SEDCondSym: u8,
    im5: u8,
    branchTarget2W: TablebranchTarget2W,
    nullifyForBranch: TablenullifyForBranch,
    DepCond: TableDepCond,
    R2dst: TableR2dst,
}
impl MOVIB_instructionVar151 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("MOVIB"));
        let extend: [DisplayElement; 1usize] = [meaning_9_display(self.SEDCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.im5 as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DepCond = if let Some((len, table)) =
            TableDepCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let im5 = token_55(tokens_current);
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                branchTarget2W,
                nullifyForBranch,
                DepCond,
                R2dst,
                SEDCondSym,
                im5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:509:1, end:509:2))"]
#[derive(Clone, Debug)]
struct MOVIB_instructionVar152 {
    SEDCondSym: u8,
    im5: u8,
    DepCond: TableDepCond,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
}
impl MOVIB_instructionVar152 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("MOVIB"));
        let extend: [DisplayElement; 1usize] = [meaning_9_display(self.SEDCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.im5 as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DepCond = if let Some((len, table)) =
            TableDepCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let im5 = token_55(tokens_current);
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DepCond,
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                SEDCondSym,
                im5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:527:1, end:527:2))"]
#[derive(Clone, Debug)]
struct ADDBT_instructionVar153 {
    RegAddCondSym: u8,
    RegAddCond: TableRegAddCond,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    R1: TableR1,
    R2: TableR2,
    branchTarget2W: TablebranchTarget2W,
}
impl ADDBT_instructionVar153 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("ADDBT"));
        let extend: [DisplayElement; 1usize] = [meaning_14_display(self.RegAddCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCond = if let Some((len, table)) =
            TableRegAddCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RegAddCond,
                R2dst,
                nullifyForBranch,
                R1,
                R2,
                branchTarget2W,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:542:1, end:542:2))"]
#[derive(Clone, Debug)]
struct ADDBT_instructionVar154 {
    RegAddCondSym: u8,
    R2: TableR2,
    branchTarget2W: TablebranchTarget2W,
    nullifyForBranch: TablenullifyForBranch,
    RegAddCond: TableRegAddCond,
    R1: TableR1,
    displacement2W: Tabledisplacement2W,
    R2dst: TableR2dst,
}
impl ADDBT_instructionVar154 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("ADDBT"));
        let extend: [DisplayElement; 1usize] = [meaning_14_display(self.RegAddCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCond = if let Some((len, table)) =
            TableRegAddCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                branchTarget2W,
                nullifyForBranch,
                RegAddCond,
                R1,
                displacement2W,
                R2dst,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:560:1, end:560:2))"]
#[derive(Clone, Debug)]
struct ADDBF_instructionVar155 {
    RegAddCondSym: u8,
    R2dst: TableR2dst,
    RegAddCond: TableRegAddCond,
    branchTarget2W: TablebranchTarget2W,
    R1: TableR1,
    nullifyForBranch: TablenullifyForBranch,
    R2: TableR2,
}
impl ADDBF_instructionVar155 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("ADDBF"));
        let extend: [DisplayElement; 1usize] = [meaning_14_display(self.RegAddCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCond = if let Some((len, table)) =
            TableRegAddCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                RegAddCond,
                branchTarget2W,
                R1,
                nullifyForBranch,
                R2,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:575:1, end:575:2))"]
#[derive(Clone, Debug)]
struct ADDBF_instructionVar156 {
    RegAddCondSym: u8,
    R2dst: TableR2dst,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    R1: TableR1,
    branchTarget2W: TablebranchTarget2W,
    RegAddCond: TableRegAddCond,
    displacement2W: Tabledisplacement2W,
}
impl ADDBF_instructionVar156 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("ADDBF"));
        let extend: [DisplayElement; 1usize] = [meaning_14_display(self.RegAddCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCond = if let Some((len, table)) =
            TableRegAddCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                R2,
                nullifyForBranch,
                R1,
                branchTarget2W,
                RegAddCond,
                displacement2W,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:592:1, end:592:2))"]
#[derive(Clone, Debug)]
struct ADDIBT_instructionVar157 {
    RegAddCondSym: u8,
    R2: TableR2,
    RegAddCondI: TableRegAddCondI,
    branchTarget2W: TablebranchTarget2W,
    highlse5: Tablehighlse5,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
}
impl ADDIBT_instructionVar157 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("ADDIBT"));
        let extend: [DisplayElement; 1usize] = [meaning_14_display(self.RegAddCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCondI = if let Some((len, table)) =
            TableRegAddCondI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                RegAddCondI,
                branchTarget2W,
                highlse5,
                R2dst,
                nullifyForBranch,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:607:1, end:607:2))"]
#[derive(Clone, Debug)]
struct ADDIBT_instructionVar158 {
    RegAddCondSym: u8,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    RegAddCondI: TableRegAddCondI,
    displacement2W: Tabledisplacement2W,
    highlse5: Tablehighlse5,
    branchTarget2W: TablebranchTarget2W,
    R2dst: TableR2dst,
}
impl ADDIBT_instructionVar158 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("ADDIBT"));
        let extend: [DisplayElement; 1usize] = [meaning_14_display(self.RegAddCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCondI = if let Some((len, table)) =
            TableRegAddCondI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                nullifyForBranch,
                RegAddCondI,
                displacement2W,
                highlse5,
                branchTarget2W,
                R2dst,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:623:1, end:623:2))"]
#[derive(Clone, Debug)]
struct ADDIBF_instructionVar159 {
    RegAddCondSym: u8,
    RegAddCondI: TableRegAddCondI,
    highlse5: Tablehighlse5,
    nullifyForBranch: TablenullifyForBranch,
    R2: TableR2,
    R2dst: TableR2dst,
    branchTarget2W: TablebranchTarget2W,
}
impl ADDIBF_instructionVar159 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("ADDIBF"));
        let extend: [DisplayElement; 1usize] = [meaning_14_display(self.RegAddCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCondI = if let Some((len, table)) =
            TableRegAddCondI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RegAddCondI,
                highlse5,
                nullifyForBranch,
                R2,
                R2dst,
                branchTarget2W,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:638:1, end:638:2))"]
#[derive(Clone, Debug)]
struct ADDIBF_instructionVar160 {
    RegAddCondSym: u8,
    highlse5: Tablehighlse5,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegAddCondI: TableRegAddCondI,
    R2: TableR2,
    displacement2W: Tabledisplacement2W,
}
impl ADDIBF_instructionVar160 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("ADDIBF"));
        let extend: [DisplayElement; 1usize] = [meaning_14_display(self.RegAddCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCondI = if let Some((len, table)) =
            TableRegAddCondI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                RegAddCondI,
                R2,
                displacement2W,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:655:1, end:655:2))"]
#[derive(Clone, Debug)]
struct BB_instructionVar161 {
    SEDCondSym: u8,
    branchTarget2W: TablebranchTarget2W,
    R1: TableR1,
    nullifyForBranch: TablenullifyForBranch,
    BVBCond: TableBVBCond,
    SAR: TableSAR,
}
impl BB_instructionVar161 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("BB"));
        let extend: [DisplayElement; 1usize] = [meaning_9_display(self.SEDCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BVBCond = if let Some((len, table)) =
            TableBVBCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                branchTarget2W,
                R1,
                nullifyForBranch,
                BVBCond,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:668:1, end:668:2))"]
#[derive(Clone, Debug)]
struct BB_instructionVar162 {
    SEDCondSym: u8,
    displacement2W: Tabledisplacement2W,
    SAR: TableSAR,
    R1: TableR1,
    branchTarget2W: TablebranchTarget2W,
    nullifyForBranch: TablenullifyForBranch,
    BVBCond: TableBVBCond,
}
impl BB_instructionVar162 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("BB"));
        let extend: [DisplayElement; 1usize] = [meaning_9_display(self.SEDCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BVBCond = if let Some((len, table)) =
            TableBVBCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                displacement2W,
                SAR,
                R1,
                branchTarget2W,
                nullifyForBranch,
                BVBCond,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:683:1, end:683:2))"]
#[derive(Clone, Debug)]
struct BB_instructionVar163 {
    SEDCondSym: u8,
    bboffset: u8,
    R1: TableR1,
    BBCond: TableBBCond,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
}
impl BB_instructionVar163 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("BB"));
        let extend: [DisplayElement; 1usize] = [meaning_9_display(self.SEDCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.bboffset as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BBCond = if let Some((len, table)) =
            TableBBCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        let bboffset = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                BBCond,
                nullifyForBranch,
                branchTarget2W,
                SEDCondSym,
                bboffset,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:696:1, end:696:2))"]
#[derive(Clone, Debug)]
struct BB_instructionVar164 {
    SEDCondSym: u8,
    bboffset: u8,
    displacement2W: Tabledisplacement2W,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    R1: TableR1,
    BBCond: TableBBCond,
}
impl BB_instructionVar164 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("BB"));
        let extend: [DisplayElement; 1usize] = [meaning_9_display(self.SEDCondSym)];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.bboffset as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.branchTarget2W
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BBCond = if let Some((len, table)) =
            TableBBCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        let bboffset = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                displacement2W,
                nullifyForBranch,
                branchTarget2W,
                R1,
                BBCond,
                SEDCondSym,
                bboffset,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:716:1, end:716:2))"]
#[derive(Clone, Debug)]
struct BE_instructionVar165 {
    externalTarget: TableexternalTarget,
    SR3bit: TableSR3bit,
    nullifyForBranch: TablenullifyForBranch,
}
impl BE_instructionVar165 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("BE"));
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.externalTarget
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let externalTarget = if let Some((len, table)) =
            TableexternalTarget::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                externalTarget,
                SR3bit,
                nullifyForBranch,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:731:1, end:731:2))"]
#[derive(Clone, Debug)]
struct BE_instructionVar166 {
    externalTarget: TableexternalTarget,
    SR3bit: TableSR3bit,
    nullifyForBranch: TablenullifyForBranch,
}
impl BE_instructionVar166 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BE"));
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.externalTarget
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let externalTarget = if let Some((len, table)) =
            TableexternalTarget::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                externalTarget,
                SR3bit,
                nullifyForBranch,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:737:1, end:737:2))"]
#[derive(Clone, Debug)]
struct BE_instructionVar167 {
    externalTarget: TableexternalTarget,
    nullifyForBranch: TablenullifyForBranch,
    R31: TableR31,
    SR3bit: TableSR3bit,
    SR0: TableSR0,
}
impl BE_instructionVar167 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_branchEnable(
                u8::try_from(i128::try_from(context.read_branchEnable()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchType(
                u8::try_from(i128::try_from(context.read_branchType()).unwrap() & 7).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_branchCouldBeNullified(
                u8::try_from(i128::try_from(context.read_branchCouldBeNullified()).unwrap() & 1)
                    .unwrap(),
            )
        });
        display.push(DisplayElement::Literal("BE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",L")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.externalTarget
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SR0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R31
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_branchEnable(u8::try_from(1i128 & 1).unwrap());
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR0 = if let Some((len, table)) =
            TableSR0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R31 = if let Some((len, table)) =
            TableR31::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let externalTarget = if let Some((len, table)) =
            TableexternalTarget::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                externalTarget,
                nullifyForBranch,
                R31,
                SR3bit,
                SR0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:754:1, end:754:2))"]
#[derive(Clone, Debug)]
struct BE_instructionVar168 {
    nullifyForBranch: TablenullifyForBranch,
    SR3bit: TableSR3bit,
    externalTarget: TableexternalTarget,
    R31: TableR31,
    SR0: TableSR0,
}
impl BE_instructionVar168 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",L")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.externalTarget
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SR0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R31
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR0 = if let Some((len, table)) =
            TableSR0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R31 = if let Some((len, table)) =
            TableR31::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let externalTarget = if let Some((len, table)) =
            TableexternalTarget::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                SR3bit,
                externalTarget,
                R31,
                SR0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:790:1, end:790:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar169 {
    AddCondSym: TableAddCondSym,
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
}
impl ADD_instructionVar169 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AddCondSym,
                R1,
                R2,
                RT,
                AddCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:797:1, end:797:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar170 {
    R1: TableR1,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
    R2: TableR2,
}
impl ADD_instructionVar170 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",L")];
        display.extend_from_slice(&extend);
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                RT,
                AddCondNullify,
                AddCondSym,
                R2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:802:1, end:802:2))"]
#[derive(Clone, Debug)]
struct ADDO_instructionVar171 {
    R2: TableR2,
    R1: TableR1,
    RT: TableRT,
    AddCondSym: TableAddCondSym,
    AddCondNullify: TableAddCondNullify,
}
impl ADDO_instructionVar171 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDO"));
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                R1,
                RT,
                AddCondSym,
                AddCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:813:1, end:813:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar172 {
    R2: TableR2,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
    R1: TableR1,
    RT: TableRT,
}
impl ADD_instructionVar172 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",C")];
        display.extend_from_slice(&extend);
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                AddCondNullify,
                AddCondSym,
                R1,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:821:1, end:821:2))"]
#[derive(Clone, Debug)]
struct ADD_instructionVar173 {
    R1: TableR1,
    AddCondNullify: TableAddCondNullify,
    R2: TableR2,
    AddCondSym: TableAddCondSym,
    RT: TableRT,
}
impl ADD_instructionVar173 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",CO")];
        display.extend_from_slice(&extend);
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                AddCondNullify,
                R2,
                AddCondSym,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:840:1, end:840:2))"]
#[derive(Clone, Debug)]
struct SH1ADD_instructionVar174 {
    AddCondNullify: TableAddCondNullify,
    R2: TableR2,
    R1: TableR1,
    RT: TableRT,
    AddCond: TableAddCond,
    AddCondSym: TableAddCondSym,
}
impl SH1ADD_instructionVar174 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SH1ADD"));
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCond = if let Some((len, table)) =
            TableAddCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AddCondNullify,
                R2,
                R1,
                RT,
                AddCond,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:847:1, end:847:2))"]
#[derive(Clone, Debug)]
struct SH1ADDL_instructionVar175 {
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
    RT: TableRT,
    R1: TableR1,
    R2: TableR2,
}
impl SH1ADDL_instructionVar175 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SH1ADDL"));
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AddCondNullify,
                AddCondSym,
                RT,
                R1,
                R2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:853:1, end:853:2))"]
#[derive(Clone, Debug)]
struct SH1ADDO_instructionVar176 {
    SEDCondSym: u8,
    R1: TableR1,
    AddCondNullify: TableAddCondNullify,
    R2: TableR2,
    RT: TableRT,
}
impl SH1ADDO_instructionVar176 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SH1ADDO"));
        let extend: [DisplayElement; 2usize] = [
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                AddCondNullify,
                R2,
                RT,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:865:1, end:865:2))"]
#[derive(Clone, Debug)]
struct SH2ADD_instructionVar177 {
    SEDCondSym: u8,
    R2: TableR2,
    R1: TableR1,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
}
impl SH2ADD_instructionVar177 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SH2ADD"));
        let extend: [DisplayElement; 2usize] = [
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                R1,
                RT,
                AddCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:872:1, end:872:2))"]
#[derive(Clone, Debug)]
struct SH2ADDL_instructionVar178 {
    AddCondNullify: TableAddCondNullify,
    RT: TableRT,
    R2: TableR2,
    AddCondSym: TableAddCondSym,
    R1: TableR1,
}
impl SH2ADDL_instructionVar178 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SH2ADDL"));
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AddCondNullify,
                RT,
                R2,
                AddCondSym,
                R1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:878:1, end:878:2))"]
#[derive(Clone, Debug)]
struct SH2ADDO_instructionVar179 {
    R2: TableR2,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
    R1: TableR1,
    RT: TableRT,
}
impl SH2ADDO_instructionVar179 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SH2ADDO"));
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                AddCondNullify,
                AddCondSym,
                R1,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:890:1, end:890:2))"]
#[derive(Clone, Debug)]
struct SH3ADD_instructionVar180 {
    AddCondSym: TableAddCondSym,
    AddCondNullify: TableAddCondNullify,
    RT: TableRT,
    R2: TableR2,
    R1: TableR1,
}
impl SH3ADD_instructionVar180 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SH3ADD"));
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                AddCondSym,
                AddCondNullify,
                RT,
                R2,
                R1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:897:1, end:897:2))"]
#[derive(Clone, Debug)]
struct SH3ADDL_instructionVar181 {
    RT: TableRT,
    R2: TableR2,
    R1: TableR1,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl SH3ADDL_instructionVar181 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SH3ADDL"));
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                R2,
                R1,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:903:1, end:903:2))"]
#[derive(Clone, Debug)]
struct SH3ADDO_instructionVar182 {
    R2: TableR2,
    R1: TableR1,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl SH3ADDO_instructionVar182 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SH3ADDO"));
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                R1,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:915:1, end:915:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar183 {
    R2: TableR2,
    CSCondNullify: TableCSCondNullify,
    CSCondSym: TableCSCondSym,
    RT: TableRT,
    R1: TableR1,
}
impl SUB_instructionVar183 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        self.CSCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) =
            TableCSCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                CSCondNullify,
                CSCondSym,
                RT,
                R1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:921:1, end:921:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar184 {
    CSCondNullify: TableCSCondNullify,
    RT: TableRT,
    R2: TableR2,
    R1: TableR1,
    CSCondSym: TableCSCondSym,
}
impl SUB_instructionVar184 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",O")];
        display.extend_from_slice(&extend);
        self.CSCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) =
            TableCSCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CSCondNullify,
                RT,
                R2,
                R1,
                CSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:932:1, end:932:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar185 {
    CSCondNullify: TableCSCondNullify,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    R2: TableR2,
    R1: TableR1,
}
impl SUB_instructionVar185 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",B")];
        display.extend_from_slice(&extend);
        self.CSCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) =
            TableCSCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CSCondNullify,
                RT,
                CSCondSym,
                R2,
                R1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:939:1, end:939:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar186 {
    R2: TableR2,
    CSCondNullify: TableCSCondNullify,
    R1: TableR1,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
}
impl SUB_instructionVar186 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",BO")];
        display.extend_from_slice(&extend);
        self.CSCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) =
            TableCSCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                CSCondNullify,
                R1,
                RT,
                CSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:953:1, end:953:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar187 {
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    R2: TableR2,
    R1: TableR1,
    CSCond: TableCSCond,
}
impl SUB_instructionVar187 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",T")];
        display.extend_from_slice(&extend);
        self.CSCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) =
            TableCSCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCond = if let Some((len, table)) =
            TableCSCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                CSCondSym,
                R2,
                R1,
                CSCond,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:964:1, end:964:2))"]
#[derive(Clone, Debug)]
struct SUB_instructionVar188 {
    CSCond: TableCSCond,
    R2: TableR2,
    CSCondSym: TableCSCondSym,
    RT: TableRT,
    R1: TableR1,
}
impl SUB_instructionVar188 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",TO")];
        display.extend_from_slice(&extend);
        self.CSCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) =
            TableCSCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCond = if let Some((len, table)) =
            TableCSCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CSCond,
                R2,
                CSCondSym,
                RT,
                R1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:977:1, end:977:2))"]
#[derive(Clone, Debug)]
struct DS_instructionVar189 {
    RT: TableRT,
    CSCondNullify: TableCSCondNullify,
    R2: TableR2,
    R1: TableR1,
    CSCondSym: TableCSCondSym,
}
impl DS_instructionVar189 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DS"));
        self.CSCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) =
            TableCSCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                CSCondNullify,
                R2,
                R1,
                CSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1000:1, end:1000:2))"]
#[derive(Clone, Debug)]
struct CMPCLR_instructionVar190 {
    CSCondNullify: TableCSCondNullify,
    RT: TableRT,
    R2: TableR2,
    CSCondSym: TableCSCondSym,
    R1: TableR1,
}
impl CMPCLR_instructionVar190 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMPCLR"));
        self.CSCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) =
            TableCSCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CSCondNullify,
                RT,
                R2,
                CSCondSym,
                R1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1014:1, end:1014:2))"]
#[derive(Clone, Debug)]
struct OR_instructionVar191 {
    LogicCondNullify: TableLogicCondNullify,
    RT: TableRT,
    R2: TableR2,
    LogicCondSym: TableLogicCondSym,
    R1: TableR1,
}
impl OR_instructionVar191 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("OR"));
        self.LogicCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let LogicCondSym = if let Some((len, table)) =
            TableLogicCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let LogicCondNullify = if let Some((len, table)) =
            TableLogicCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                LogicCondNullify,
                RT,
                R2,
                LogicCondSym,
                R1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1019:1, end:1019:2))"]
#[derive(Clone, Debug)]
struct XOR_instructionVar192 {
    LogicCondSym: TableLogicCondSym,
    R2: TableR2,
    RT: TableRT,
    R1: TableR1,
    LogicCondNullify: TableLogicCondNullify,
}
impl XOR_instructionVar192 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XOR"));
        self.LogicCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let LogicCondSym = if let Some((len, table)) =
            TableLogicCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let LogicCondNullify = if let Some((len, table)) =
            TableLogicCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                LogicCondSym,
                R2,
                RT,
                R1,
                LogicCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1024:1, end:1024:2))"]
#[derive(Clone, Debug)]
struct AND_instructionVar193 {
    R1: TableR1,
    R2: TableR2,
    LogicCondSym: TableLogicCondSym,
    RT: TableRT,
    LogicCondNullify: TableLogicCondNullify,
}
impl AND_instructionVar193 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("AND"));
        self.LogicCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let LogicCondSym = if let Some((len, table)) =
            TableLogicCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let LogicCondNullify = if let Some((len, table)) =
            TableLogicCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                LogicCondSym,
                RT,
                LogicCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1029:1, end:1029:2))"]
#[derive(Clone, Debug)]
struct ANDCM_instructionVar194 {
    R2: TableR2,
    LogicCondSym: TableLogicCondSym,
    LogicCondNullify: TableLogicCondNullify,
    R1: TableR1,
    RT: TableRT,
}
impl ANDCM_instructionVar194 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANDCM"));
        self.LogicCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let LogicCondSym = if let Some((len, table)) =
            TableLogicCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let LogicCondNullify = if let Some((len, table)) =
            TableLogicCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                LogicCondSym,
                LogicCondNullify,
                R1,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1034:1, end:1034:2))"]
#[derive(Clone, Debug)]
struct UXOR_instructionVar195 {
    R1: TableR1,
    R2: TableR2,
    UnitCondNullify: TableUnitCondNullify,
    UnitCondSym: TableUnitCondSym,
    RT: TableRT,
}
impl UXOR_instructionVar195 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("UXOR"));
        self.UnitCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) =
            TableUnitCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UnitCondNullify = if let Some((len, table)) =
            TableUnitCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                UnitCondNullify,
                UnitCondSym,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1039:1, end:1039:2))"]
#[derive(Clone, Debug)]
struct UADDCM_instructionVar196 {
    R2: TableR2,
    UnitCondSym: TableUnitCondSym,
    RT: TableRT,
    R1: TableR1,
    UnitCondNullify: TableUnitCondNullify,
}
impl UADDCM_instructionVar196 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("UADDCM"));
        self.UnitCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) =
            TableUnitCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UnitCondNullify = if let Some((len, table)) =
            TableUnitCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                UnitCondSym,
                RT,
                R1,
                UnitCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1045:1, end:1045:2))"]
#[derive(Clone, Debug)]
struct UADDCMT_instructionVar197 {
    R2: TableR2,
    UnitCondSym: TableUnitCondSym,
    UnitCond: TableUnitCond,
    RT: TableRT,
    R1: TableR1,
}
impl UADDCMT_instructionVar197 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("UADDCMT"));
        self.UnitCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UnitCond = if let Some((len, table)) =
            TableUnitCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) =
            TableUnitCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                UnitCondSym,
                UnitCond,
                RT,
                R1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1717:1, end:1717:2))"]
#[derive(Clone, Debug)]
struct FCPY_instructionVar198 {
    fpfmt: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCPY_instructionVar198 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCPY"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        let freg2sgl = token_2(tokens_current);
        let fptsgl = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1721:1, end:1721:2))"]
#[derive(Clone, Debug)]
struct FCPY_instructionVar199 {
    fpfmt: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FCPY_instructionVar199 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCPY"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fptsgl = token_55(tokens_current);
        let fpfmt = token_21(tokens_current);
        let freg2sgl = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1776:1, end:1776:2))"]
#[derive(Clone, Debug)]
struct FMPY_instructionVar200 {
    fpfmt: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl FMPY_instructionVar200 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FMPY"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let freg1sgl = token_6(tokens_current);
        let freg2sgl = token_2(tokens_current);
        let fpfmt = token_21(tokens_current);
        let fptsgl = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1780:1, end:1780:2))"]
#[derive(Clone, Debug)]
struct FMPY_instructionVar201 {
    fpfmt: u8,
    FPR164: TableFPR164,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FMPY_instructionVar201 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FMPY"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let freg1sgl = token_6(tokens_current);
        let fptsgl = token_55(tokens_current);
        let fpfmt = token_21(tokens_current);
        let freg2sgl = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR164,
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1752:1, end:1752:2))"]
#[derive(Clone, Debug)]
struct FADD_instructionVar202 {
    fpfmt: u8,
    FPR164: TableFPR164,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FADD_instructionVar202 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FADD"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let freg2sgl = token_2(tokens_current);
        let freg1sgl = token_6(tokens_current);
        let fptsgl = token_55(tokens_current);
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR164,
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1756:1, end:1756:2))"]
#[derive(Clone, Debug)]
struct FADD_instructionVar203 {
    fpfmt: u8,
    FPRT64: TableFPRT64,
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl FADD_instructionVar203 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FADD"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let freg1sgl = token_6(tokens_current);
        let fpfmt = token_21(tokens_current);
        let fptsgl = token_55(tokens_current);
        let freg2sgl = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT64,
                FPR264,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1764:1, end:1764:2))"]
#[derive(Clone, Debug)]
struct FSUB_instructionVar204 {
    fpfmt: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl FSUB_instructionVar204 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSUB"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fptsgl = token_55(tokens_current);
        let freg1sgl = token_6(tokens_current);
        let fpfmt = token_21(tokens_current);
        let freg2sgl = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1768:1, end:1768:2))"]
#[derive(Clone, Debug)]
struct FSUB_instructionVar205 {
    fpfmt: u8,
    FPR164: TableFPR164,
    FPRT64: TableFPRT64,
    FPR264: TableFPR264,
}
impl FSUB_instructionVar205 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSUB"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fptsgl = token_55(tokens_current);
        let freg2sgl = token_2(tokens_current);
        let freg1sgl = token_6(tokens_current);
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR164,
                FPRT64,
                FPR264,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1788:1, end:1788:2))"]
#[derive(Clone, Debug)]
struct FDIV_instructionVar206 {
    fpfmt: u8,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl FDIV_instructionVar206 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FDIV"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        let freg1sgl = token_6(tokens_current);
        let fptsgl = token_55(tokens_current);
        let freg2sgl = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT64,
                FPR164,
                FPR264,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1792:1, end:1792:2))"]
#[derive(Clone, Debug)]
struct FDIV_instructionVar207 {
    fpfmt: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl FDIV_instructionVar207 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FDIV"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let freg1sgl = token_6(tokens_current);
        let fpfmt = token_21(tokens_current);
        let freg2sgl = token_2(tokens_current);
        let fptsgl = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1848:1, end:1848:2))"]
#[derive(Clone, Debug)]
struct FCMP_instructionVar208 {
    fpfmt: u8,
    FPR164: TableFPR164,
    FPR264: TableFPR264,
    fpcmp: Tablefpcmp,
}
impl FCMP_instructionVar208 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCMP"));
        let extend: [DisplayElement; 1usize] = [meaning_19_display(self.fpfmt)];
        display.extend_from_slice(&extend);
        self.fpcmp
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpcmp = if let Some((len, table)) =
            Tablefpcmp::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR164,
                FPR264,
                fpcmp,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1857:1, end:1857:2))"]
#[derive(Clone, Debug)]
struct FCMP_instructionVar209 {
    fpfmt: u8,
    FPR264: TableFPR264,
    fpcmp64: Tablefpcmp64,
    FPR164: TableFPR164,
}
impl FCMP_instructionVar209 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCMP"));
        let extend: [DisplayElement; 1usize] = [meaning_19_display(self.fpfmt)];
        display.extend_from_slice(&extend);
        self.fpcmp64
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpcmp64 = if let Some((len, table)) =
            Tablefpcmp64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                fpcmp64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1136:1, end:1136:2))"]
#[derive(Clone, Debug)]
struct SHRPW_instructionVar210 {
    SEDCondSym: u8,
    R1: TableR1,
    ShiftCondNullify: TableShiftCondNullify,
    R2: TableR2,
    RT: TableRT,
    shiftC: TableshiftC,
}
impl SHRPW_instructionVar210 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SHRPW"));
        let extend: [DisplayElement; 2usize] = [
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftC = if let Some((len, table)) =
            TableshiftC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ShiftCondNullify = if let Some((len, table)) =
            TableShiftCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                ShiftCondNullify,
                R2,
                RT,
                shiftC,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1167:1, end:1167:2))"]
#[derive(Clone, Debug)]
struct EXTRW_instructionVar211 {
    SEDCondSym: u8,
    cp: u8,
    ExtrCondNullify: TableExtrCondNullify,
    R1dst: TableR1dst,
    shiftCLen: TableshiftCLen,
    shiftC: TableshiftC,
    R2: TableR2,
}
impl EXTRW_instructionVar211 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXTRW"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",U"),
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.cp as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shiftCLen
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) =
            TableshiftCLen::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ExtrCondNullify = if let Some((len, table)) =
            TableExtrCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftC = if let Some((len, table)) =
            TableshiftC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        let cp = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ExtrCondNullify,
                R1dst,
                shiftCLen,
                shiftC,
                R2,
                SEDCondSym,
                cp,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1177:1, end:1177:2))"]
#[derive(Clone, Debug)]
struct EXTRW_instructionVar212 {
    SEDCondSym: u8,
    cp: u8,
    shiftC: TableshiftC,
    ExtrCondNullify: TableExtrCondNullify,
    shiftCLen: TableshiftCLen,
    R1dst: TableR1dst,
    R2: TableR2,
}
impl EXTRW_instructionVar212 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXTRW"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",S"),
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.cp as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shiftCLen
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftC = if let Some((len, table)) =
            TableshiftC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) =
            TableshiftCLen::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ExtrCondNullify = if let Some((len, table)) =
            TableExtrCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        let cp = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftC,
                ExtrCondNullify,
                shiftCLen,
                R1dst,
                R2,
                SEDCondSym,
                cp,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1201:1, end:1201:2))"]
#[derive(Clone, Debug)]
struct DEPW_instructionVar213 {
    SEDCondSym: u8,
    shiftCLen: TableshiftCLen,
    shiftC: TableshiftC,
    R2: TableR2,
    R2dst: TableR2dst,
    R1: TableR1,
    DepCondNullify: TableDepCondNullify,
}
impl DEPW_instructionVar213 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEPW"));
        let extend: [DisplayElement; 2usize] = [
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shiftC = if let Some((len, table)) =
            TableshiftC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) =
            TableshiftCLen::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        let cp = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftCLen,
                shiftC,
                R2,
                R2dst,
                R1,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1229:1, end:1229:2))"]
#[derive(Clone, Debug)]
struct DEPWI_instructionVar214 {
    SEDCondSym: u8,
    shiftCLen: TableshiftCLen,
    shiftC: TableshiftC,
    R2dst: TableR2dst,
    R2: TableR2,
    highlse5: Tablehighlse5,
    DepCondNullify: TableDepCondNullify,
}
impl DEPWI_instructionVar214 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEPWI"));
        let extend: [DisplayElement; 2usize] = [
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shiftC = if let Some((len, table)) =
            TableshiftC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) =
            TableshiftCLen::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        let cp = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftCLen,
                shiftC,
                R2dst,
                R2,
                highlse5,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1253:1, end:1253:2))"]
#[derive(Clone, Debug)]
struct DEPW_instructionVar215 {
    SEDCondSym: u8,
    shiftC: TableshiftC,
    shiftCLen: TableshiftCLen,
    R2dst: TableR2dst,
    R1: TableR1,
    DepCondNullify: TableDepCondNullify,
    R2: TableR2,
}
impl DEPW_instructionVar215 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEPW"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",Z"),
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shiftC = if let Some((len, table)) =
            TableshiftC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) =
            TableshiftCLen::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cp = token_41(tokens_current);
        let SEDCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftC,
                shiftCLen,
                R2dst,
                R1,
                DepCondNullify,
                R2,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1274:1, end:1274:2))"]
#[derive(Clone, Debug)]
struct DEPWI_instructionVar216 {
    SEDCondSym: u8,
    shiftCLen: TableshiftCLen,
    highlse5: Tablehighlse5,
    R2dst: TableR2dst,
    shiftC: TableshiftC,
    DepCondNullify: TableDepCondNullify,
}
impl DEPWI_instructionVar216 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEPWI"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",Z"),
            meaning_9_display(self.SEDCondSym),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shiftC = if let Some((len, table)) =
            TableshiftC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) =
            TableshiftCLen::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_13(tokens_current);
        let cp = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftCLen,
                highlse5,
                R2dst,
                shiftC,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1287:1, end:1287:2))"]
#[derive(Clone, Debug)]
struct DCOR_instructionVar217 {
    RT: TableRT,
    R2: TableR2,
    UnitCondSym: TableUnitCondSym,
    UnitCond: TableUnitCond,
}
impl DCOR_instructionVar217 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DCOR"));
        self.UnitCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UnitCond = if let Some((len, table)) =
            TableUnitCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) =
            TableUnitCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                R2,
                UnitCondSym,
                UnitCond,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1288:1, end:1288:2))"]
#[derive(Clone, Debug)]
struct IDCOR_instructionVar218 {
    UnitCondSym: TableUnitCondSym,
    UnitCond: TableUnitCond,
    RT: TableRT,
    R2: TableR2,
}
impl IDCOR_instructionVar218 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("IDCOR"));
        self.UnitCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UnitCond = if let Some((len, table)) =
            TableUnitCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) =
            TableUnitCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                UnitCondSym,
                UnitCond,
                RT,
                R2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1829:1, end:1829:2))"]
#[derive(Clone, Debug)]
struct FCMP_instructionVar219 {
    fpfmt1bit: u8,
    FPR132: TableFPR132,
    fpcmp: Tablefpcmp,
    FPR232: TableFPR232,
}
impl FCMP_instructionVar219 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCMP"));
        let extend: [DisplayElement; 1usize] = [meaning_20_display(self.fpfmt1bit)];
        display.extend_from_slice(&extend);
        self.fpcmp
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpcmp = if let Some((len, table)) =
            Tablefpcmp::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt1bit = token_22(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR132,
                fpcmp,
                FPR232,
                fpfmt1bit,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1838:1, end:1838:2))"]
#[derive(Clone, Debug)]
struct FCMP_instructionVar220 {
    fpfmt1bit: u8,
    FPR132: TableFPR132,
    FPR232: TableFPR232,
    fpcmp64: Tablefpcmp64,
}
impl FCMP_instructionVar220 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCMP"));
        let extend: [DisplayElement; 1usize] = [meaning_20_display(self.fpfmt1bit)];
        display.extend_from_slice(&extend);
        self.fpcmp64
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpcmp64 = if let Some((len, table)) =
            Tablefpcmp64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt1bit = token_22(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR132,
                FPR232,
                fpcmp64,
                fpfmt1bit,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1054:1, end:1054:2))"]
#[derive(Clone, Debug)]
struct ADDI_instructionVar221 {
    R2: TableR2,
    AddCondI11Nullify: TableAddCondI11Nullify,
    R1dst: TableR1dst,
    AddCondSym: TableAddCondSym,
    lse11: Tablelse11,
}
impl ADDI_instructionVar221 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDI"));
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondI11Nullify = if let Some((len, table)) =
            TableAddCondI11Nullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                AddCondI11Nullify,
                R1dst,
                AddCondSym,
                lse11,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1062:1, end:1062:2))"]
#[derive(Clone, Debug)]
struct ADDI_instructionVar222 {
    R2: TableR2,
    R1dst: TableR1dst,
    lse11: Tablelse11,
    AddCondSym: TableAddCondSym,
    AddCondI11Nullify: TableAddCondI11Nullify,
}
impl ADDI_instructionVar222 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",TSV")];
        display.extend_from_slice(&extend);
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondI11Nullify = if let Some((len, table)) =
            TableAddCondI11Nullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                R1dst,
                lse11,
                AddCondSym,
                AddCondI11Nullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1075:1, end:1075:2))"]
#[derive(Clone, Debug)]
struct ADDI_instructionVar223 {
    R1dst: TableR1dst,
    lse11: Tablelse11,
    AddCondI11: TableAddCondI11,
    R2: TableR2,
    AddCondSym: TableAddCondSym,
}
impl ADDI_instructionVar223 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",TC")];
        display.extend_from_slice(&extend);
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondI11 = if let Some((len, table)) =
            TableAddCondI11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1dst,
                lse11,
                AddCondI11,
                R2,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1088:1, end:1088:2))"]
#[derive(Clone, Debug)]
struct ADDI_instructionVar224 {
    lse11: Tablelse11,
    AddCondI11: TableAddCondI11,
    AddCondSym: TableAddCondSym,
    R1dst: TableR1dst,
    R2: TableR2,
}
impl ADDI_instructionVar224 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",TC,TSV")];
        display.extend_from_slice(&extend);
        self.AddCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) =
            TableAddCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let AddCondI11 = if let Some((len, table)) =
            TableAddCondI11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                AddCondI11,
                AddCondSym,
                R1dst,
                R2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1101:1, end:1101:2))"]
#[derive(Clone, Debug)]
struct SUBI_instructionVar225 {
    R1dst: TableR1dst,
    R2: TableR2,
    CSCondSym: TableCSCondSym,
    CSCondI11Nullify: TableCSCondI11Nullify,
    lse11: Tablelse11,
}
impl SUBI_instructionVar225 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBI"));
        self.CSCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondI11Nullify = if let Some((len, table)) =
            TableCSCondI11Nullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) =
            TableCSCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1dst,
                R2,
                CSCondSym,
                CSCondI11Nullify,
                lse11,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1108:1, end:1108:2))"]
#[derive(Clone, Debug)]
struct SUBI_instructionVar226 {
    lse11: Tablelse11,
    CSCondI11: TableCSCondI11,
    CSCondSym: TableCSCondSym,
    R1dst: TableR1dst,
    CSCondI11Nullify: TableCSCondI11Nullify,
    R2: TableR2,
}
impl SUBI_instructionVar226 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",TSV")];
        display.extend_from_slice(&extend);
        self.CSCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondI11 = if let Some((len, table)) =
            TableCSCondI11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) =
            TableCSCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondI11Nullify = if let Some((len, table)) =
            TableCSCondI11Nullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                CSCondI11,
                CSCondSym,
                R1dst,
                CSCondI11Nullify,
                R2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1120:1, end:1120:2))"]
#[derive(Clone, Debug)]
struct CMPICLR_instructionVar227 {
    R2: TableR2,
    R1dst: TableR1dst,
    lse11: Tablelse11,
    CSCondSym: TableCSCondSym,
    CSCondI11Nullify: TableCSCondI11Nullify,
}
impl CMPICLR_instructionVar227 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMPICLR"));
        self.CSCondSym
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondI11Nullify = if let Some((len, table)) =
            TableCSCondI11Nullify::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) =
            TableCSCondSym::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                R1dst,
                lse11,
                CSCondSym,
                CSCondI11Nullify,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1729:1, end:1729:2))"]
#[derive(Clone, Debug)]
struct FABS_instructionVar228 {
    fpfmt: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FABS_instructionVar228 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FABS"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1725:1, end:1725:2))"]
#[derive(Clone, Debug)]
struct FABS_instructionVar229 {
    fpfmt: u8,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FABS_instructionVar229 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FABS"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1713:1, end:1713:2))"]
#[derive(Clone, Debug)]
struct FCPY_instructionVar230 {
    fpfmt: u8,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FCPY_instructionVar230 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCPY"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1733:1, end:1733:2))"]
#[derive(Clone, Debug)]
struct FSQRT_instructionVar231 {
    fpfmt: u8,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FSQRT_instructionVar231 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSQRT"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1736:1, end:1736:2))"]
#[derive(Clone, Debug)]
struct FSQRT_instructionVar232 {
    fpfmt: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FSQRT_instructionVar232 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSQRT"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1639:1, end:1639:2))"]
#[derive(Clone, Debug)]
struct FCNV_instructionVar233 {
    fpsf: u8,
    fpdf: u8,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FCNV_instructionVar233 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNV"));
        let extend: [DisplayElement; 3usize] = [
            meaning_19_display(self.fpsf),
            meaning_19_display(self.fpdf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpsf = token_21(tokens_current);
        let fpdf = token_15(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1659:1, end:1659:2))"]
#[derive(Clone, Debug)]
struct FCNVXF_instructionVar234 {
    fpsf: u8,
    fpdf: u8,
    FPRT32: TableFPRT32,
    FPR232: TableFPR232,
}
impl FCNVXF_instructionVar234 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNVXF"));
        let extend: [DisplayElement; 3usize] = [
            meaning_19_display(self.fpsf),
            meaning_19_display(self.fpdf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpdf = token_15(tokens_current);
        let fpsf = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT32,
                FPR232,
                fpsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1681:1, end:1681:2))"]
#[derive(Clone, Debug)]
struct FCNVFX_instructionVar235 {
    fpsf: u8,
    fixeddf: u8,
    FPRT32: TableFPRT32,
    FPR232: TableFPR232,
}
impl FCNVFX_instructionVar235 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNVFX"));
        let extend: [DisplayElement; 3usize] = [
            meaning_19_display(self.fpsf),
            meaning_21_display(self.fixeddf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fixeddf = token_15(tokens_current);
        let fpsf = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT32,
                FPR232,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1698:1, end:1698:2))"]
#[derive(Clone, Debug)]
struct FCNVFXT_instructionVar236 {
    fpsf: u8,
    fixeddf: u8,
    FPRT32: TableFPRT32,
    FPR232: TableFPR232,
}
impl FCNVFXT_instructionVar236 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FCNVFXT"));
        let extend: [DisplayElement; 3usize] = [
            meaning_19_display(self.fpsf),
            meaning_21_display(self.fixeddf),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fixeddf = token_15(tokens_current);
        let fpsf = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT32,
                FPR232,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1772:1, end:1772:2))"]
#[derive(Clone, Debug)]
struct FMPY_instructionVar237 {
    fpfmt: u8,
    FPRT32: TableFPRT32,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl FMPY_instructionVar237 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FMPY"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT32,
                FPR232,
                FPR132,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1820:1, end:1820:2))"]
#[derive(Clone, Debug)]
struct XMPYU_instructionVar238 {
    fpfmt: u8,
    FPR132: TableFPR132,
    FPRT64: TableFPRT64,
    FPR232: TableFPR232,
}
impl XMPYU_instructionVar238 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XMPYU"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        let fptsgl = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR132,
                FPRT64,
                FPR232,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1740:1, end:1740:2))"]
#[derive(Clone, Debug)]
struct FRND_instructionVar239 {
    fpfmt: u8,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FRND_instructionVar239 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FRND"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1744:1, end:1744:2))"]
#[derive(Clone, Debug)]
struct FRND_instructionVar240 {
    fpfmt: u8,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl FRND_instructionVar240 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FRND"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1748:1, end:1748:2))"]
#[derive(Clone, Debug)]
struct FADD_instructionVar241 {
    fpfmt: u8,
    FPR132: TableFPR132,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl FADD_instructionVar241 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FADD"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR132,
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1760:1, end:1760:2))"]
#[derive(Clone, Debug)]
struct FSUB_instructionVar242 {
    fpfmt: u8,
    FPR132: TableFPR132,
    FPRT32: TableFPRT32,
    FPR232: TableFPR232,
}
impl FSUB_instructionVar242 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSUB"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR132,
                FPRT32,
                FPR232,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1784:1, end:1784:2))"]
#[derive(Clone, Debug)]
struct FDIV_instructionVar243 {
    fpfmt: u8,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    FPRT32: TableFPRT32,
}
impl FDIV_instructionVar243 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FDIV"));
        let extend: [DisplayElement; 2usize] = [
            meaning_19_display(self.fpfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fpfmt = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1866:1, end:1866:2))"]
#[derive(Clone, Debug)]
struct FTEST_instructionVar244 {
    fptest: u8,
}
impl FTEST_instructionVar244 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_nullifyEnable(
                u8::try_from(i128::try_from(context.read_nullifyEnable()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("FTEST"));
        let extend: [DisplayElement; 1usize] = [meaning_18_display(self.fptest)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_nullifyEnable(u8::try_from(1i128 & 1).unwrap());
        let fptest = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fptest }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1452:1, end:1452:2))"]
#[derive(Clone, Debug)]
struct SPOP0_instructionVar245 {
    im15: u16,
    im5: u8,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
}
impl SPOP0_instructionVar245 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_sop: i128 = 0;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| i128::try_from(self.im15).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.im5).unwrap());
        display.push(DisplayElement::Literal("SPOP0"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.nullifyForSpecial
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Number(true, calc_sop.is_negative(), calc_sop.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_sop: i128 = 0;
        let mut block_0_len = 4;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_18(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_55(tokens_current)).unwrap());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let im5 = token_55(tokens_current);
        let im15 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                im15,
                im5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1453:1, end:1453:2))"]
#[derive(Clone, Debug)]
struct SPOP1_instructionVar246 {
    sopim10: u16,
    im5: u8,
    nullifyForSpecial: TablenullifyForSpecial,
    SFU: TableSFU,
}
impl SPOP1_instructionVar246 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_sop: i128 = 0;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.sopim10 & 512 != 0 {
                        -1 & !511
                    } else {
                        0
                    } | self.sopim10 as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(self.im5).unwrap());
        display.push(DisplayElement::Literal("SPOP1"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.nullifyForSpecial
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Number(true, calc_sop.is_negative(), calc_sop.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_sop: i128 = 0;
        let mut block_0_len = 4;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_19(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_55(tokens_current)).unwrap());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sopim10 = token_19(tokens_current);
        let im5 = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForSpecial,
                SFU,
                sopim10,
                im5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1454:1, end:1454:2))"]
#[derive(Clone, Debug)]
struct SPOP2_instructionVar247 {
    sopim5: u8,
    im5: u8,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
    R2: TableR2,
}
impl SPOP2_instructionVar247 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_sop: i128 = 0;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.sopim5 & 16 != 0 { -1 & !15 } else { 0 } | self.sopim5 as i8),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(self.im5).unwrap());
        display.push(DisplayElement::Literal("SPOP2"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.nullifyForSpecial
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Number(true, calc_sop.is_negative(), calc_sop.abs() as u64),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_sop: i128 = 0;
        let mut block_0_len = 4;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_20(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_55(tokens_current)).unwrap());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sopim5 = token_20(tokens_current);
        let im5 = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                R2,
                sopim5,
                im5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1455:1, end:1455:2))"]
#[derive(Clone, Debug)]
struct SPOP3_instructionVar248 {
    sopim5: u8,
    im5: u8,
    nullifyForSpecial: TablenullifyForSpecial,
    SFU: TableSFU,
    R1: TableR1,
    R2: TableR2,
}
impl SPOP3_instructionVar248 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_sop: i128 = 0;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.sopim5 & 16 != 0 { -1 & !15 } else { 0 } | self.sopim5 as i8),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(self.im5).unwrap());
        display.push(DisplayElement::Literal("SPOP3"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.nullifyForSpecial
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Number(true, calc_sop.is_negative(), calc_sop.abs() as u64),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_sop: i128 = 0;
        let mut block_0_len = 4;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_20(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_55(tokens_current)).unwrap());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sopim5 = token_20(tokens_current);
        let im5 = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForSpecial,
                SFU,
                R1,
                R2,
                sopim5,
                im5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1475:1, end:1475:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar249 {
    SRRB: TableSRRB,
    RX: TableRX,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    FPRT32: TableFPRT32,
    loadCC: TableloadCC,
    SPCBASE: TableSPCBASE,
}
impl FLDW_instructionVar249 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDW"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RX,
                indexedWordAccessCmplt,
                FPRT32,
                loadCC,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1480:1, end:1480:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar250 {
    RX: TableRX,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    SPCBASE: TableSPCBASE,
    SRRB: TableSRRB,
    loadCC: TableloadCC,
    FPRT32: TableFPRT32,
}
impl FLDW_instructionVar250 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDW"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                indexedWordAccessCmplt,
                SPCBASE,
                SRRB,
                loadCC,
                FPRT32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1485:1, end:1485:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar251 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    RB: TableRB,
    loadCC: TableloadCC,
    FPRT32: TableFPRT32,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
}
impl FLDW_instructionVar251 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDW"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                RB,
                loadCC,
                FPRT32,
                SRRB,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1491:1, end:1491:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar252 {
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    FPRT32: TableFPRT32,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    RB: TableRB,
}
impl FLDW_instructionVar252 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDW"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB,
                SPCBASE,
                FPRT32,
                indexedWordAccessCmplt,
                loadCC,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1522:1, end:1522:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar253 {
    storeCC: TablestoreCC,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl FSTW_instructionVar253 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTW"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeCC,
                indexedWordAccessCmplt,
                SRRB,
                RX,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1527:1, end:1527:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar254 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    SPCBASE: TableSPCBASE,
    storeCC: TablestoreCC,
    RX: TableRX,
    FPRT32: TableFPRT32,
    SRRB: TableSRRB,
}
impl FSTW_instructionVar254 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTW"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                SPCBASE,
                storeCC,
                RX,
                FPRT32,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1532:1, end:1532:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar255 {
    RX: TableRX,
    storeCC: TablestoreCC,
    RB: TableRB,
    FPRT32: TableFPRT32,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
}
impl FSTW_instructionVar255 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTW"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                storeCC,
                RB,
                FPRT32,
                SRRB,
                SPCBASE,
                indexedWordAccessCmplt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1538:1, end:1538:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar256 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    RB: TableRB,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
}
impl FSTW_instructionVar256 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTW"));
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                RB,
                FPRT32,
                SPCBASE,
                storeCC,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1544:1, end:1544:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar257 {
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
    SRRB: TableSRRB,
    RX: TableRX,
    storeCC: TablestoreCC,
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
}
impl FSTD_instructionVar257 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTD"));
        self.indexedDoublewordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT64,
                SPCBASE,
                SRRB,
                RX,
                storeCC,
                indexedDoublewordAccessCmplt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1549:1, end:1549:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar258 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl FSTD_instructionVar258 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTD"));
        self.indexedDoublewordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1554:1, end:1554:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar259 {
    RB: TableRB,
    storeCC: TablestoreCC,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    SRRB: TableSRRB,
    RX: TableRX,
}
impl FSTD_instructionVar259 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTD"));
        self.indexedDoublewordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                storeCC,
                FPRT64,
                SPCBASE,
                indexedDoublewordAccessCmplt,
                SRRB,
                RX,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1560:1, end:1560:2))"]
#[derive(Clone, Debug)]
struct FSTD_instructionVar260 {
    RX: TableRX,
    FPRT64: TableFPRT64,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    RB: TableRB,
    storeCC: TablestoreCC,
}
impl FSTD_instructionVar260 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTD"));
        self.indexedDoublewordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                FPRT64,
                SRRB,
                SPCBASE,
                indexedDoublewordAccessCmplt,
                RB,
                storeCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1574:1, end:1574:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar261 {
    loadCC: TableloadCC,
    SPCBASE: TableSPCBASE,
    FPRT32: TableFPRT32,
    SRRB: TableSRRB,
    shortDispCmplt: TableshortDispCmplt,
    RB: TableRB,
    highlse5: Tablehighlse5,
}
impl FLDW_instructionVar261 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDW"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                loadCC,
                SPCBASE,
                FPRT32,
                SRRB,
                shortDispCmplt,
                RB,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1581:1, end:1581:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar262 {
    highlse5: Tablehighlse5,
    SPCBASE: TableSPCBASE,
    loadCC: TableloadCC,
    RB: TableRB,
    shortDispCmplt: TableshortDispCmplt,
    SRRB: TableSRRB,
    FPRT32: TableFPRT32,
}
impl FLDW_instructionVar262 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDW"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                SPCBASE,
                loadCC,
                RB,
                shortDispCmplt,
                SRRB,
                FPRT32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1609:1, end:1609:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar263 {
    storeCC: TablestoreCC,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
    FPRT32: TableFPRT32,
    highlse5: Tablehighlse5,
    SRRB: TableSRRB,
    shortDispCmplt: TableshortDispCmplt,
}
impl FSTW_instructionVar263 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTW"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeCC,
                SPCBASE,
                RB,
                FPRT32,
                highlse5,
                SRRB,
                shortDispCmplt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1615:1, end:1615:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar264 {
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
    highlse5: Tablehighlse5,
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
}
impl FSTW_instructionVar264 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTW"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT32,
                SPCBASE,
                RB,
                highlse5,
                shortDispCmplt,
                storeCC,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1568:1, end:1568:2))"]
#[derive(Clone, Debug)]
struct FLDW_instructionVar265 {
    FPRT32: TableFPRT32,
    highlse5: Tablehighlse5,
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SPCBASE: TableSPCBASE,
    SRRB: TableSRRB,
}
impl FLDW_instructionVar265 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FLDW"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT32,
                highlse5,
                shortDispCmplt,
                loadCC,
                SPCBASE,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1604:1, end:1604:2))"]
#[derive(Clone, Debug)]
struct FSTW_instructionVar266 {
    highlse5: Tablehighlse5,
    FPRT32: TableFPRT32,
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
}
impl FSTW_instructionVar266 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FSTW"));
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) =
            TableFPRT32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                FPRT32,
                shortDispCmplt,
                storeCC,
                SRRB,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1458:1, end:1458:2))"]
#[derive(Clone, Debug)]
struct CLDW_instructionVar267 {
    SFU: TableSFU,
    loadCC: TableloadCC,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RT: TableRT,
    RX: TableRX,
    SRRB: TableSRRB,
}
impl CLDW_instructionVar267 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLDW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                loadCC,
                indexedWordAccessCmplt,
                RT,
                RX,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1459:1, end:1459:2))"]
#[derive(Clone, Debug)]
struct CLDD_instructionVar268 {
    SFU: TableSFU,
    RT: TableRT,
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
}
impl CLDD_instructionVar268 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLDD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.indexedDoublewordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                RT,
                indexedDoublewordAccessCmplt,
                loadCC,
                SRRB,
                RX,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1460:1, end:1460:2))"]
#[derive(Clone, Debug)]
struct CSTW_instructionVar269 {
    storeCC: TablestoreCC,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SFU: TableSFU,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl CSTW_instructionVar269 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CSTW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.indexedWordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeCC,
                indexedWordAccessCmplt,
                RX,
                SFU,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1461:1, end:1461:2))"]
#[derive(Clone, Debug)]
struct CSTD_instructionVar270 {
    RT: TableRT,
    SFU: TableSFU,
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    RX: TableRX,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
}
impl CSTD_instructionVar270 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CSTD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.indexedDoublewordAccessCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                SFU,
                indexedDoublewordAccessCmplt,
                RX,
                storeCC,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1463:1, end:1463:2))"]
#[derive(Clone, Debug)]
struct CLDW_instructionVar271 {
    RT: TableRT,
    SFU: TableSFU,
    highlse5: Tablehighlse5,
    loadCC: TableloadCC,
    shortDispCmplt: TableshortDispCmplt,
    SRRB: TableSRRB,
}
impl CLDW_instructionVar271 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLDW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                SFU,
                highlse5,
                loadCC,
                shortDispCmplt,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1464:1, end:1464:2))"]
#[derive(Clone, Debug)]
struct CLDD_instructionVar272 {
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    SFU: TableSFU,
    highlse5: Tablehighlse5,
    shortDispCmplt: TableshortDispCmplt,
    RT: TableRT,
}
impl CLDD_instructionVar272 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLDD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.loadCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) =
            TableloadCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                loadCC,
                SRRB,
                SFU,
                highlse5,
                shortDispCmplt,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1465:1, end:1465:2))"]
#[derive(Clone, Debug)]
struct CSTW_instructionVar273 {
    RT: TableRT,
    shortDispCmplt: TableshortDispCmplt,
    highlse5: Tablehighlse5,
    SFU: TableSFU,
    SRRB: TableSRRB,
    storeCC: TablestoreCC,
}
impl CSTW_instructionVar273 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CSTW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                shortDispCmplt,
                highlse5,
                SFU,
                SRRB,
                storeCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1466:1, end:1466:2))"]
#[derive(Clone, Debug)]
struct CSTD_instructionVar274 {
    shortDispCmplt: TableshortDispCmplt,
    RT: TableRT,
    SFU: TableSFU,
    SRRB: TableSRRB,
    highlse5: Tablehighlse5,
    storeCC: TablestoreCC,
}
impl CSTD_instructionVar274 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CSTD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.shortDispCmplt
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.storeCC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) =
            TablestoreCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                RT,
                SFU,
                SRRB,
                highlse5,
                storeCC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1797:1, end:1797:2))"]
#[derive(Clone, Debug)]
struct FMPYADD_instructionVar275 {
    fusedfmt: u8,
    fpra: u8,
    fpta: u8,
    FPRT64: TableFPRT64,
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl FMPYADD_instructionVar275 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FMPYADD"));
        let extend: [DisplayElement; 2usize] = [
            meaning_22_display(self.fusedfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            meaning_1_display(self.fpra),
            <DisplayElement>::Literal(","),
            meaning_1_display(self.fpta),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fusedfmt = token_42(tokens_current);
        let fpra = token_32(tokens_current);
        let fpta = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPRT64,
                FPR264,
                FPR164,
                fusedfmt,
                fpra,
                fpta,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1803:1, end:1803:2))"]
#[derive(Clone, Debug)]
struct FMPYADD_instructionVar276 {
    fusedfmt: u8,
    FUSEDR2: TableFUSEDR2,
    FUSEDR1: TableFUSEDR1,
    FUSEDRT: TableFUSEDRT,
    FUSEDRA: TableFUSEDRA,
    FUSEDTA: TableFUSEDTA,
}
impl FMPYADD_instructionVar276 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FMPYADD"));
        let extend: [DisplayElement; 2usize] = [
            meaning_22_display(self.fusedfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FUSEDR2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDR1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDRT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDRA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDTA
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FUSEDR2 = if let Some((len, table)) =
            TableFUSEDR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FUSEDR1 = if let Some((len, table)) =
            TableFUSEDR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FUSEDRT = if let Some((len, table)) =
            TableFUSEDRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FUSEDRA = if let Some((len, table)) =
            TableFUSEDRA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FUSEDTA = if let Some((len, table)) =
            TableFUSEDTA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fusedfmt = token_42(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FUSEDR2,
                FUSEDR1,
                FUSEDRT,
                FUSEDRA,
                FUSEDTA,
                fusedfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1809:1, end:1809:2))"]
#[derive(Clone, Debug)]
struct FMPYSUB_instructionVar277 {
    fusedfmt: u8,
    fpra: u8,
    fpta: u8,
    FPR164: TableFPR164,
    FPRT64: TableFPRT64,
    FPR264: TableFPR264,
}
impl FMPYSUB_instructionVar277 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FMPYSUB"));
        let extend: [DisplayElement; 2usize] = [
            meaning_22_display(self.fusedfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            meaning_1_display(self.fpra),
            <DisplayElement>::Literal(","),
            meaning_1_display(self.fpta),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) =
            TableFPRT64::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fusedfmt = token_42(tokens_current);
        let fpra = token_32(tokens_current);
        let fpta = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR164,
                FPRT64,
                FPR264,
                fusedfmt,
                fpra,
                fpta,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1814:1, end:1814:2))"]
#[derive(Clone, Debug)]
struct FMPYSUB_instructionVar278 {
    fusedfmt: u8,
    FUSEDR1: TableFUSEDR1,
    FUSEDRA: TableFUSEDRA,
    FUSEDR2: TableFUSEDR2,
    FUSEDRT: TableFUSEDRT,
    FUSEDTA: TableFUSEDTA,
}
impl FMPYSUB_instructionVar278 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FMPYSUB"));
        let extend: [DisplayElement; 2usize] = [
            meaning_22_display(self.fusedfmt),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FUSEDR2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDR1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDRT
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDRA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDTA
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FUSEDR2 = if let Some((len, table)) =
            TableFUSEDR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FUSEDR1 = if let Some((len, table)) =
            TableFUSEDR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FUSEDRT = if let Some((len, table)) =
            TableFUSEDRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FUSEDRA = if let Some((len, table)) =
            TableFUSEDRA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FUSEDTA = if let Some((len, table)) =
            TableFUSEDTA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fusedfmt = token_42(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FUSEDR1,
                FUSEDRA,
                FUSEDR2,
                FUSEDRT,
                FUSEDTA,
                fusedfmt,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:12:1, end:12:2))"]
#[derive(Clone, Debug)]
struct LDW_instructionVar279 {
    R1dst: TableR1dst,
    OFF_BASE_14: TableOFF_BASE_14,
}
impl LDW_instructionVar279 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE_14 = if let Some((len, table)) =
            TableOFF_BASE_14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1dst, OFF_BASE_14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:17:1, end:17:2))"]
#[derive(Clone, Debug)]
struct LDH_instructionVar280 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1dst: TableR1dst,
}
impl LDH_instructionVar280 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDH"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE_14 = if let Some((len, table)) =
            TableOFF_BASE_14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1dst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:22:1, end:22:2))"]
#[derive(Clone, Debug)]
struct LDB_instructionVar281 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1dst: TableR1dst,
}
impl LDB_instructionVar281 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE_14 = if let Some((len, table)) =
            TableOFF_BASE_14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1dst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:27:1, end:27:2))"]
#[derive(Clone, Debug)]
struct STW_instructionVar282 {
    R1: TableR1,
    OFF_BASE_14: TableOFF_BASE_14,
}
impl STW_instructionVar282 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("STW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE_14 = if let Some((len, table)) =
            TableOFF_BASE_14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, OFF_BASE_14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:32:1, end:32:2))"]
#[derive(Clone, Debug)]
struct STH_instructionVar283 {
    R1: TableR1,
    OFF_BASE_14: TableOFF_BASE_14,
}
impl STH_instructionVar283 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("STH"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let OFF_BASE_14 = if let Some((len, table)) =
            TableOFF_BASE_14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, OFF_BASE_14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:36:1, end:36:2))"]
#[derive(Clone, Debug)]
struct STB_instructionVar284 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1: TableR1,
}
impl STB_instructionVar284 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("STB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE_14 = if let Some((len, table)) =
            TableOFF_BASE_14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:41:1, end:41:2))"]
#[derive(Clone, Debug)]
struct LDW_instructionVar285 {
    RB: TableRB,
    R1dst: TableR1dst,
    OFF_BASE_14: TableOFF_BASE_14,
    lse14: Tablelse14,
    SPCBASE: TableSPCBASE,
}
impl LDW_instructionVar285 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDW"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",M"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE_14 = if let Some((len, table)) =
            TableOFF_BASE_14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                R1dst,
                OFF_BASE_14,
                lse14,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:51:1, end:51:2))"]
#[derive(Clone, Debug)]
struct STW_instructionVar286 {
    OFF_BASE_14: TableOFF_BASE_14,
    RB: TableRB,
    R1: TableR1,
    lse14: Tablelse14,
    SPCBASE: TableSPCBASE,
}
impl STW_instructionVar286 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("STW"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",M"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let OFF_BASE_14 = if let Some((len, table)) =
            TableOFF_BASE_14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                OFF_BASE_14,
                RB,
                R1,
                lse14,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:188:1, end:188:2))"]
#[derive(Clone, Debug)]
struct LDO_instructionVar287 {
    RB: TableRB,
    lse14: Tablelse14,
    R1dst: TableR1dst,
}
impl LDO_instructionVar287 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDO"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse14
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("),")];
        display.extend_from_slice(&extend);
        self.R1dst
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB, lse14, R1dst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:201:1, end:201:2))"]
#[derive(Clone, Debug)]
struct LDIL_instructionVar288 {
    lse21: Tablelse21,
    R2: TableR2,
}
impl LDIL_instructionVar288 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDIL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse21
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse21 = if let Some((len, table)) =
            Tablelse21::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse21, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:207:1, end:207:2))"]
#[derive(Clone, Debug)]
struct ADDIL_instructionVar289 {
    R2: TableR2,
    lse21: Tablelse21,
}
impl ADDIL_instructionVar289 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDIL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse21
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse21 = if let Some((len, table)) =
            Tablelse21::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse21 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1447:1, end:1447:2))"]
#[derive(Clone, Debug)]
struct DIAG_instructionVar290 {
    im26: u32,
}
impl DIAG_instructionVar290 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DIAG"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.im26 & 33554432 != 0 {
                    -1 & !33554431
                } else {
                    0
                } | self.im26 as i32)
                    .is_negative(),
                (if self.im26 & 33554432 != 0 {
                    -1 & !33554431
                } else {
                    0
                } | self.im26 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let im26 = token_47(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im26 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc, start:1456:1, end:1456:2))"]
#[derive(Clone, Debug)]
struct COPR_instructionVar291 {
    sopim17: u32,
    im5: u8,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
}
impl COPR_instructionVar291 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_sop: i128 = 0;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| i128::try_from(self.sopim17).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.im5).unwrap());
        display.push(DisplayElement::Literal("COPR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.SFU
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Number(true, calc_sop.is_negative(), calc_sop.abs() as u64),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForSpecial
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_sop: i128 = 0;
        let mut block_0_len = 4;
        calc_sop = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_25(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_55(tokens_current)).unwrap());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let im5 = token_55(tokens_current);
        let sopim17 = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                sopim17,
                im5,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(instructionVar0),
    Var1(instructionVar1),
    Var2(instructionVar2),
    Var3(instructionVar3),
    Var4(instructionVar4),
    Var5(instructionVar5),
    Var6(instructionVar6),
    Var7(instructionVar7),
    Var8(instructionVar8),
    Var9(instructionVar9),
    Var10(instructionVar10),
    Var11(instructionVar11),
    Var12(instructionVar12),
    Var13(instructionVar13),
    Var14(instructionVar14),
    Var15(instructionVar15),
    Var16(instructionVar16),
    Var17(instructionVar17),
    Var18(instructionVar18),
    Var19(instructionVar19),
    Var20(instructionVar20),
    Var21(instructionVar21),
    Var22(instructionVar22),
    Var23(instructionVar23),
    Var24(instructionVar24),
    Var25(instructionVar25),
    Var26(instructionVar26),
    Var27(instructionVar27),
    Var28(instructionVar28),
    Var29(instructionVar29),
    Var30(instructionVar30),
    Var31(instructionVar31),
    Var32(instructionVar32),
    Var33(instructionVar33),
    Var34(instructionVar34),
    Var35(NOP_instructionVar35),
    Var36(COPR_0_0_instructionVar36),
    Var37(COPY_instructionVar37),
    Var38(SYNC_instructionVar38),
    Var39(SYNCDMA_instructionVar39),
    Var40(MTSM_instructionVar40),
    Var41(IITLBT_instructionVar41),
    Var42(SSM_instructionVar42),
    Var43(RSM_instructionVar43),
    Var44(FCNVXF_instructionVar44),
    Var45(FCNVXF_instructionVar45),
    Var46(FCNVXF_instructionVar46),
    Var47(FCNVXF_instructionVar47),
    Var48(LDWAX_instructionVar48),
    Var49(COPY_instructionVar49),
    Var50(IDTLBA_instructionVar50),
    Var51(IDTLBP_instructionVar51),
    Var52(PDC_instructionVar52),
    Var53(PDC_instructionVar53),
    Var54(LDSID_instructionVar54),
    Var55(PROBER_instructionVar55),
    Var56(PROBERI_instructionVar56),
    Var57(PROBEW_instructionVar57),
    Var58(PROBEWI_instructionVar58),
    Var59(LCI_instructionVar59),
    Var60(PDTLB_instructionVar60),
    Var61(PDTLB_instructionVar61),
    Var62(PITLB_instructionVar62),
    Var63(PITLB_instructionVar63),
    Var64(PDTLBE_instructionVar64),
    Var65(PDTLBE_instructionVar65),
    Var66(PITLBE_instructionVar66),
    Var67(PITLBE_instructionVar67),
    Var68(FDC_instructionVar68),
    Var69(FDC_instructionVar69),
    Var70(FDCE_instructionVar70),
    Var71(FDCE_instructionVar71),
    Var72(PMENB_instructionVar72),
    Var73(PMDIS_instructionVar73),
    Var74(LPA_instructionVar74),
    Var75(FLDD_instructionVar75),
    Var76(FLDD_instructionVar76),
    Var77(FLDD_instructionVar77),
    Var78(FLDD_instructionVar78),
    Var79(FLDD_instructionVar79),
    Var80(FLDD_instructionVar80),
    Var81(FSTD_instructionVar81),
    Var82(FSTD_instructionVar82),
    Var83(STBYS_instructionVar83),
    Var84(STBYS_instructionVar84),
    Var85(MTSAR_instructionVar85),
    Var86(RFI_instructionVar86),
    Var87(RFI_instructionVar87),
    Var88(MTSP_instructionVar88),
    Var89(MTCTL_instructionVar89),
    Var90(FCNV_instructionVar90),
    Var91(FCNV_instructionVar91),
    Var92(MFSP_instructionVar92),
    Var93(MFCTL_instructionVar93),
    Var94(MFIA_instructionVar94),
    Var95(IITLBA_instructionVar95),
    Var96(IITLBP_instructionVar96),
    Var97(SHRPW_instructionVar97),
    Var98(EXTRW_instructionVar98),
    Var99(EXTRW_instructionVar99),
    Var100(DEPW_instructionVar100),
    Var101(DEPWI_instructionVar101),
    Var102(DEPW_instructionVar102),
    Var103(DEPWI_instructionVar103),
    Var104(BREAK_instructionVar104),
    Var105(FIC_instructionVar105),
    Var106(FIC_instructionVar106),
    Var107(FICE_instructionVar107),
    Var108(FICE_instructionVar108),
    Var109(FLDD_instructionVar109),
    Var110(FSTD_instructionVar110),
    Var111(FCNVFX_instructionVar111),
    Var112(FCNVFX_instructionVar112),
    Var113(FCNVFXT_instructionVar113),
    Var114(FCNVFXT_instructionVar114),
    Var115(LDW_instructionVar115),
    Var116(LDH_instructionVar116),
    Var117(LDB_instructionVar117),
    Var118(LDCWX_instructionVar118),
    Var119(LDW_instructionVar119),
    Var120(LDH_instructionVar120),
    Var121(LDB_instructionVar121),
    Var122(STW_instructionVar122),
    Var123(STH_instructionVar123),
    Var124(STB_instructionVar124),
    Var125(LDWAS_instructionVar125),
    Var126(LDCWS_instructionVar126),
    Var127(STWAS_instructionVar127),
    Var128(B_instructionVar128),
    Var129(B_instructionVar129),
    Var130(LDI_instructionVar130),
    Var131(BV_instructionVar131),
    Var132(BV_instructionVar132),
    Var133(BV_instructionVar133),
    Var134(BV_instructionVar134),
    Var135(B_instructionVar135),
    Var136(B_instructionVar136),
    Var137(BLR_instructionVar137),
    Var138(BLR_instructionVar138),
    Var139(B_instructionVar139),
    Var140(B_instructionVar140),
    Var141(CMPBT_instructionVar141),
    Var142(CMPBT_instructionVar142),
    Var143(CMPBF_instructionVar143),
    Var144(CMPBF_instructionVar144),
    Var145(CMPIBT_instructionVar145),
    Var146(CMPIBT_instructionVar146),
    Var147(CMPIBF_instructionVar147),
    Var148(CMPIBF_instructionVar148),
    Var149(MOVB_instructionVar149),
    Var150(MOVB_instructionVar150),
    Var151(MOVIB_instructionVar151),
    Var152(MOVIB_instructionVar152),
    Var153(ADDBT_instructionVar153),
    Var154(ADDBT_instructionVar154),
    Var155(ADDBF_instructionVar155),
    Var156(ADDBF_instructionVar156),
    Var157(ADDIBT_instructionVar157),
    Var158(ADDIBT_instructionVar158),
    Var159(ADDIBF_instructionVar159),
    Var160(ADDIBF_instructionVar160),
    Var161(BB_instructionVar161),
    Var162(BB_instructionVar162),
    Var163(BB_instructionVar163),
    Var164(BB_instructionVar164),
    Var165(BE_instructionVar165),
    Var166(BE_instructionVar166),
    Var167(BE_instructionVar167),
    Var168(BE_instructionVar168),
    Var169(ADD_instructionVar169),
    Var170(ADD_instructionVar170),
    Var171(ADDO_instructionVar171),
    Var172(ADD_instructionVar172),
    Var173(ADD_instructionVar173),
    Var174(SH1ADD_instructionVar174),
    Var175(SH1ADDL_instructionVar175),
    Var176(SH1ADDO_instructionVar176),
    Var177(SH2ADD_instructionVar177),
    Var178(SH2ADDL_instructionVar178),
    Var179(SH2ADDO_instructionVar179),
    Var180(SH3ADD_instructionVar180),
    Var181(SH3ADDL_instructionVar181),
    Var182(SH3ADDO_instructionVar182),
    Var183(SUB_instructionVar183),
    Var184(SUB_instructionVar184),
    Var185(SUB_instructionVar185),
    Var186(SUB_instructionVar186),
    Var187(SUB_instructionVar187),
    Var188(SUB_instructionVar188),
    Var189(DS_instructionVar189),
    Var190(CMPCLR_instructionVar190),
    Var191(OR_instructionVar191),
    Var192(XOR_instructionVar192),
    Var193(AND_instructionVar193),
    Var194(ANDCM_instructionVar194),
    Var195(UXOR_instructionVar195),
    Var196(UADDCM_instructionVar196),
    Var197(UADDCMT_instructionVar197),
    Var198(FCPY_instructionVar198),
    Var199(FCPY_instructionVar199),
    Var200(FMPY_instructionVar200),
    Var201(FMPY_instructionVar201),
    Var202(FADD_instructionVar202),
    Var203(FADD_instructionVar203),
    Var204(FSUB_instructionVar204),
    Var205(FSUB_instructionVar205),
    Var206(FDIV_instructionVar206),
    Var207(FDIV_instructionVar207),
    Var208(FCMP_instructionVar208),
    Var209(FCMP_instructionVar209),
    Var210(SHRPW_instructionVar210),
    Var211(EXTRW_instructionVar211),
    Var212(EXTRW_instructionVar212),
    Var213(DEPW_instructionVar213),
    Var214(DEPWI_instructionVar214),
    Var215(DEPW_instructionVar215),
    Var216(DEPWI_instructionVar216),
    Var217(DCOR_instructionVar217),
    Var218(IDCOR_instructionVar218),
    Var219(FCMP_instructionVar219),
    Var220(FCMP_instructionVar220),
    Var221(ADDI_instructionVar221),
    Var222(ADDI_instructionVar222),
    Var223(ADDI_instructionVar223),
    Var224(ADDI_instructionVar224),
    Var225(SUBI_instructionVar225),
    Var226(SUBI_instructionVar226),
    Var227(CMPICLR_instructionVar227),
    Var228(FABS_instructionVar228),
    Var229(FABS_instructionVar229),
    Var230(FCPY_instructionVar230),
    Var231(FSQRT_instructionVar231),
    Var232(FSQRT_instructionVar232),
    Var233(FCNV_instructionVar233),
    Var234(FCNVXF_instructionVar234),
    Var235(FCNVFX_instructionVar235),
    Var236(FCNVFXT_instructionVar236),
    Var237(FMPY_instructionVar237),
    Var238(XMPYU_instructionVar238),
    Var239(FRND_instructionVar239),
    Var240(FRND_instructionVar240),
    Var241(FADD_instructionVar241),
    Var242(FSUB_instructionVar242),
    Var243(FDIV_instructionVar243),
    Var244(FTEST_instructionVar244),
    Var245(SPOP0_instructionVar245),
    Var246(SPOP1_instructionVar246),
    Var247(SPOP2_instructionVar247),
    Var248(SPOP3_instructionVar248),
    Var249(FLDW_instructionVar249),
    Var250(FLDW_instructionVar250),
    Var251(FLDW_instructionVar251),
    Var252(FLDW_instructionVar252),
    Var253(FSTW_instructionVar253),
    Var254(FSTW_instructionVar254),
    Var255(FSTW_instructionVar255),
    Var256(FSTW_instructionVar256),
    Var257(FSTD_instructionVar257),
    Var258(FSTD_instructionVar258),
    Var259(FSTD_instructionVar259),
    Var260(FSTD_instructionVar260),
    Var261(FLDW_instructionVar261),
    Var262(FLDW_instructionVar262),
    Var263(FSTW_instructionVar263),
    Var264(FSTW_instructionVar264),
    Var265(FLDW_instructionVar265),
    Var266(FSTW_instructionVar266),
    Var267(CLDW_instructionVar267),
    Var268(CLDD_instructionVar268),
    Var269(CSTW_instructionVar269),
    Var270(CSTD_instructionVar270),
    Var271(CLDW_instructionVar271),
    Var272(CLDD_instructionVar272),
    Var273(CSTW_instructionVar273),
    Var274(CSTD_instructionVar274),
    Var275(FMPYADD_instructionVar275),
    Var276(FMPYADD_instructionVar276),
    Var277(FMPYSUB_instructionVar277),
    Var278(FMPYSUB_instructionVar278),
    Var279(LDW_instructionVar279),
    Var280(LDH_instructionVar280),
    Var281(LDB_instructionVar281),
    Var282(STW_instructionVar282),
    Var283(STH_instructionVar283),
    Var284(STB_instructionVar284),
    Var285(LDW_instructionVar285),
    Var286(STW_instructionVar286),
    Var287(LDO_instructionVar287),
    Var288(LDIL_instructionVar288),
    Var289(ADDIL_instructionVar289),
    Var290(DIAG_instructionVar290),
    Var291(COPR_instructionVar291),
}
impl Tableinstruction {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var35(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var36(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var37(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var38(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var39(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var40(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var41(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var42(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var43(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var44(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var45(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var46(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var47(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var48(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var49(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var50(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var51(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var52(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var53(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var54(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var55(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var56(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var57(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var58(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var59(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var60(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var61(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var62(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var63(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var64(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var65(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var66(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var67(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var68(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var69(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var70(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var71(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var72(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var73(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var74(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var75(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var76(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var77(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var78(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var79(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var80(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var81(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var82(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var83(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var84(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var85(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var86(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var87(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var88(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var89(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var90(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var91(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var92(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var93(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var94(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var95(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var96(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var97(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var98(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var99(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var100(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var101(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var102(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var103(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var104(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var105(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var106(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var107(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var108(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var109(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var110(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var111(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var112(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var113(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var114(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var115(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var116(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var117(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var118(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var119(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var120(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var121(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var122(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var123(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var124(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var125(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var126(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var127(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var128(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var129(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var130(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var131(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var132(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var133(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var134(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var135(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var136(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var137(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var138(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var139(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var140(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var141(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var142(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var143(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var144(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var145(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var146(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var147(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var148(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var149(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var150(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var151(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var152(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var153(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var154(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var155(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var156(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var157(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var158(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var159(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var160(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var161(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var162(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var163(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var164(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var165(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var166(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var167(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var168(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var169(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var170(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var171(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var172(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var173(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var174(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var175(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var176(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var177(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var178(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var179(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var180(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var181(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var182(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var183(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var184(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var185(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var186(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var187(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var188(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var189(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var190(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var191(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var192(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var193(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var194(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var195(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var196(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var197(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var198(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var199(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var200(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var201(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var202(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var203(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var204(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var205(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var206(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var207(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var208(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var209(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var210(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var211(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var212(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var213(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var214(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var215(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var216(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var217(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var218(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var219(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var220(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var221(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var222(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var223(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var224(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var225(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var226(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var227(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var228(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var229(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var230(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var231(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var232(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var233(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var234(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var235(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var236(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var237(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var238(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var239(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var240(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var241(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var242(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var243(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var244(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var245(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var246(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var247(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var248(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var249(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var250(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var251(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var252(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var253(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var254(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var255(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var256(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var257(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var258(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var259(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var260(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var261(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var262(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var263(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var264(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var265(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var266(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var267(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var268(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var269(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var270(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var271(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var272(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var273(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var274(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var275(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var276(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var277(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var278(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var279(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var280(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var281(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var282(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var283(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var284(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var285(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var286(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var287(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var288(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var289(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var290(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var291(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && context_param.0 & 2039 == 192 {
            if let Some((inst_len, parsed)) =
                instructionVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 2039 == 1216 {
            if let Some((inst_len, parsed)) =
                instructionVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 96 {
            if let Some((inst_len, parsed)) =
                instructionVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 64 {
            if let Some((inst_len, parsed)) =
                instructionVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 608 {
            if let Some((inst_len, parsed)) =
                instructionVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 576 {
            if let Some((inst_len, parsed)) =
                instructionVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 352 {
            if let Some((inst_len, parsed)) =
                instructionVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 320 {
            if let Some((inst_len, parsed)) =
                instructionVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 864 {
            if let Some((inst_len, parsed)) =
                instructionVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 832 {
            if let Some((inst_len, parsed)) =
                instructionVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 224 {
            if let Some((inst_len, parsed)) =
                instructionVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 736 {
            if let Some((inst_len, parsed)) =
                instructionVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 704 {
            if let Some((inst_len, parsed)) =
                instructionVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 480 {
            if let Some((inst_len, parsed)) =
                instructionVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 448 {
            if let Some((inst_len, parsed)) =
                instructionVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 992 {
            if let Some((inst_len, parsed)) =
                instructionVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 960 {
            if let Some((inst_len, parsed)) =
                instructionVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 112 {
            if let Some((inst_len, parsed)) =
                instructionVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 80 {
            if let Some((inst_len, parsed)) =
                instructionVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 624 {
            if let Some((inst_len, parsed)) =
                instructionVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 592 {
            if let Some((inst_len, parsed)) =
                instructionVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 368 {
            if let Some((inst_len, parsed)) =
                instructionVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 336 {
            if let Some((inst_len, parsed)) =
                instructionVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 880 {
            if let Some((inst_len, parsed)) =
                instructionVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 848 {
            if let Some((inst_len, parsed)) =
                instructionVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 240 {
            if let Some((inst_len, parsed)) =
                instructionVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 208 {
            if let Some((inst_len, parsed)) =
                instructionVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 752 {
            if let Some((inst_len, parsed)) =
                instructionVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 720 {
            if let Some((inst_len, parsed)) =
                instructionVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 496 {
            if let Some((inst_len, parsed)) =
                instructionVar29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 464 {
            if let Some((inst_len, parsed)) =
                instructionVar30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 1008 {
            if let Some((inst_len, parsed)) =
                instructionVar31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1015 == 976 {
            if let Some((inst_len, parsed)) =
                instructionVar32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 87 == 0 {
            if let Some((inst_len, parsed)) =
                instructionVar33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 87 == 16 {
            if let Some((inst_len, parsed)) =
                instructionVar34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 2
            && (tokens_param[3] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                NOP_instructionVar35::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var35(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                COPR_0_0_instructionVar36::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var36(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 255) == 2
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                COPY_instructionVar37::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var37(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[1] & 16) == 0
            && (tokens_param[2] & 255) == 4
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                SYNC_instructionVar38::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var38(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[1] & 16) == 16
            && (tokens_param[2] & 255) == 4
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                SYNCDMA_instructionVar39::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var39(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[2] & 255) == 24
            && (tokens_param[3] & 255) == 96
        {
            if let Some((inst_len, parsed)) =
                MTSM_instructionVar40::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var40(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 255) == 8
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                IITLBT_instructionVar41::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var41(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[2] & 255) == 13
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                SSM_instructionVar42::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var42(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[2] & 255) == 14
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                RSM_instructionVar43::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var43(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 255) == 130
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                FCNVXF_instructionVar44::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var44(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 255) == 162
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                FCNVXF_instructionVar45::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var45(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 255) == 138
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                FCNVXF_instructionVar46::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var46(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 255) == 170
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                FCNVXF_instructionVar47::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var47(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 211) == 1
            && (tokens_param[3] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                LDWAX_instructionVar48::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var48(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 52
            && (tokens_param[2] & 63) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                COPY_instructionVar49::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var49(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 16
            && (tokens_param[3] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                IDTLBA_instructionVar50::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var50(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 16
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                IDTLBP_instructionVar51::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var51(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 19
            && (tokens_param[3] & 255) == 128
        {
            if let Some((inst_len, parsed)) =
                PDC_instructionVar52::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var52(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 19
            && (tokens_param[3] & 255) == 160
        {
            if let Some((inst_len, parsed)) =
                PDC_instructionVar53::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var53(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[2] & 63) == 16
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                LDSID_instructionVar54::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var54(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 17
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                PROBER_instructionVar55::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var55(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 49
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                PROBERI_instructionVar56::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var56(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 17
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                PROBEW_instructionVar57::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var57(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 49
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                PROBEWI_instructionVar58::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var58(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 19
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                LCI_instructionVar59::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var59(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 18
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                PDTLB_instructionVar60::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var60(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 18
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                PDTLB_instructionVar61::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var61(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 2
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                PITLB_instructionVar62::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var62(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 2
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                PITLB_instructionVar63::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var63(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 18
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                PDTLBE_instructionVar64::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var64(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 18
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                PDTLBE_instructionVar65::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var65(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 2
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                PITLBE_instructionVar66::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var66(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 2
            && (tokens_param[3] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                PITLBE_instructionVar67::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var67(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 18
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                FDC_instructionVar68::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var68(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 18
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                FDC_instructionVar69::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var69(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 18
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                FDCE_instructionVar70::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var70(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 18
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                FDCE_instructionVar71::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var71(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 63) == 6
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                PMENB_instructionVar72::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var72(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 63) == 2
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                PMDIS_instructionVar73::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var73(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 63) == 19
            && (tokens_param[3] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                LPA_instructionVar74::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var74(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 51) == 0
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                FLDD_instructionVar75::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var75(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 51) == 32
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                FLDD_instructionVar76::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var76(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 51) == 0
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                FLDD_instructionVar77::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var77(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 51) == 32
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                FLDD_instructionVar78::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var78(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 51) == 16
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                FLDD_instructionVar79::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var79(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 51) == 48
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                FLDD_instructionVar80::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var80(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 51) == 18
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                FSTD_instructionVar81::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var81(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 51) == 50
            && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                FSTD_instructionVar82::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var82(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 51) == 19
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                STBYS_instructionVar83::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var83(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 51) == 51
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                STBYS_instructionVar84::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var84(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 224) == 96
            && (tokens_param[2] & 31) == 24
            && (tokens_param[3] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                MTSAR_instructionVar85::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var85(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[2] & 31) == 12
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                RFI_instructionVar86::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var86(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[2] & 31) == 12
            && (tokens_param[3] & 255) == 160
        {
            if let Some((inst_len, parsed)) =
                RFI_instructionVar87::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var87(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[2] & 31) == 24
            && (tokens_param[3] & 255) == 32
        {
            if let Some((inst_len, parsed)) =
                MTSP_instructionVar88::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var88(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[2] & 31) == 24
            && (tokens_param[3] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                MTCTL_instructionVar89::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var89(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 159) == 2
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                FCNV_instructionVar90::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var90(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 159) == 10
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                FCNV_instructionVar91::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var91(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 31) == 4
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                MFSP_instructionVar92::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var92(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 31) == 8
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                MFCTL_instructionVar93::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var93(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 31) == 20
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                MFIA_instructionVar94::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var94(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 255) == 64
        {
            if let Some((inst_len, parsed)) =
                IITLBA_instructionVar95::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var95(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                IITLBP_instructionVar96::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var96(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 208
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                SHRPW_instructionVar97::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var97(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 208
            && (tokens_param[2] & 31) == 16
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                EXTRW_instructionVar98::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var98(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 208
            && (tokens_param[2] & 31) == 20
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                EXTRW_instructionVar99::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var99(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 212
            && (tokens_param[2] & 31) == 4
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                DEPW_instructionVar100::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var100(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 212
            && (tokens_param[2] & 31) == 20
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                DEPWI_instructionVar101::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var101(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 212
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                DEPW_instructionVar102::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var102(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 212
            && (tokens_param[2] & 31) == 16
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                DEPWI_instructionVar103::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var103(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                BREAK_instructionVar104::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var104(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 31) == 2
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                FIC_instructionVar105::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var105(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 31) == 2
            && (tokens_param[3] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                FIC_instructionVar106::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var106(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 31) == 2
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                FICE_instructionVar107::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var107(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 4
            && (tokens_param[2] & 31) == 2
            && (tokens_param[3] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                FICE_instructionVar108::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var108(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 19) == 16
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                FLDD_instructionVar109::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var109(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 19) == 18
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                FSTD_instructionVar110::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var110(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 1
            && (tokens_param[2] & 159) == 10
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                FCNVFX_instructionVar111::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var111(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 1
            && (tokens_param[2] & 159) == 2
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                FCNVFX_instructionVar112::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var112(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 1
            && (tokens_param[2] & 159) == 138
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                FCNVFXT_instructionVar113::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var113(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 1
            && (tokens_param[2] & 159) == 130
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                FCNVFXT_instructionVar114::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var114(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 0
            && (tokens_param[3] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                LDW_instructionVar115::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var115(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 0
            && (tokens_param[3] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                LDH_instructionVar116::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var116(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 0
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                LDB_instructionVar117::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var117(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 1
            && (tokens_param[3] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                LDCWX_instructionVar118::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var118(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 16
            && (tokens_param[3] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                LDW_instructionVar119::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var119(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 16
            && (tokens_param[3] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                LDH_instructionVar120::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var120(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 16
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                LDB_instructionVar121::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var121(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 18
            && (tokens_param[3] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                STW_instructionVar122::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var122(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 18
            && (tokens_param[3] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                STH_instructionVar123::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var123(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 18
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                STB_instructionVar124::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var124(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 17
            && (tokens_param[3] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                LDWAS_instructionVar125::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var125(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 17
            && (tokens_param[3] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                LDCWS_instructionVar126::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var126(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 12
            && (tokens_param[2] & 19) == 19
            && (tokens_param[3] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                STWAS_instructionVar127::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var127(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 255) == 232
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                B_instructionVar128::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var128(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 255) == 232
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                B_instructionVar129::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var129(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 255) == 52
            && (tokens_param[1] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                LDI_instructionVar130::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var130(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 232
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 3) == 0
        {
            if let Some((inst_len, parsed)) =
                BV_instructionVar131::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var131(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 232
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 3) == 2
        {
            if let Some((inst_len, parsed)) =
                BV_instructionVar132::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var132(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 232
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 3) == 0
        {
            if let Some((inst_len, parsed)) =
                BV_instructionVar133::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var133(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 232
            && (tokens_param[2] & 224) == 192
            && (tokens_param[3] & 3) == 2
        {
            if let Some((inst_len, parsed)) =
                BV_instructionVar134::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var134(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 232
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                B_instructionVar135::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var135(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 232
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                B_instructionVar136::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var136(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 232
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                BLR_instructionVar137::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var137(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 232
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                BLR_instructionVar138::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var138(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 232
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                B_instructionVar139::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var139(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 232
            && (tokens_param[2] & 224) == 32
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                B_instructionVar140::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var140(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 128
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                CMPBT_instructionVar141::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var141(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 128
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                CMPBT_instructionVar142::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var142(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 136
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                CMPBF_instructionVar143::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var143(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 136
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                CMPBF_instructionVar144::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var144(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 132
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                CMPIBT_instructionVar145::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var145(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 132
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                CMPIBT_instructionVar146::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var146(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 140
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                CMPIBF_instructionVar147::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var147(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 140
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                CMPIBF_instructionVar148::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var148(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 200
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                MOVB_instructionVar149::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var149(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 200
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                MOVB_instructionVar150::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var150(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 204
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                MOVIB_instructionVar151::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var151(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 204
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                MOVIB_instructionVar152::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var152(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 160
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                ADDBT_instructionVar153::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var153(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 160
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                ADDBT_instructionVar154::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var154(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 168
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                ADDBF_instructionVar155::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var155(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 168
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                ADDBF_instructionVar156::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var156(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 164
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                ADDIBT_instructionVar157::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var157(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 164
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                ADDIBT_instructionVar158::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var158(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 172
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                ADDIBF_instructionVar159::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var159(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 172
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                ADDIBF_instructionVar160::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var160(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 192
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                BB_instructionVar161::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var161(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 192
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                BB_instructionVar162::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var162(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 196
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                BB_instructionVar163::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var163(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 196
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                BB_instructionVar164::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var164(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 224
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                BE_instructionVar165::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var165(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 224
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                BE_instructionVar166::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var166(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 228
            && (tokens_param[3] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                BE_instructionVar167::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var167(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 228
            && (tokens_param[3] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                BE_instructionVar168::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var168(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 6
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar169::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var169(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 10
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar170::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var170(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 14
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                ADDO_instructionVar171::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var171(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 7
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar172::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var172(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                ADD_instructionVar173::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var173(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 6
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                SH1ADD_instructionVar174::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var174(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 10
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                SH1ADDL_instructionVar175::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var175(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 14
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                SH1ADDO_instructionVar176::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var176(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 6
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                SH2ADD_instructionVar177::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var177(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 10
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                SH2ADDL_instructionVar178::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var178(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 14
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                SH2ADDO_instructionVar179::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var179(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 6
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                SH3ADD_instructionVar180::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var180(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 10
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                SH3ADDL_instructionVar181::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var181(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 14
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                SH3ADDO_instructionVar182::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var182(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 4
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar183::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var183(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 12
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar184::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var184(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 5
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar185::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var185(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 13
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar186::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var186(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 4
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar187::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var187(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 12
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                SUB_instructionVar188::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var188(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 4
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                DS_instructionVar189::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var189(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 8
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                CMPCLR_instructionVar190::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var190(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 2
            && (tokens_param[3] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                OR_instructionVar191::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var191(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 2
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                XOR_instructionVar192::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var192(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 2
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                AND_instructionVar193::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var193(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                ANDCM_instructionVar194::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var194(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 3
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                UXOR_instructionVar195::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var195(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 9
            && (tokens_param[3] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                UADDCM_instructionVar196::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var196(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[2] & 15) == 9
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                UADDCMT_instructionVar197::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var197(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 254) == 72
        {
            if let Some((inst_len, parsed)) =
                FCPY_instructionVar198::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var198(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 254) == 64
        {
            if let Some((inst_len, parsed)) =
                FCPY_instructionVar199::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var199(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                FMPY_instructionVar200::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var200(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 255) == 78
        {
            if let Some((inst_len, parsed)) =
                FMPY_instructionVar201::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var201(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 254) == 6
        {
            if let Some((inst_len, parsed)) =
                FADD_instructionVar202::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var202(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 254) == 14
        {
            if let Some((inst_len, parsed)) =
                FADD_instructionVar203::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var203(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 254) == 38
        {
            if let Some((inst_len, parsed)) =
                FSUB_instructionVar204::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var204(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 254) == 46
        {
            if let Some((inst_len, parsed)) =
                FSUB_instructionVar205::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var205(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 254) == 102
        {
            if let Some((inst_len, parsed)) =
                FDIV_instructionVar206::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var206(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 254) == 110
        {
            if let Some((inst_len, parsed)) =
                FDIV_instructionVar207::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var207(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 254) == 4
        {
            if let Some((inst_len, parsed)) =
                FCMP_instructionVar208::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var208(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 254) == 12
        {
            if let Some((inst_len, parsed)) =
                FCMP_instructionVar209::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var209(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 208
            && (tokens_param[2] & 28) == 8
        {
            if let Some((inst_len, parsed)) =
                SHRPW_instructionVar210::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var210(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 208
            && (tokens_param[2] & 28) == 24
        {
            if let Some((inst_len, parsed)) =
                EXTRW_instructionVar211::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var211(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 208
            && (tokens_param[2] & 28) == 28
        {
            if let Some((inst_len, parsed)) =
                EXTRW_instructionVar212::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var212(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 212
            && (tokens_param[2] & 28) == 12
        {
            if let Some((inst_len, parsed)) =
                DEPW_instructionVar213::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var213(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 212
            && (tokens_param[2] & 28) == 28
        {
            if let Some((inst_len, parsed)) =
                DEPWI_instructionVar214::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var214(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 212
            && (tokens_param[2] & 28) == 8
        {
            if let Some((inst_len, parsed)) =
                DEPW_instructionVar215::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var215(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 212
            && (tokens_param[2] & 28) == 24
        {
            if let Some((inst_len, parsed)) =
                DEPWI_instructionVar216::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var216(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 15) == 11
            && (tokens_param[3] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                DCOR_instructionVar217::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var217(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 8
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 15) == 11
            && (tokens_param[3] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                IDCOR_instructionVar218::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var218(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[2] & 238) == 4
        {
            if let Some((inst_len, parsed)) =
                FCMP_instructionVar219::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var219(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[2] & 238) == 12
        {
            if let Some((inst_len, parsed)) =
                FCMP_instructionVar220::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var220(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 180
            && (tokens_param[2] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                ADDI_instructionVar221::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var221(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 180
            && (tokens_param[2] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                ADDI_instructionVar222::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var222(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 176
            && (tokens_param[2] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                ADDI_instructionVar223::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var223(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 176
            && (tokens_param[2] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                ADDI_instructionVar224::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var224(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 148
            && (tokens_param[2] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                SUBI_instructionVar225::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var225(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 148
            && (tokens_param[2] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                SUBI_instructionVar226::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var226(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 144
            && (tokens_param[2] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                CMPICLR_instructionVar227::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var227(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 231) == 96
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                FABS_instructionVar228::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var228(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 231) == 96
            && (tokens_param[3] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                FABS_instructionVar229::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var229(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 230) == 64
        {
            if let Some((inst_len, parsed)) =
                FCPY_instructionVar230::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var230(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 230) == 128
        {
            if let Some((inst_len, parsed)) =
                FSQRT_instructionVar231::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var231(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 230) == 128
        {
            if let Some((inst_len, parsed)) =
                FSQRT_instructionVar232::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var232(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 134) == 2
        {
            if let Some((inst_len, parsed)) =
                FCNV_instructionVar233::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var233(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[1] & 31) == 0
            && (tokens_param[2] & 134) == 130
        {
            if let Some((inst_len, parsed)) =
                FCNVXF_instructionVar234::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var234(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[1] & 31) == 1
            && (tokens_param[2] & 134) == 2
        {
            if let Some((inst_len, parsed)) =
                FCNVFX_instructionVar235::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var235(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[1] & 31) == 1
            && (tokens_param[2] & 134) == 130
        {
            if let Some((inst_len, parsed)) =
                FCNVFXT_instructionVar236::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var236(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[2] & 231) == 70
        {
            if let Some((inst_len, parsed)) =
                FMPY_instructionVar237::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var237(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[2] & 231) == 71
        {
            if let Some((inst_len, parsed)) =
                XMPYU_instructionVar238::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var238(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[2] & 230) == 160
        {
            if let Some((inst_len, parsed)) =
                FRND_instructionVar239::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var239(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 230) == 160
        {
            if let Some((inst_len, parsed)) =
                FRND_instructionVar240::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var240(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[2] & 230) == 6
        {
            if let Some((inst_len, parsed)) =
                FADD_instructionVar241::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var241(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[2] & 230) == 38
        {
            if let Some((inst_len, parsed)) =
                FSUB_instructionVar242::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var242(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 56
            && (tokens_param[2] & 230) == 102
        {
            if let Some((inst_len, parsed)) =
                FDIV_instructionVar243::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var243(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 48
            && (tokens_param[2] & 230) == 36
        {
            if let Some((inst_len, parsed)) =
                FTEST_instructionVar244::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var244(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 16
            && (tokens_param[2] & 6) == 0
        {
            if let Some((inst_len, parsed)) =
                SPOP0_instructionVar245::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var245(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 16
            && (tokens_param[2] & 6) == 2
        {
            if let Some((inst_len, parsed)) =
                SPOP1_instructionVar246::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var246(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 16
            && (tokens_param[2] & 6) == 4
        {
            if let Some((inst_len, parsed)) =
                SPOP2_instructionVar247::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var247(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 16
            && (tokens_param[2] & 6) == 6
        {
            if let Some((inst_len, parsed)) =
                SPOP3_instructionVar248::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var248(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 51) == 0
            && (tokens_param[3] & 160) == 0
        {
            if let Some((inst_len, parsed)) =
                FLDW_instructionVar249::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var249(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 51) == 32
            && (tokens_param[3] & 160) == 0
        {
            if let Some((inst_len, parsed)) =
                FLDW_instructionVar250::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var250(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 51) == 0
            && (tokens_param[3] & 160) == 32
        {
            if let Some((inst_len, parsed)) =
                FLDW_instructionVar251::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var251(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 51) == 32
            && (tokens_param[3] & 160) == 32
        {
            if let Some((inst_len, parsed)) =
                FLDW_instructionVar252::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var252(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 51) == 2
            && (tokens_param[3] & 160) == 0
        {
            if let Some((inst_len, parsed)) =
                FSTW_instructionVar253::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var253(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 51) == 34
            && (tokens_param[3] & 160) == 0
        {
            if let Some((inst_len, parsed)) =
                FSTW_instructionVar254::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var254(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 51) == 2
            && (tokens_param[3] & 160) == 32
        {
            if let Some((inst_len, parsed)) =
                FSTW_instructionVar255::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var255(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 51) == 34
            && (tokens_param[3] & 160) == 32
        {
            if let Some((inst_len, parsed)) =
                FSTW_instructionVar256::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var256(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 51) == 2
            && (tokens_param[3] & 160) == 0
        {
            if let Some((inst_len, parsed)) =
                FSTD_instructionVar257::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var257(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 51) == 34
            && (tokens_param[3] & 160) == 0
        {
            if let Some((inst_len, parsed)) =
                FSTD_instructionVar258::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var258(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 51) == 2
            && (tokens_param[3] & 160) == 32
        {
            if let Some((inst_len, parsed)) =
                FSTD_instructionVar259::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var259(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 51) == 34
            && (tokens_param[3] & 160) == 32
        {
            if let Some((inst_len, parsed)) =
                FSTD_instructionVar260::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var260(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 51) == 16
            && (tokens_param[3] & 160) == 32
        {
            if let Some((inst_len, parsed)) =
                FLDW_instructionVar261::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var261(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 51) == 48
            && (tokens_param[3] & 160) == 32
        {
            if let Some((inst_len, parsed)) =
                FLDW_instructionVar262::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var262(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 51) == 18
            && (tokens_param[3] & 160) == 32
        {
            if let Some((inst_len, parsed)) =
                FSTW_instructionVar263::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var263(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 51) == 50
            && (tokens_param[3] & 160) == 32
        {
            if let Some((inst_len, parsed)) =
                FSTW_instructionVar264::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var264(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 19) == 16
            && (tokens_param[3] & 160) == 0
        {
            if let Some((inst_len, parsed)) =
                FLDW_instructionVar265::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var265(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 19) == 18
            && (tokens_param[3] & 160) == 0
        {
            if let Some((inst_len, parsed)) =
                FSTW_instructionVar266::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var266(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 18) == 0
        {
            if let Some((inst_len, parsed)) =
                CLDW_instructionVar267::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var267(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 18) == 0
        {
            if let Some((inst_len, parsed)) =
                CLDD_instructionVar268::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var268(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 18) == 2
        {
            if let Some((inst_len, parsed)) =
                CSTW_instructionVar269::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var269(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 18) == 2
        {
            if let Some((inst_len, parsed)) =
                CSTD_instructionVar270::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var270(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 18) == 16
        {
            if let Some((inst_len, parsed)) =
                CLDW_instructionVar271::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var271(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 18) == 16
        {
            if let Some((inst_len, parsed)) =
                CLDD_instructionVar272::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var272(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 36
            && (tokens_param[2] & 18) == 18
        {
            if let Some((inst_len, parsed)) =
                CSTW_instructionVar273::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var273(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 44
            && (tokens_param[2] & 18) == 18
        {
            if let Some((inst_len, parsed)) =
                CSTD_instructionVar274::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var274(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 24
            && (tokens_param[3] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                FMPYADD_instructionVar275::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var275(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 24
            && (tokens_param[3] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                FMPYADD_instructionVar276::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var276(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 152
            && (tokens_param[3] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                FMPYSUB_instructionVar277::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var277(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 4
            && (tokens_param[0] & 252) == 152
            && (tokens_param[3] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                FMPYSUB_instructionVar278::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var278(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 72 {
            if let Some((inst_len, parsed)) =
                LDW_instructionVar279::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var279(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 68 {
            if let Some((inst_len, parsed)) =
                LDH_instructionVar280::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var280(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 64 {
            if let Some((inst_len, parsed)) =
                LDB_instructionVar281::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var281(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 104 {
            if let Some((inst_len, parsed)) =
                STW_instructionVar282::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var282(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 100 {
            if let Some((inst_len, parsed)) =
                STH_instructionVar283::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var283(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 96 {
            if let Some((inst_len, parsed)) =
                STB_instructionVar284::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var284(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 76 {
            if let Some((inst_len, parsed)) =
                LDW_instructionVar285::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var285(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 108 {
            if let Some((inst_len, parsed)) =
                STW_instructionVar286::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var286(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 52 {
            if let Some((inst_len, parsed)) =
                LDO_instructionVar287::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var287(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 32 {
            if let Some((inst_len, parsed)) =
                LDIL_instructionVar288::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var288(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 40 {
            if let Some((inst_len, parsed)) =
                ADDIL_instructionVar289::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var289(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 20 {
            if let Some((inst_len, parsed)) =
                DIAG_instructionVar290::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var290(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 7 == 4 && (tokens_param[0] & 252) == 48 {
            if let Some((inst_len, parsed)) =
                COPR_instructionVar291::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var291(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:458:1, end:458:14))"]
#[derive(Clone, Debug)]
struct immediateDestVar0 {}
impl immediateDestVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableimmediateDest {
    Var0(immediateDestVar0),
}
impl TableimmediateDest {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                immediateDestVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:942:1, end:942:3))"]
#[derive(Clone, Debug)]
struct R1Var0 {
    reg1: u8,
}
impl R1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.reg1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:943:1, end:943:3))"]
#[derive(Clone, Debug)]
struct R1Var1 {
    reg1: u8,
}
impl R1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.reg1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg1 }))
    }
}
#[derive(Clone, Debug)]
enum TableR1 {
    Var0(R1Var0),
    Var1(R1Var1),
}
impl TableR1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                R1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                R1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:944:1, end:944:6))"]
#[derive(Clone, Debug)]
struct R1dstVar0 {
    reg1: u8,
}
impl R1dstVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.reg1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg1 }))
    }
}
#[derive(Clone, Debug)]
enum TableR1dst {
    Var0(R1dstVar0),
}
impl TableR1dst {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                R1dstVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:946:1, end:946:3))"]
#[derive(Clone, Debug)]
struct R2Var0 {
    reg2: u8,
}
impl R2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.reg2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:947:1, end:947:3))"]
#[derive(Clone, Debug)]
struct R2Var1 {
    reg2: u8,
}
impl R2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.reg2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg2 }))
    }
}
#[derive(Clone, Debug)]
enum TableR2 {
    Var0(R2Var0),
    Var1(R2Var1),
}
impl TableR2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 0 && (tokens_param[1] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                R2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                R2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:948:1, end:948:6))"]
#[derive(Clone, Debug)]
struct R2dstVar0 {
    reg2: u8,
}
impl R2dstVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.reg2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let reg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg2 }))
    }
}
#[derive(Clone, Debug)]
enum TableR2dst {
    Var0(R2dstVar0),
}
impl TableR2dst {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                R2dstVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:950:1, end:950:3))"]
#[derive(Clone, Debug)]
struct RTVar0 {
    t: u8,
}
impl RTVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.t)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let t = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { t }))
    }
}
#[derive(Clone, Debug)]
enum TableRT {
    Var0(RTVar0),
}
impl TableRT {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RTVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:952:1, end:952:3))"]
#[derive(Clone, Debug)]
struct RBVar0 {
    b: u8,
}
impl RBVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.b)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let b = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:953:1, end:953:3))"]
#[derive(Clone, Debug)]
struct RBVar1 {
    b: u8,
}
impl RBVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.b)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let b = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { b }))
    }
}
#[derive(Clone, Debug)]
enum TableRB {
    Var0(RBVar0),
    Var1(RBVar1),
}
impl TableRB {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 0 && (tokens_param[1] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                RBVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RBVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:955:1, end:955:3))"]
#[derive(Clone, Debug)]
struct RXVar0 {}
impl RXVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:956:1, end:956:3))"]
#[derive(Clone, Debug)]
struct RXVar1 {
    x: u8,
}
impl RXVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.x)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let x = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { x }))
    }
}
#[derive(Clone, Debug)]
enum TableRX {
    Var0(RXVar0),
    Var1(RXVar1),
}
impl TableRX {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                RXVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RXVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:958:1, end:958:3))"]
#[derive(Clone, Debug)]
struct RRVar0 {
    r: u8,
}
impl RRVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.r)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let r = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:959:1, end:959:3))"]
#[derive(Clone, Debug)]
struct RRVar1 {
    r: u8,
}
impl RRVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.r)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let r = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r }))
    }
}
#[derive(Clone, Debug)]
enum TableRR {
    Var0(RRVar0),
    Var1(RRVar1),
}
impl TableRR {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                RRVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RRVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:961:1, end:961:4))"]
#[derive(Clone, Debug)]
struct SARVar0 {}
impl SARVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("SAR")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSAR {
    Var0(SARVar0),
}
impl TableSAR {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                SARVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:962:1, end:962:4))"]
#[derive(Clone, Debug)]
struct SR0Var0 {}
impl SR0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSR0 {
    Var0(SR0Var0),
}
impl TableSR0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                SR0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:963:1, end:963:4))"]
#[derive(Clone, Debug)]
struct R31Var0 {}
impl R31Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r31)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableR31 {
    Var0(R31Var0),
}
impl TableR31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                R31Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:966:1, end:966:7))"]
#[derive(Clone, Debug)]
struct FPR164Var0 {
    freg1: u8,
}
impl FPR164Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_1_display(self.freg1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[derive(Clone, Debug)]
enum TableFPR164 {
    Var0(FPR164Var0),
}
impl TableFPR164 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                FPR164Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:967:1, end:967:7))"]
#[derive(Clone, Debug)]
struct FPR264Var0 {
    freg2: u8,
}
impl FPR264Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_1_display(self.freg2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[derive(Clone, Debug)]
enum TableFPR264 {
    Var0(FPR264Var0),
}
impl TableFPR264 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                FPR264Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:968:1, end:968:7))"]
#[derive(Clone, Debug)]
struct FPRT64Var0 {
    fpt: u8,
}
impl FPRT64Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_1_display(self.fpt)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[derive(Clone, Debug)]
enum TableFPRT64 {
    Var0(FPRT64Var0),
}
impl TableFPRT64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                FPRT64Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:971:1, end:971:8))"]
#[derive(Clone, Debug)]
struct FUSEDR1Var0 {
    fusedr1: u8,
}
impl FUSEDR1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_3_display(self.fusedr1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fusedr1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedr1 }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDR1 {
    Var0(FUSEDR1Var0),
}
impl TableFUSEDR1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                FUSEDR1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:972:1, end:972:8))"]
#[derive(Clone, Debug)]
struct FUSEDR2Var0 {
    fusedr2: u8,
}
impl FUSEDR2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_3_display(self.fusedr2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fusedr2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedr2 }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDR2 {
    Var0(FUSEDR2Var0),
}
impl TableFUSEDR2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                FUSEDR2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:973:1, end:973:8))"]
#[derive(Clone, Debug)]
struct FUSEDRAVar0 {
    fusedra: u8,
}
impl FUSEDRAVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_3_display(self.fusedra)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fusedra = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedra }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDRA {
    Var0(FUSEDRAVar0),
}
impl TableFUSEDRA {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                FUSEDRAVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:974:1, end:974:8))"]
#[derive(Clone, Debug)]
struct FUSEDTAVar0 {
    fusedta: u8,
}
impl FUSEDTAVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_3_display(self.fusedta)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fusedta = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedta }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDTA {
    Var0(FUSEDTAVar0),
}
impl TableFUSEDTA {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                FUSEDTAVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:975:1, end:975:8))"]
#[derive(Clone, Debug)]
struct FUSEDRTVar0 {
    fusedrt: u8,
}
impl FUSEDRTVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_3_display(self.fusedrt)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fusedrt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedrt }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDRT {
    Var0(FUSEDRTVar0),
}
impl TableFUSEDRT {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                FUSEDRTVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:978:1, end:978:7))"]
#[derive(Clone, Debug)]
struct FPR132Var0 {
    freg1: u8,
}
impl FPR132Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:979:1, end:979:7))"]
#[derive(Clone, Debug)]
struct FPR132Var1 {
    freg1: u8,
}
impl FPR132Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:980:1, end:980:7))"]
#[derive(Clone, Debug)]
struct FPR132Var2 {
    freg1: u8,
}
impl FPR132Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:981:1, end:981:7))"]
#[derive(Clone, Debug)]
struct FPR132Var3 {
    freg1: u8,
}
impl FPR132Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:982:1, end:982:7))"]
#[derive(Clone, Debug)]
struct FPR132Var4 {
    freg1: u8,
}
impl FPR132Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:983:1, end:983:7))"]
#[derive(Clone, Debug)]
struct FPR132Var5 {
    freg1: u8,
}
impl FPR132Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:984:1, end:984:7))"]
#[derive(Clone, Debug)]
struct FPR132Var6 {
    freg1: u8,
}
impl FPR132Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:985:1, end:985:7))"]
#[derive(Clone, Debug)]
struct FPR132Var7 {
    freg1: u8,
}
impl FPR132Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:986:1, end:986:7))"]
#[derive(Clone, Debug)]
struct FPR132Var8 {
    freg1: u8,
}
impl FPR132Var8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:987:1, end:987:7))"]
#[derive(Clone, Debug)]
struct FPR132Var9 {
    freg1: u8,
}
impl FPR132Var9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:988:1, end:988:7))"]
#[derive(Clone, Debug)]
struct FPR132Var10 {
    freg1: u8,
}
impl FPR132Var10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:989:1, end:989:7))"]
#[derive(Clone, Debug)]
struct FPR132Var11 {
    freg1: u8,
}
impl FPR132Var11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:990:1, end:990:7))"]
#[derive(Clone, Debug)]
struct FPR132Var12 {
    freg1: u8,
}
impl FPR132Var12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:991:1, end:991:7))"]
#[derive(Clone, Debug)]
struct FPR132Var13 {
    freg1: u8,
}
impl FPR132Var13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:992:1, end:992:7))"]
#[derive(Clone, Debug)]
struct FPR132Var14 {
    freg1: u8,
}
impl FPR132Var14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:993:1, end:993:7))"]
#[derive(Clone, Debug)]
struct FPR132Var15 {
    freg1: u8,
}
impl FPR132Var15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:994:1, end:994:7))"]
#[derive(Clone, Debug)]
struct FPR132Var16 {
    freg1: u8,
}
impl FPR132Var16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:995:1, end:995:7))"]
#[derive(Clone, Debug)]
struct FPR132Var17 {
    freg1: u8,
}
impl FPR132Var17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:996:1, end:996:7))"]
#[derive(Clone, Debug)]
struct FPR132Var18 {
    freg1: u8,
}
impl FPR132Var18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:997:1, end:997:7))"]
#[derive(Clone, Debug)]
struct FPR132Var19 {
    freg1: u8,
}
impl FPR132Var19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:998:1, end:998:7))"]
#[derive(Clone, Debug)]
struct FPR132Var20 {
    freg1: u8,
}
impl FPR132Var20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:999:1, end:999:7))"]
#[derive(Clone, Debug)]
struct FPR132Var21 {
    freg1: u8,
}
impl FPR132Var21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1000:1, end:1000:7))"]
#[derive(Clone, Debug)]
struct FPR132Var22 {
    freg1: u8,
}
impl FPR132Var22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1001:1, end:1001:7))"]
#[derive(Clone, Debug)]
struct FPR132Var23 {
    freg1: u8,
}
impl FPR132Var23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1002:1, end:1002:7))"]
#[derive(Clone, Debug)]
struct FPR132Var24 {
    freg1: u8,
}
impl FPR132Var24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1003:1, end:1003:7))"]
#[derive(Clone, Debug)]
struct FPR132Var25 {
    freg1: u8,
}
impl FPR132Var25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1004:1, end:1004:7))"]
#[derive(Clone, Debug)]
struct FPR132Var26 {
    freg1: u8,
}
impl FPR132Var26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1005:1, end:1005:7))"]
#[derive(Clone, Debug)]
struct FPR132Var27 {
    freg1: u8,
}
impl FPR132Var27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1006:1, end:1006:7))"]
#[derive(Clone, Debug)]
struct FPR132Var28 {
    freg1: u8,
}
impl FPR132Var28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1007:1, end:1007:7))"]
#[derive(Clone, Debug)]
struct FPR132Var29 {
    freg1: u8,
}
impl FPR132Var29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1008:1, end:1008:7))"]
#[derive(Clone, Debug)]
struct FPR132Var30 {
    freg1: u8,
}
impl FPR132Var30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1009:1, end:1009:7))"]
#[derive(Clone, Debug)]
struct FPR132Var31 {
    freg1: u8,
}
impl FPR132Var31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1010:1, end:1010:7))"]
#[derive(Clone, Debug)]
struct FPR132Var32 {
    freg1: u8,
}
impl FPR132Var32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1011:1, end:1011:7))"]
#[derive(Clone, Debug)]
struct FPR132Var33 {
    freg1: u8,
}
impl FPR132Var33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1012:1, end:1012:7))"]
#[derive(Clone, Debug)]
struct FPR132Var34 {
    freg1: u8,
}
impl FPR132Var34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1013:1, end:1013:7))"]
#[derive(Clone, Debug)]
struct FPR132Var35 {
    freg1: u8,
}
impl FPR132Var35 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1014:1, end:1014:7))"]
#[derive(Clone, Debug)]
struct FPR132Var36 {
    freg1: u8,
}
impl FPR132Var36 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1015:1, end:1015:7))"]
#[derive(Clone, Debug)]
struct FPR132Var37 {
    freg1: u8,
}
impl FPR132Var37 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1016:1, end:1016:7))"]
#[derive(Clone, Debug)]
struct FPR132Var38 {
    freg1: u8,
}
impl FPR132Var38 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1017:1, end:1017:7))"]
#[derive(Clone, Debug)]
struct FPR132Var39 {
    freg1: u8,
}
impl FPR132Var39 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1018:1, end:1018:7))"]
#[derive(Clone, Debug)]
struct FPR132Var40 {
    freg1: u8,
}
impl FPR132Var40 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1019:1, end:1019:7))"]
#[derive(Clone, Debug)]
struct FPR132Var41 {
    freg1: u8,
}
impl FPR132Var41 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1020:1, end:1020:7))"]
#[derive(Clone, Debug)]
struct FPR132Var42 {
    freg1: u8,
}
impl FPR132Var42 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1021:1, end:1021:7))"]
#[derive(Clone, Debug)]
struct FPR132Var43 {
    freg1: u8,
}
impl FPR132Var43 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1022:1, end:1022:7))"]
#[derive(Clone, Debug)]
struct FPR132Var44 {
    freg1: u8,
}
impl FPR132Var44 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1023:1, end:1023:7))"]
#[derive(Clone, Debug)]
struct FPR132Var45 {
    freg1: u8,
}
impl FPR132Var45 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1024:1, end:1024:7))"]
#[derive(Clone, Debug)]
struct FPR132Var46 {
    freg1: u8,
}
impl FPR132Var46 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1025:1, end:1025:7))"]
#[derive(Clone, Debug)]
struct FPR132Var47 {
    freg1: u8,
}
impl FPR132Var47 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1026:1, end:1026:7))"]
#[derive(Clone, Debug)]
struct FPR132Var48 {
    freg1: u8,
}
impl FPR132Var48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1027:1, end:1027:7))"]
#[derive(Clone, Debug)]
struct FPR132Var49 {
    freg1: u8,
}
impl FPR132Var49 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1028:1, end:1028:7))"]
#[derive(Clone, Debug)]
struct FPR132Var50 {
    freg1: u8,
}
impl FPR132Var50 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1029:1, end:1029:7))"]
#[derive(Clone, Debug)]
struct FPR132Var51 {
    freg1: u8,
}
impl FPR132Var51 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1030:1, end:1030:7))"]
#[derive(Clone, Debug)]
struct FPR132Var52 {
    freg1: u8,
}
impl FPR132Var52 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1031:1, end:1031:7))"]
#[derive(Clone, Debug)]
struct FPR132Var53 {
    freg1: u8,
}
impl FPR132Var53 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1032:1, end:1032:7))"]
#[derive(Clone, Debug)]
struct FPR132Var54 {
    freg1: u8,
}
impl FPR132Var54 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1033:1, end:1033:7))"]
#[derive(Clone, Debug)]
struct FPR132Var55 {
    freg1: u8,
}
impl FPR132Var55 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1034:1, end:1034:7))"]
#[derive(Clone, Debug)]
struct FPR132Var56 {
    freg1: u8,
}
impl FPR132Var56 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1035:1, end:1035:7))"]
#[derive(Clone, Debug)]
struct FPR132Var57 {
    freg1: u8,
}
impl FPR132Var57 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1036:1, end:1036:7))"]
#[derive(Clone, Debug)]
struct FPR132Var58 {
    freg1: u8,
}
impl FPR132Var58 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1037:1, end:1037:7))"]
#[derive(Clone, Debug)]
struct FPR132Var59 {
    freg1: u8,
}
impl FPR132Var59 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1038:1, end:1038:7))"]
#[derive(Clone, Debug)]
struct FPR132Var60 {
    freg1: u8,
}
impl FPR132Var60 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1039:1, end:1039:7))"]
#[derive(Clone, Debug)]
struct FPR132Var61 {
    freg1: u8,
}
impl FPR132Var61 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1040:1, end:1040:7))"]
#[derive(Clone, Debug)]
struct FPR132Var62 {
    freg1: u8,
}
impl FPR132Var62 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1041:1, end:1041:7))"]
#[derive(Clone, Debug)]
struct FPR132Var63 {
    freg1: u8,
}
impl FPR132Var63 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg1),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg1 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[derive(Clone, Debug)]
enum TableFPR132 {
    Var0(FPR132Var0),
    Var1(FPR132Var1),
    Var2(FPR132Var2),
    Var3(FPR132Var3),
    Var4(FPR132Var4),
    Var5(FPR132Var5),
    Var6(FPR132Var6),
    Var7(FPR132Var7),
    Var8(FPR132Var8),
    Var9(FPR132Var9),
    Var10(FPR132Var10),
    Var11(FPR132Var11),
    Var12(FPR132Var12),
    Var13(FPR132Var13),
    Var14(FPR132Var14),
    Var15(FPR132Var15),
    Var16(FPR132Var16),
    Var17(FPR132Var17),
    Var18(FPR132Var18),
    Var19(FPR132Var19),
    Var20(FPR132Var20),
    Var21(FPR132Var21),
    Var22(FPR132Var22),
    Var23(FPR132Var23),
    Var24(FPR132Var24),
    Var25(FPR132Var25),
    Var26(FPR132Var26),
    Var27(FPR132Var27),
    Var28(FPR132Var28),
    Var29(FPR132Var29),
    Var30(FPR132Var30),
    Var31(FPR132Var31),
    Var32(FPR132Var32),
    Var33(FPR132Var33),
    Var34(FPR132Var34),
    Var35(FPR132Var35),
    Var36(FPR132Var36),
    Var37(FPR132Var37),
    Var38(FPR132Var38),
    Var39(FPR132Var39),
    Var40(FPR132Var40),
    Var41(FPR132Var41),
    Var42(FPR132Var42),
    Var43(FPR132Var43),
    Var44(FPR132Var44),
    Var45(FPR132Var45),
    Var46(FPR132Var46),
    Var47(FPR132Var47),
    Var48(FPR132Var48),
    Var49(FPR132Var49),
    Var50(FPR132Var50),
    Var51(FPR132Var51),
    Var52(FPR132Var52),
    Var53(FPR132Var53),
    Var54(FPR132Var54),
    Var55(FPR132Var55),
    Var56(FPR132Var56),
    Var57(FPR132Var57),
    Var58(FPR132Var58),
    Var59(FPR132Var59),
    Var60(FPR132Var60),
    Var61(FPR132Var61),
    Var62(FPR132Var62),
    Var63(FPR132Var63),
}
impl TableFPR132 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var35(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var36(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var37(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var38(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var39(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var40(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var41(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var42(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var43(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var44(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var45(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var46(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var47(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var48(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var49(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var50(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var51(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var52(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var53(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var54(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var55(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var56(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var57(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var58(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var59(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var60(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var61(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var62(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var63(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 0 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 1 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 2 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 3 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 5 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 6 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 7 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 8 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 9 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 10 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 11 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 12 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 13 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 14 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 15 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 16 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 17 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 18 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 19 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 20 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 21 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 22 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 23 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 24 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 25 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 26 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 27 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 28 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 29 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 30 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 31 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                FPR132Var31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 0 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 1 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 2 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 3 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var35::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var35(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var36::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var36(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 5 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var37::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var37(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 6 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var38::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var38(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 7 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var39::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var39(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 8 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var40::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var40(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 9 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var41::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var41(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 10 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var42::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var42(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 11 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var43::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var43(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 12 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var44::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var44(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 13 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var45::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var45(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 14 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var46::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var46(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 15 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var47::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var47(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 16 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var48::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var48(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 17 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var49::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var49(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 18 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var50::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var50(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 19 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var51::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var51(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 20 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var52::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var52(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 21 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var53::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var53(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 22 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var54::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var54(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 23 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var55::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var55(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 24 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var56::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var56(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 25 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var57::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var57(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 26 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var58::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var58(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 27 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var59::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var59(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 28 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var60::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var60(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 29 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var61::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var61(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 30 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var62::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var62(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 31) == 31 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                FPR132Var63::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var63(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1043:1, end:1043:7))"]
#[derive(Clone, Debug)]
struct FPR232Var0 {
    freg2: u8,
}
impl FPR232Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1044:1, end:1044:7))"]
#[derive(Clone, Debug)]
struct FPR232Var1 {
    freg2: u8,
}
impl FPR232Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1045:1, end:1045:7))"]
#[derive(Clone, Debug)]
struct FPR232Var2 {
    freg2: u8,
}
impl FPR232Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1046:1, end:1046:7))"]
#[derive(Clone, Debug)]
struct FPR232Var3 {
    freg2: u8,
}
impl FPR232Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1047:1, end:1047:7))"]
#[derive(Clone, Debug)]
struct FPR232Var4 {
    freg2: u8,
}
impl FPR232Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1048:1, end:1048:7))"]
#[derive(Clone, Debug)]
struct FPR232Var5 {
    freg2: u8,
}
impl FPR232Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1049:1, end:1049:7))"]
#[derive(Clone, Debug)]
struct FPR232Var6 {
    freg2: u8,
}
impl FPR232Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1050:1, end:1050:7))"]
#[derive(Clone, Debug)]
struct FPR232Var7 {
    freg2: u8,
}
impl FPR232Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1051:1, end:1051:7))"]
#[derive(Clone, Debug)]
struct FPR232Var8 {
    freg2: u8,
}
impl FPR232Var8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1052:1, end:1052:7))"]
#[derive(Clone, Debug)]
struct FPR232Var9 {
    freg2: u8,
}
impl FPR232Var9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1053:1, end:1053:7))"]
#[derive(Clone, Debug)]
struct FPR232Var10 {
    freg2: u8,
}
impl FPR232Var10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1054:1, end:1054:7))"]
#[derive(Clone, Debug)]
struct FPR232Var11 {
    freg2: u8,
}
impl FPR232Var11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1055:1, end:1055:7))"]
#[derive(Clone, Debug)]
struct FPR232Var12 {
    freg2: u8,
}
impl FPR232Var12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1056:1, end:1056:7))"]
#[derive(Clone, Debug)]
struct FPR232Var13 {
    freg2: u8,
}
impl FPR232Var13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1057:1, end:1057:7))"]
#[derive(Clone, Debug)]
struct FPR232Var14 {
    freg2: u8,
}
impl FPR232Var14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1058:1, end:1058:7))"]
#[derive(Clone, Debug)]
struct FPR232Var15 {
    freg2: u8,
}
impl FPR232Var15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1059:1, end:1059:7))"]
#[derive(Clone, Debug)]
struct FPR232Var16 {
    freg2: u8,
}
impl FPR232Var16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1060:1, end:1060:7))"]
#[derive(Clone, Debug)]
struct FPR232Var17 {
    freg2: u8,
}
impl FPR232Var17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1061:1, end:1061:7))"]
#[derive(Clone, Debug)]
struct FPR232Var18 {
    freg2: u8,
}
impl FPR232Var18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1062:1, end:1062:7))"]
#[derive(Clone, Debug)]
struct FPR232Var19 {
    freg2: u8,
}
impl FPR232Var19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1063:1, end:1063:7))"]
#[derive(Clone, Debug)]
struct FPR232Var20 {
    freg2: u8,
}
impl FPR232Var20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1064:1, end:1064:7))"]
#[derive(Clone, Debug)]
struct FPR232Var21 {
    freg2: u8,
}
impl FPR232Var21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1065:1, end:1065:7))"]
#[derive(Clone, Debug)]
struct FPR232Var22 {
    freg2: u8,
}
impl FPR232Var22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1066:1, end:1066:7))"]
#[derive(Clone, Debug)]
struct FPR232Var23 {
    freg2: u8,
}
impl FPR232Var23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1067:1, end:1067:7))"]
#[derive(Clone, Debug)]
struct FPR232Var24 {
    freg2: u8,
}
impl FPR232Var24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1068:1, end:1068:7))"]
#[derive(Clone, Debug)]
struct FPR232Var25 {
    freg2: u8,
}
impl FPR232Var25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1069:1, end:1069:7))"]
#[derive(Clone, Debug)]
struct FPR232Var26 {
    freg2: u8,
}
impl FPR232Var26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1070:1, end:1070:7))"]
#[derive(Clone, Debug)]
struct FPR232Var27 {
    freg2: u8,
}
impl FPR232Var27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1071:1, end:1071:7))"]
#[derive(Clone, Debug)]
struct FPR232Var28 {
    freg2: u8,
}
impl FPR232Var28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1072:1, end:1072:7))"]
#[derive(Clone, Debug)]
struct FPR232Var29 {
    freg2: u8,
}
impl FPR232Var29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1073:1, end:1073:7))"]
#[derive(Clone, Debug)]
struct FPR232Var30 {
    freg2: u8,
}
impl FPR232Var30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1074:1, end:1074:7))"]
#[derive(Clone, Debug)]
struct FPR232Var31 {
    freg2: u8,
}
impl FPR232Var31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("L"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1076:1, end:1076:7))"]
#[derive(Clone, Debug)]
struct FPR232Var32 {
    freg2: u8,
}
impl FPR232Var32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1077:1, end:1077:7))"]
#[derive(Clone, Debug)]
struct FPR232Var33 {
    freg2: u8,
}
impl FPR232Var33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1078:1, end:1078:7))"]
#[derive(Clone, Debug)]
struct FPR232Var34 {
    freg2: u8,
}
impl FPR232Var34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1079:1, end:1079:7))"]
#[derive(Clone, Debug)]
struct FPR232Var35 {
    freg2: u8,
}
impl FPR232Var35 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1080:1, end:1080:7))"]
#[derive(Clone, Debug)]
struct FPR232Var36 {
    freg2: u8,
}
impl FPR232Var36 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1081:1, end:1081:7))"]
#[derive(Clone, Debug)]
struct FPR232Var37 {
    freg2: u8,
}
impl FPR232Var37 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1082:1, end:1082:7))"]
#[derive(Clone, Debug)]
struct FPR232Var38 {
    freg2: u8,
}
impl FPR232Var38 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1083:1, end:1083:7))"]
#[derive(Clone, Debug)]
struct FPR232Var39 {
    freg2: u8,
}
impl FPR232Var39 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1084:1, end:1084:7))"]
#[derive(Clone, Debug)]
struct FPR232Var40 {
    freg2: u8,
}
impl FPR232Var40 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1085:1, end:1085:7))"]
#[derive(Clone, Debug)]
struct FPR232Var41 {
    freg2: u8,
}
impl FPR232Var41 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1086:1, end:1086:7))"]
#[derive(Clone, Debug)]
struct FPR232Var42 {
    freg2: u8,
}
impl FPR232Var42 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1087:1, end:1087:7))"]
#[derive(Clone, Debug)]
struct FPR232Var43 {
    freg2: u8,
}
impl FPR232Var43 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1088:1, end:1088:7))"]
#[derive(Clone, Debug)]
struct FPR232Var44 {
    freg2: u8,
}
impl FPR232Var44 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1089:1, end:1089:7))"]
#[derive(Clone, Debug)]
struct FPR232Var45 {
    freg2: u8,
}
impl FPR232Var45 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1090:1, end:1090:7))"]
#[derive(Clone, Debug)]
struct FPR232Var46 {
    freg2: u8,
}
impl FPR232Var46 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1091:1, end:1091:7))"]
#[derive(Clone, Debug)]
struct FPR232Var47 {
    freg2: u8,
}
impl FPR232Var47 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1092:1, end:1092:7))"]
#[derive(Clone, Debug)]
struct FPR232Var48 {
    freg2: u8,
}
impl FPR232Var48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1093:1, end:1093:7))"]
#[derive(Clone, Debug)]
struct FPR232Var49 {
    freg2: u8,
}
impl FPR232Var49 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1094:1, end:1094:7))"]
#[derive(Clone, Debug)]
struct FPR232Var50 {
    freg2: u8,
}
impl FPR232Var50 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1095:1, end:1095:7))"]
#[derive(Clone, Debug)]
struct FPR232Var51 {
    freg2: u8,
}
impl FPR232Var51 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1096:1, end:1096:7))"]
#[derive(Clone, Debug)]
struct FPR232Var52 {
    freg2: u8,
}
impl FPR232Var52 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1097:1, end:1097:7))"]
#[derive(Clone, Debug)]
struct FPR232Var53 {
    freg2: u8,
}
impl FPR232Var53 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1098:1, end:1098:7))"]
#[derive(Clone, Debug)]
struct FPR232Var54 {
    freg2: u8,
}
impl FPR232Var54 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1099:1, end:1099:7))"]
#[derive(Clone, Debug)]
struct FPR232Var55 {
    freg2: u8,
}
impl FPR232Var55 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1100:1, end:1100:7))"]
#[derive(Clone, Debug)]
struct FPR232Var56 {
    freg2: u8,
}
impl FPR232Var56 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1101:1, end:1101:7))"]
#[derive(Clone, Debug)]
struct FPR232Var57 {
    freg2: u8,
}
impl FPR232Var57 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1102:1, end:1102:7))"]
#[derive(Clone, Debug)]
struct FPR232Var58 {
    freg2: u8,
}
impl FPR232Var58 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1103:1, end:1103:7))"]
#[derive(Clone, Debug)]
struct FPR232Var59 {
    freg2: u8,
}
impl FPR232Var59 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1104:1, end:1104:7))"]
#[derive(Clone, Debug)]
struct FPR232Var60 {
    freg2: u8,
}
impl FPR232Var60 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1105:1, end:1105:7))"]
#[derive(Clone, Debug)]
struct FPR232Var61 {
    freg2: u8,
}
impl FPR232Var61 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1106:1, end:1106:7))"]
#[derive(Clone, Debug)]
struct FPR232Var62 {
    freg2: u8,
}
impl FPR232Var62 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1107:1, end:1107:7))"]
#[derive(Clone, Debug)]
struct FPR232Var63 {
    freg2: u8,
}
impl FPR232Var63 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_1_display(self.freg2),
            <DisplayElement>::Literal("R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let freg2 = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[derive(Clone, Debug)]
enum TableFPR232 {
    Var0(FPR232Var0),
    Var1(FPR232Var1),
    Var2(FPR232Var2),
    Var3(FPR232Var3),
    Var4(FPR232Var4),
    Var5(FPR232Var5),
    Var6(FPR232Var6),
    Var7(FPR232Var7),
    Var8(FPR232Var8),
    Var9(FPR232Var9),
    Var10(FPR232Var10),
    Var11(FPR232Var11),
    Var12(FPR232Var12),
    Var13(FPR232Var13),
    Var14(FPR232Var14),
    Var15(FPR232Var15),
    Var16(FPR232Var16),
    Var17(FPR232Var17),
    Var18(FPR232Var18),
    Var19(FPR232Var19),
    Var20(FPR232Var20),
    Var21(FPR232Var21),
    Var22(FPR232Var22),
    Var23(FPR232Var23),
    Var24(FPR232Var24),
    Var25(FPR232Var25),
    Var26(FPR232Var26),
    Var27(FPR232Var27),
    Var28(FPR232Var28),
    Var29(FPR232Var29),
    Var30(FPR232Var30),
    Var31(FPR232Var31),
    Var32(FPR232Var32),
    Var33(FPR232Var33),
    Var34(FPR232Var34),
    Var35(FPR232Var35),
    Var36(FPR232Var36),
    Var37(FPR232Var37),
    Var38(FPR232Var38),
    Var39(FPR232Var39),
    Var40(FPR232Var40),
    Var41(FPR232Var41),
    Var42(FPR232Var42),
    Var43(FPR232Var43),
    Var44(FPR232Var44),
    Var45(FPR232Var45),
    Var46(FPR232Var46),
    Var47(FPR232Var47),
    Var48(FPR232Var48),
    Var49(FPR232Var49),
    Var50(FPR232Var50),
    Var51(FPR232Var51),
    Var52(FPR232Var52),
    Var53(FPR232Var53),
    Var54(FPR232Var54),
    Var55(FPR232Var55),
    Var56(FPR232Var56),
    Var57(FPR232Var57),
    Var58(FPR232Var58),
    Var59(FPR232Var59),
    Var60(FPR232Var60),
    Var61(FPR232Var61),
    Var62(FPR232Var62),
    Var63(FPR232Var63),
}
impl TableFPR232 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var35(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var36(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var37(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var38(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var39(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var40(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var41(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var42(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var43(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var44(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var45(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var46(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var47(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var48(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var49(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var50(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var51(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var52(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var53(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var54(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var55(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var56(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var57(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var58(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var59(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var60(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var61(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var62(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var63(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 0
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 32
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 64
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 96
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 128
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 160
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 192
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 224
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 0
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 32
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 64
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 96
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 128
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 160
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 192
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 224
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 0
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 32
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 64
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 96
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 128
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 160
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 192
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 224
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 0
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 32
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 64
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 96
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 128
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 160
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 192
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 224
            && (tokens_param[3] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                FPR232Var31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 0
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 32
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 64
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 96
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var35::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var35(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 128
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var36::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var36(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 160
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var37::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var37(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 192
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var38::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var38(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 0
            && (tokens_param[1] & 224) == 224
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var39::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var39(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 0
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var40::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var40(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 32
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var41::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var41(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 64
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var42::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var42(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 96
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var43::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var43(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 128
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var44::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var44(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 160
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var45::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var45(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 192
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var46::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var46(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 1
            && (tokens_param[1] & 224) == 224
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var47::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var47(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 0
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var48::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var48(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 32
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var49::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var49(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 64
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var50::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var50(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 96
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var51::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var51(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 128
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var52::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var52(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 160
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var53::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var53(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 192
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var54::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var54(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 2
            && (tokens_param[1] & 224) == 224
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var55::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var55(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 0
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var56::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var56(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 32
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var57::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var57(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 64
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var58::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var58(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 96
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var59::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var59(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 128
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var60::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var60(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 160
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var61::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var61(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 192
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var62::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var62(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 3) == 3
            && (tokens_param[1] & 224) == 224
            && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                FPR232Var63::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var63(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1109:1, end:1109:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var0 {
    fpt: u8,
}
impl FPRT32Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1110:1, end:1110:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var1 {
    fpt: u8,
}
impl FPRT32Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1111:1, end:1111:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var2 {
    fpt: u8,
}
impl FPRT32Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1112:1, end:1112:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var3 {
    fpt: u8,
}
impl FPRT32Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1113:1, end:1113:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var4 {
    fpt: u8,
}
impl FPRT32Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1114:1, end:1114:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var5 {
    fpt: u8,
}
impl FPRT32Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1115:1, end:1115:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var6 {
    fpt: u8,
}
impl FPRT32Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1116:1, end:1116:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var7 {
    fpt: u8,
}
impl FPRT32Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1117:1, end:1117:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var8 {
    fpt: u8,
}
impl FPRT32Var8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1118:1, end:1118:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var9 {
    fpt: u8,
}
impl FPRT32Var9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1119:1, end:1119:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var10 {
    fpt: u8,
}
impl FPRT32Var10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1120:1, end:1120:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var11 {
    fpt: u8,
}
impl FPRT32Var11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1121:1, end:1121:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var12 {
    fpt: u8,
}
impl FPRT32Var12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1122:1, end:1122:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var13 {
    fpt: u8,
}
impl FPRT32Var13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1123:1, end:1123:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var14 {
    fpt: u8,
}
impl FPRT32Var14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1124:1, end:1124:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var15 {
    fpt: u8,
}
impl FPRT32Var15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1125:1, end:1125:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var16 {
    fpt: u8,
}
impl FPRT32Var16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1126:1, end:1126:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var17 {
    fpt: u8,
}
impl FPRT32Var17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1127:1, end:1127:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var18 {
    fpt: u8,
}
impl FPRT32Var18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1128:1, end:1128:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var19 {
    fpt: u8,
}
impl FPRT32Var19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1129:1, end:1129:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var20 {
    fpt: u8,
}
impl FPRT32Var20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1130:1, end:1130:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var21 {
    fpt: u8,
}
impl FPRT32Var21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1131:1, end:1131:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var22 {
    fpt: u8,
}
impl FPRT32Var22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1132:1, end:1132:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var23 {
    fpt: u8,
}
impl FPRT32Var23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1133:1, end:1133:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var24 {
    fpt: u8,
}
impl FPRT32Var24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1134:1, end:1134:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var25 {
    fpt: u8,
}
impl FPRT32Var25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1135:1, end:1135:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var26 {
    fpt: u8,
}
impl FPRT32Var26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1136:1, end:1136:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var27 {
    fpt: u8,
}
impl FPRT32Var27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1137:1, end:1137:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var28 {
    fpt: u8,
}
impl FPRT32Var28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1138:1, end:1138:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var29 {
    fpt: u8,
}
impl FPRT32Var29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1139:1, end:1139:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var30 {
    fpt: u8,
}
impl FPRT32Var30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1140:1, end:1140:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var31 {
    fpt: u8,
}
impl FPRT32Var31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1143:1, end:1143:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var32 {
    fpt: u8,
}
impl FPRT32Var32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1144:1, end:1144:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var33 {
    fpt: u8,
}
impl FPRT32Var33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1145:1, end:1145:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var34 {
    fpt: u8,
}
impl FPRT32Var34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1146:1, end:1146:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var35 {
    fpt: u8,
}
impl FPRT32Var35 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1147:1, end:1147:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var36 {
    fpt: u8,
}
impl FPRT32Var36 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1148:1, end:1148:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var37 {
    fpt: u8,
}
impl FPRT32Var37 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1149:1, end:1149:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var38 {
    fpt: u8,
}
impl FPRT32Var38 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1150:1, end:1150:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var39 {
    fpt: u8,
}
impl FPRT32Var39 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1151:1, end:1151:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var40 {
    fpt: u8,
}
impl FPRT32Var40 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1152:1, end:1152:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var41 {
    fpt: u8,
}
impl FPRT32Var41 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1153:1, end:1153:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var42 {
    fpt: u8,
}
impl FPRT32Var42 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1154:1, end:1154:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var43 {
    fpt: u8,
}
impl FPRT32Var43 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1155:1, end:1155:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var44 {
    fpt: u8,
}
impl FPRT32Var44 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1156:1, end:1156:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var45 {
    fpt: u8,
}
impl FPRT32Var45 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1157:1, end:1157:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var46 {
    fpt: u8,
}
impl FPRT32Var46 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1158:1, end:1158:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var47 {
    fpt: u8,
}
impl FPRT32Var47 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1159:1, end:1159:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var48 {
    fpt: u8,
}
impl FPRT32Var48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1160:1, end:1160:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var49 {
    fpt: u8,
}
impl FPRT32Var49 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1161:1, end:1161:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var50 {
    fpt: u8,
}
impl FPRT32Var50 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1162:1, end:1162:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var51 {
    fpt: u8,
}
impl FPRT32Var51 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1163:1, end:1163:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var52 {
    fpt: u8,
}
impl FPRT32Var52 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1164:1, end:1164:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var53 {
    fpt: u8,
}
impl FPRT32Var53 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1165:1, end:1165:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var54 {
    fpt: u8,
}
impl FPRT32Var54 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1166:1, end:1166:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var55 {
    fpt: u8,
}
impl FPRT32Var55 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1167:1, end:1167:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var56 {
    fpt: u8,
}
impl FPRT32Var56 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1168:1, end:1168:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var57 {
    fpt: u8,
}
impl FPRT32Var57 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1169:1, end:1169:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var58 {
    fpt: u8,
}
impl FPRT32Var58 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1170:1, end:1170:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var59 {
    fpt: u8,
}
impl FPRT32Var59 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1171:1, end:1171:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var60 {
    fpt: u8,
}
impl FPRT32Var60 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1172:1, end:1172:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var61 {
    fpt: u8,
}
impl FPRT32Var61 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1173:1, end:1173:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var62 {
    fpt: u8,
}
impl FPRT32Var62 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1174:1, end:1174:7))"]
#[derive(Clone, Debug)]
struct FPRT32Var63 {
    fpt: u8,
}
impl FPRT32Var63 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] =
            [meaning_1_display(self.fpt), <DisplayElement>::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fpt = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[derive(Clone, Debug)]
enum TableFPRT32 {
    Var0(FPRT32Var0),
    Var1(FPRT32Var1),
    Var2(FPRT32Var2),
    Var3(FPRT32Var3),
    Var4(FPRT32Var4),
    Var5(FPRT32Var5),
    Var6(FPRT32Var6),
    Var7(FPRT32Var7),
    Var8(FPRT32Var8),
    Var9(FPRT32Var9),
    Var10(FPRT32Var10),
    Var11(FPRT32Var11),
    Var12(FPRT32Var12),
    Var13(FPRT32Var13),
    Var14(FPRT32Var14),
    Var15(FPRT32Var15),
    Var16(FPRT32Var16),
    Var17(FPRT32Var17),
    Var18(FPRT32Var18),
    Var19(FPRT32Var19),
    Var20(FPRT32Var20),
    Var21(FPRT32Var21),
    Var22(FPRT32Var22),
    Var23(FPRT32Var23),
    Var24(FPRT32Var24),
    Var25(FPRT32Var25),
    Var26(FPRT32Var26),
    Var27(FPRT32Var27),
    Var28(FPRT32Var28),
    Var29(FPRT32Var29),
    Var30(FPRT32Var30),
    Var31(FPRT32Var31),
    Var32(FPRT32Var32),
    Var33(FPRT32Var33),
    Var34(FPRT32Var34),
    Var35(FPRT32Var35),
    Var36(FPRT32Var36),
    Var37(FPRT32Var37),
    Var38(FPRT32Var38),
    Var39(FPRT32Var39),
    Var40(FPRT32Var40),
    Var41(FPRT32Var41),
    Var42(FPRT32Var42),
    Var43(FPRT32Var43),
    Var44(FPRT32Var44),
    Var45(FPRT32Var45),
    Var46(FPRT32Var46),
    Var47(FPRT32Var47),
    Var48(FPRT32Var48),
    Var49(FPRT32Var49),
    Var50(FPRT32Var50),
    Var51(FPRT32Var51),
    Var52(FPRT32Var52),
    Var53(FPRT32Var53),
    Var54(FPRT32Var54),
    Var55(FPRT32Var55),
    Var56(FPRT32Var56),
    Var57(FPRT32Var57),
    Var58(FPRT32Var58),
    Var59(FPRT32Var59),
    Var60(FPRT32Var60),
    Var61(FPRT32Var61),
    Var62(FPRT32Var62),
    Var63(FPRT32Var63),
}
impl TableFPRT32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var35(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var36(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var37(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var38(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var39(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var40(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var41(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var42(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var43(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var44(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var45(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var46(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var47(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var48(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var49(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var50(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var51(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var52(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var53(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var54(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var55(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var56(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var57(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var58(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var59(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var60(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var61(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var62(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var63(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 0 {
            if let Some((inst_len, parsed)) =
                FPRT32Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 1 {
            if let Some((inst_len, parsed)) =
                FPRT32Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 2 {
            if let Some((inst_len, parsed)) =
                FPRT32Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 3 {
            if let Some((inst_len, parsed)) =
                FPRT32Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 4 {
            if let Some((inst_len, parsed)) =
                FPRT32Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 5 {
            if let Some((inst_len, parsed)) =
                FPRT32Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 6 {
            if let Some((inst_len, parsed)) =
                FPRT32Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 7 {
            if let Some((inst_len, parsed)) =
                FPRT32Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 8 {
            if let Some((inst_len, parsed)) =
                FPRT32Var8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 9 {
            if let Some((inst_len, parsed)) =
                FPRT32Var9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 10 {
            if let Some((inst_len, parsed)) =
                FPRT32Var10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 11 {
            if let Some((inst_len, parsed)) =
                FPRT32Var11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 12 {
            if let Some((inst_len, parsed)) =
                FPRT32Var12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 13 {
            if let Some((inst_len, parsed)) =
                FPRT32Var13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 14 {
            if let Some((inst_len, parsed)) =
                FPRT32Var14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 15 {
            if let Some((inst_len, parsed)) =
                FPRT32Var15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 16 {
            if let Some((inst_len, parsed)) =
                FPRT32Var16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 17 {
            if let Some((inst_len, parsed)) =
                FPRT32Var17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 18 {
            if let Some((inst_len, parsed)) =
                FPRT32Var18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 19 {
            if let Some((inst_len, parsed)) =
                FPRT32Var19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 20 {
            if let Some((inst_len, parsed)) =
                FPRT32Var20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 21 {
            if let Some((inst_len, parsed)) =
                FPRT32Var21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 22 {
            if let Some((inst_len, parsed)) =
                FPRT32Var22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 23 {
            if let Some((inst_len, parsed)) =
                FPRT32Var23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 24 {
            if let Some((inst_len, parsed)) =
                FPRT32Var24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 25 {
            if let Some((inst_len, parsed)) =
                FPRT32Var25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 26 {
            if let Some((inst_len, parsed)) =
                FPRT32Var26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 27 {
            if let Some((inst_len, parsed)) =
                FPRT32Var27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 28 {
            if let Some((inst_len, parsed)) =
                FPRT32Var28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 29 {
            if let Some((inst_len, parsed)) =
                FPRT32Var29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 30 {
            if let Some((inst_len, parsed)) =
                FPRT32Var30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 31 {
            if let Some((inst_len, parsed)) =
                FPRT32Var31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 64 {
            if let Some((inst_len, parsed)) =
                FPRT32Var32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 65 {
            if let Some((inst_len, parsed)) =
                FPRT32Var33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 66 {
            if let Some((inst_len, parsed)) =
                FPRT32Var34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 67 {
            if let Some((inst_len, parsed)) =
                FPRT32Var35::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var35(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 68 {
            if let Some((inst_len, parsed)) =
                FPRT32Var36::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var36(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 69 {
            if let Some((inst_len, parsed)) =
                FPRT32Var37::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var37(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 70 {
            if let Some((inst_len, parsed)) =
                FPRT32Var38::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var38(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 71 {
            if let Some((inst_len, parsed)) =
                FPRT32Var39::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var39(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 72 {
            if let Some((inst_len, parsed)) =
                FPRT32Var40::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var40(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 73 {
            if let Some((inst_len, parsed)) =
                FPRT32Var41::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var41(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 74 {
            if let Some((inst_len, parsed)) =
                FPRT32Var42::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var42(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 75 {
            if let Some((inst_len, parsed)) =
                FPRT32Var43::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var43(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 76 {
            if let Some((inst_len, parsed)) =
                FPRT32Var44::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var44(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 77 {
            if let Some((inst_len, parsed)) =
                FPRT32Var45::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var45(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 78 {
            if let Some((inst_len, parsed)) =
                FPRT32Var46::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var46(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 79 {
            if let Some((inst_len, parsed)) =
                FPRT32Var47::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var47(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 80 {
            if let Some((inst_len, parsed)) =
                FPRT32Var48::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var48(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 81 {
            if let Some((inst_len, parsed)) =
                FPRT32Var49::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var49(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 82 {
            if let Some((inst_len, parsed)) =
                FPRT32Var50::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var50(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 83 {
            if let Some((inst_len, parsed)) =
                FPRT32Var51::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var51(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 84 {
            if let Some((inst_len, parsed)) =
                FPRT32Var52::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var52(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 85 {
            if let Some((inst_len, parsed)) =
                FPRT32Var53::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var53(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 86 {
            if let Some((inst_len, parsed)) =
                FPRT32Var54::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var54(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 87 {
            if let Some((inst_len, parsed)) =
                FPRT32Var55::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var55(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 88 {
            if let Some((inst_len, parsed)) =
                FPRT32Var56::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var56(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 89 {
            if let Some((inst_len, parsed)) =
                FPRT32Var57::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var57(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 90 {
            if let Some((inst_len, parsed)) =
                FPRT32Var58::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var58(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 91 {
            if let Some((inst_len, parsed)) =
                FPRT32Var59::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var59(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 92 {
            if let Some((inst_len, parsed)) =
                FPRT32Var60::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var60(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 93 {
            if let Some((inst_len, parsed)) =
                FPRT32Var61::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var61(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 94 {
            if let Some((inst_len, parsed)) =
                FPRT32Var62::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var62(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 95) == 95 {
            if let Some((inst_len, parsed)) =
                FPRT32Var63::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var63(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1177:1, end:1177:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar0 {}
impl fpcmpVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",FALSE?")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1178:1, end:1178:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar1 {}
impl fpcmpVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",false")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1179:1, end:1179:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar2 {}
impl fpcmpVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",?")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1180:1, end:1180:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar3 {}
impl fpcmpVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!<=>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1181:1, end:1181:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar4 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1182:1, end:1182:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar5 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",=T")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1183:1, end:1183:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar6 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",?=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1184:1, end:1184:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar7 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!<>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1185:1, end:1185:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar8 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!?>=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1186:1, end:1186:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar9 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",<")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1187:1, end:1187:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar10 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",?<")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1188:1, end:1188:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar11 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!>=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1189:1, end:1189:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar12 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!?>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1190:1, end:1190:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar13 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",<=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1191:1, end:1191:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar14 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",?<=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1192:1, end:1192:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar15 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1193:1, end:1193:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar16 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!?<=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1194:1, end:1194:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar17 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1195:1, end:1195:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar18 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",?>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1196:1, end:1196:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar19 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!<=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1197:1, end:1197:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar20 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!?<")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1198:1, end:1198:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar21 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",>=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1199:1, end:1199:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar22 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",?>=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1200:1, end:1200:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar23 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!<;")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1201:1, end:1201:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar24 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!?=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1202:1, end:1202:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar25 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",<>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1203:1, end:1203:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar26 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1204:1, end:1204:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar27 {
    FPR232: TableFPR232,
    FPR132: TableFPR132,
}
impl fpcmpVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!=T")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR132 = if let Some((len, table)) =
            TableFPR132::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) =
            TableFPR232::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR232, FPR132 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1205:1, end:1205:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar28 {}
impl fpcmpVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!?")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1206:1, end:1206:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar29 {}
impl fpcmpVar29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",<=>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1207:1, end:1207:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar30 {}
impl fpcmpVar30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",TRUE?")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1208:1, end:1208:6))"]
#[derive(Clone, Debug)]
struct fpcmpVar31 {}
impl fpcmpVar31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",TRUE")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefpcmp {
    Var0(fpcmpVar0),
    Var1(fpcmpVar1),
    Var2(fpcmpVar2),
    Var3(fpcmpVar3),
    Var4(fpcmpVar4),
    Var5(fpcmpVar5),
    Var6(fpcmpVar6),
    Var7(fpcmpVar7),
    Var8(fpcmpVar8),
    Var9(fpcmpVar9),
    Var10(fpcmpVar10),
    Var11(fpcmpVar11),
    Var12(fpcmpVar12),
    Var13(fpcmpVar13),
    Var14(fpcmpVar14),
    Var15(fpcmpVar15),
    Var16(fpcmpVar16),
    Var17(fpcmpVar17),
    Var18(fpcmpVar18),
    Var19(fpcmpVar19),
    Var20(fpcmpVar20),
    Var21(fpcmpVar21),
    Var22(fpcmpVar22),
    Var23(fpcmpVar23),
    Var24(fpcmpVar24),
    Var25(fpcmpVar25),
    Var26(fpcmpVar26),
    Var27(fpcmpVar27),
    Var28(fpcmpVar28),
    Var29(fpcmpVar29),
    Var30(fpcmpVar30),
    Var31(fpcmpVar31),
}
impl Tablefpcmp {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                fpcmpVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 1 {
            if let Some((inst_len, parsed)) =
                fpcmpVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 2 {
            if let Some((inst_len, parsed)) =
                fpcmpVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 3 {
            if let Some((inst_len, parsed)) =
                fpcmpVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 4 {
            if let Some((inst_len, parsed)) =
                fpcmpVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 5 {
            if let Some((inst_len, parsed)) =
                fpcmpVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 6 {
            if let Some((inst_len, parsed)) =
                fpcmpVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 7 {
            if let Some((inst_len, parsed)) =
                fpcmpVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 8 {
            if let Some((inst_len, parsed)) =
                fpcmpVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 9 {
            if let Some((inst_len, parsed)) =
                fpcmpVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 10 {
            if let Some((inst_len, parsed)) =
                fpcmpVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 11 {
            if let Some((inst_len, parsed)) =
                fpcmpVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 12 {
            if let Some((inst_len, parsed)) =
                fpcmpVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 13 {
            if let Some((inst_len, parsed)) =
                fpcmpVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 14 {
            if let Some((inst_len, parsed)) =
                fpcmpVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 15 {
            if let Some((inst_len, parsed)) =
                fpcmpVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 16 {
            if let Some((inst_len, parsed)) =
                fpcmpVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 17 {
            if let Some((inst_len, parsed)) =
                fpcmpVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 18 {
            if let Some((inst_len, parsed)) =
                fpcmpVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 19 {
            if let Some((inst_len, parsed)) =
                fpcmpVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 20 {
            if let Some((inst_len, parsed)) =
                fpcmpVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 21 {
            if let Some((inst_len, parsed)) =
                fpcmpVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 22 {
            if let Some((inst_len, parsed)) =
                fpcmpVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 23 {
            if let Some((inst_len, parsed)) =
                fpcmpVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 24 {
            if let Some((inst_len, parsed)) =
                fpcmpVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 25 {
            if let Some((inst_len, parsed)) =
                fpcmpVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 26 {
            if let Some((inst_len, parsed)) =
                fpcmpVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 27 {
            if let Some((inst_len, parsed)) =
                fpcmpVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 28 {
            if let Some((inst_len, parsed)) =
                fpcmpVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 29 {
            if let Some((inst_len, parsed)) =
                fpcmpVar29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 30 {
            if let Some((inst_len, parsed)) =
                fpcmpVar30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 31 {
            if let Some((inst_len, parsed)) =
                fpcmpVar31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1210:1, end:1210:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var0 {}
impl fpcmp64Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",FALSE?")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1211:1, end:1211:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var1 {}
impl fpcmp64Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",false")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1212:1, end:1212:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var2 {}
impl fpcmp64Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",?")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1213:1, end:1213:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var3 {}
impl fpcmp64Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!<=>;")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1214:1, end:1214:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var4 {
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl fpcmp64Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR264, FPR164 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1215:1, end:1215:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var5 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",=T")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1216:1, end:1216:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var6 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",?=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1217:1, end:1217:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var7 {
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl fpcmp64Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!<>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR264, FPR164 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1218:1, end:1218:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var8 {
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl fpcmp64Var8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!?>=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR264, FPR164 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1219:1, end:1219:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var9 {
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl fpcmp64Var9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",<")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR264, FPR164 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1220:1, end:1220:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var10 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",?<")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1221:1, end:1221:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var11 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!>=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1222:1, end:1222:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var12 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!?>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1223:1, end:1223:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var13 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",<=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1224:1, end:1224:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var14 {
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl fpcmp64Var14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",?<=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR264, FPR164 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1225:1, end:1225:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var15 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1226:1, end:1226:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var16 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!?<=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1227:1, end:1227:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var17 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1228:1, end:1228:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var18 {
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl fpcmp64Var18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",?>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR264, FPR164 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1229:1, end:1229:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var19 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!<=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1230:1, end:1230:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var20 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!?<")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1231:1, end:1231:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var21 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",>=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1232:1, end:1232:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var22 {
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl fpcmp64Var22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",?>=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR264, FPR164 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1233:1, end:1233:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var23 {
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl fpcmp64Var23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!<")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR264, FPR164 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1234:1, end:1234:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var24 {
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl fpcmp64Var24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!?=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR264, FPR164 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1235:1, end:1235:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var25 {
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl fpcmp64Var25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",<>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR264, FPR164 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1236:1, end:1236:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var26 {
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl fpcmp64Var26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!=")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR264, FPR164 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1237:1, end:1237:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var27 {
    FPR264: TableFPR264,
    FPR164: TableFPR164,
}
impl fpcmp64Var27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!=T")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPR164 = if let Some((len, table)) =
            TableFPR164::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) =
            TableFPR264::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR264, FPR164 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1238:1, end:1238:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var28 {}
impl fpcmp64Var28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",!?")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1239:1, end:1239:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var29 {}
impl fpcmp64Var29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",<=>")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1240:1, end:1240:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var30 {}
impl fpcmp64Var30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",TRUE?")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1241:1, end:1241:8))"]
#[derive(Clone, Debug)]
struct fpcmp64Var31 {}
impl fpcmp64Var31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",TRUE")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefpcmp64 {
    Var0(fpcmp64Var0),
    Var1(fpcmp64Var1),
    Var2(fpcmp64Var2),
    Var3(fpcmp64Var3),
    Var4(fpcmp64Var4),
    Var5(fpcmp64Var5),
    Var6(fpcmp64Var6),
    Var7(fpcmp64Var7),
    Var8(fpcmp64Var8),
    Var9(fpcmp64Var9),
    Var10(fpcmp64Var10),
    Var11(fpcmp64Var11),
    Var12(fpcmp64Var12),
    Var13(fpcmp64Var13),
    Var14(fpcmp64Var14),
    Var15(fpcmp64Var15),
    Var16(fpcmp64Var16),
    Var17(fpcmp64Var17),
    Var18(fpcmp64Var18),
    Var19(fpcmp64Var19),
    Var20(fpcmp64Var20),
    Var21(fpcmp64Var21),
    Var22(fpcmp64Var22),
    Var23(fpcmp64Var23),
    Var24(fpcmp64Var24),
    Var25(fpcmp64Var25),
    Var26(fpcmp64Var26),
    Var27(fpcmp64Var27),
    Var28(fpcmp64Var28),
    Var29(fpcmp64Var29),
    Var30(fpcmp64Var30),
    Var31(fpcmp64Var31),
}
impl Tablefpcmp64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 1 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 2 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 3 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 4 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 5 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 6 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 7 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 8 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 9 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 10 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 11 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 12 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 13 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 14 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 15 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 16 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 17 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 18 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 19 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 20 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 21 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 22 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 23 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 24 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 25 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 26 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 27 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 28 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 29 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 30 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 31 {
            if let Some((inst_len, parsed)) =
                fpcmp64Var31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1247:1, end:1247:3))"]
#[derive(Clone, Debug)]
struct SRVar0 {}
impl SRVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("srN")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1248:1, end:1248:3))"]
#[derive(Clone, Debug)]
struct SRVar1 {}
impl SRVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1249:1, end:1249:3))"]
#[derive(Clone, Debug)]
struct SRVar2 {}
impl SRVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1250:1, end:1250:3))"]
#[derive(Clone, Debug)]
struct SRVar3 {}
impl SRVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSR {
    Var0(SRVar0),
    Var1(SRVar1),
    Var2(SRVar2),
    Var3(SRVar3),
}
impl TableSR {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                SRVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                SRVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                SRVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                SRVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1252:1, end:1252:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar0 {}
impl SR3bitVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1253:1, end:1253:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar1 {}
impl SR3bitVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1254:1, end:1254:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar2 {}
impl SR3bitVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1255:1, end:1255:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar3 {}
impl SR3bitVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1256:1, end:1256:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar4 {}
impl SR3bitVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1257:1, end:1257:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar5 {}
impl SR3bitVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1258:1, end:1258:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar6 {}
impl SR3bitVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1259:1, end:1259:7))"]
#[derive(Clone, Debug)]
struct SR3bitVar7 {}
impl SR3bitVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSR3bit {
    Var0(SR3bitVar0),
    Var1(SR3bitVar1),
    Var2(SR3bitVar2),
    Var3(SR3bitVar3),
    Var4(SR3bitVar4),
    Var5(SR3bitVar5),
    Var6(SR3bitVar6),
    Var7(SR3bitVar7),
}
impl TableSR3bit {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                SR3bitVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                SR3bitVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 {
            if let Some((inst_len, parsed)) =
                SR3bitVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                SR3bitVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                SR3bitVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                SR3bitVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 {
            if let Some((inst_len, parsed)) =
                SR3bitVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                SR3bitVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1264:1, end:1264:5))"]
#[derive(Clone, Debug)]
struct SRRBVar0 {
    RB: TableRB,
}
impl SRRBVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1266:1, end:1266:5))"]
#[derive(Clone, Debug)]
struct SRRBVar1 {
    SR: TableSR,
    RB: TableRB,
}
impl SRRBVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SR = if let Some((len, table)) =
            TableSR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR, RB }))
    }
}
#[derive(Clone, Debug)]
enum TableSRRB {
    Var0(SRRBVar0),
    Var1(SRRBVar1),
}
impl TableSRRB {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                SRRBVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                SRRBVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1269:1, end:1269:9))"]
#[derive(Clone, Debug)]
struct SRRB3bitVar0 {
    RB: TableRB,
    SR3bit: TableSR3bit,
}
impl SRRB3bitVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SR3bit = if let Some((len, table)) =
            TableSR3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB, SR3bit }))
    }
}
#[derive(Clone, Debug)]
enum TableSRRB3bit {
    Var0(SRRB3bitVar0),
}
impl TableSRRB3bit {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                SRRB3bitVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1274:1, end:1274:6))"]
#[derive(Clone, Debug)]
struct SRVALVar0 {
    SR: TableSR,
    RB: TableRB,
}
impl SRVALVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.SR
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SR = if let Some((len, table)) =
            TableSR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR, RB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1281:1, end:1281:6))"]
#[derive(Clone, Debug)]
struct SRVALVar1 {}
impl SRVALVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1282:1, end:1282:6))"]
#[derive(Clone, Debug)]
struct SRVALVar2 {}
impl SRVALVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1283:1, end:1283:6))"]
#[derive(Clone, Debug)]
struct SRVALVar3 {}
impl SRVALVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sr3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSRVAL {
    Var0(SRVALVar0),
    Var1(SRVALVar1),
    Var2(SRVALVar2),
    Var3(SRVALVar3),
}
impl TableSRVAL {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                SRVALVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                SRVALVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                SRVALVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                SRVALVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1286:1, end:1286:8))"]
#[derive(Clone, Debug)]
struct SPCBASEVar0 {
    SRVAL: TableSRVAL,
    RB: TableRB,
}
impl SPCBASEVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SRVAL = if let Some((len, table)) =
            TableSRVAL::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SRVAL, RB }))
    }
}
#[derive(Clone, Debug)]
enum TableSPCBASE {
    Var0(SPCBASEVar0),
}
impl TableSPCBASE {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                SPCBASEVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1298:1, end:1298:15))"]
#[derive(Clone, Debug)]
struct displacement2WVar0 {
    w: u8,
    w2: u16,
}
impl displacement2WVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_target: i128 = 0;
        calc_target = 1i128
            .wrapping_sub(i128::try_from(self.w).unwrap().wrapping_mul(2i128))
            .wrapping_mul(
                (u32::try_from(10i128)
                    .ok()
                    .and_then(|shl| (i128::try_from(self.w2).unwrap() & 1i128).checked_shl(shl))
                    .unwrap_or(0)
                    | (u32::try_from(1i128)
                        .ok()
                        .and_then(|shr| i128::try_from(self.w2).unwrap().checked_shr(shr))
                        .unwrap_or(0)
                        & 1023i128)),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_target.is_negative(),
            calc_target.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 4;
        calc_target = 1i128
            .wrapping_sub(
                i128::try_from(token_57(tokens_current))
                    .unwrap()
                    .wrapping_mul(2i128),
            )
            .wrapping_mul(
                (u32::try_from(10i128)
                    .ok()
                    .and_then(|shl| {
                        (i128::try_from(token_43(tokens_current)).unwrap() & 1i128).checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | (u32::try_from(1i128)
                        .ok()
                        .and_then(|shr| {
                            i128::try_from(token_43(tokens_current))
                                .unwrap()
                                .checked_shr(shr)
                        })
                        .unwrap_or(0)
                        & 1023i128)),
            );
        let w = token_57(tokens_current);
        let w2 = token_43(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { w, w2 }))
    }
}
#[derive(Clone, Debug)]
enum Tabledisplacement2W {
    Var0(displacement2WVar0),
}
impl Tabledisplacement2W {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                displacement2WVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1304:1, end:1304:15))"]
#[derive(Clone, Debug)]
struct branchTarget2WVar0 {
    w: u8,
    w2_2: u8,
    w2less2: u16,
}
impl branchTarget2WVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_target: i128 = 0;
        calc_target = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    ((u32::try_from(11i128)
                        .ok()
                        .and_then(|shl| {
                            (-1i128)
                                .wrapping_mul(i128::try_from(self.w).unwrap())
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)
                        | u32::try_from(10i128)
                            .ok()
                            .and_then(|shl| i128::try_from(self.w2_2).unwrap().checked_shl(shl))
                            .unwrap_or(0))
                        | i128::try_from(self.w2less2).unwrap()),
                ),
            );
        global_set.set(Some(inst_next), |context| {
            context.write_branchImmDest(
                u32::try_from(i128::try_from(context.read_branchImmDest()).unwrap() & 4294967295)
                    .unwrap(),
            )
        });
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_target.is_negative(),
            calc_target.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 4;
        calc_target = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    ((u32::try_from(11i128)
                        .ok()
                        .and_then(|shl| {
                            (-1i128)
                                .wrapping_mul(i128::try_from(token_57(tokens_current)).unwrap())
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)
                        | u32::try_from(10i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(token_44(tokens_current))
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0))
                        | i128::try_from(token_45(tokens_current)).unwrap()),
                ),
            );
        context_instance.write_temp32(
            u32::try_from(
                i128::try_from(context_instance.read_branchImmDest()).unwrap() & 4294967295,
            )
            .unwrap(),
        );
        context_instance.write_branchImmDest(u32::try_from(calc_target & 4294967295).unwrap());
        let w2less2 = token_45(tokens_current);
        let w = token_57(tokens_current);
        let w2_2 = token_44(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { w, w2_2, w2less2 }))
    }
}
#[derive(Clone, Debug)]
enum TablebranchTarget2W {
    Var0(branchTarget2WVar0),
}
impl TablebranchTarget2W {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                branchTarget2WVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1322:1, end:1322:15))"]
#[derive(Clone, Debug)]
struct displacement3WVar0 {
    w: u8,
    w1: u8,
    w2_2: u8,
    w2less2: u16,
}
impl displacement3WVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_target: i128 = 0;
        calc_target = 4i128.wrapping_mul(
            (((u32::try_from(16i128)
                .ok()
                .and_then(|shl| {
                    (-1i128)
                        .wrapping_mul(i128::try_from(self.w).unwrap())
                        .checked_shl(shl)
                })
                .unwrap_or(0)
                | u32::try_from(11i128)
                    .ok()
                    .and_then(|shl| i128::try_from(self.w1).unwrap().checked_shl(shl))
                    .unwrap_or(0))
                | u32::try_from(10i128)
                    .ok()
                    .and_then(|shl| i128::try_from(self.w2_2).unwrap().checked_shl(shl))
                    .unwrap_or(0))
                | i128::try_from(self.w2less2).unwrap()),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_target.is_negative(),
            calc_target.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 4;
        calc_target = 4i128.wrapping_mul(
            (((u32::try_from(16i128)
                .ok()
                .and_then(|shl| {
                    (-1i128)
                        .wrapping_mul(i128::try_from(token_57(tokens_current)).unwrap())
                        .checked_shl(shl)
                })
                .unwrap_or(0)
                | u32::try_from(11i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(token_6(tokens_current))
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0))
                | u32::try_from(10i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(token_44(tokens_current))
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0))
                | i128::try_from(token_45(tokens_current)).unwrap()),
        );
        let w = token_57(tokens_current);
        let w2_2 = token_44(tokens_current);
        let w1 = token_6(tokens_current);
        let w2less2 = token_45(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                w,
                w1,
                w2_2,
                w2less2,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tabledisplacement3W {
    Var0(displacement3WVar0),
}
impl Tabledisplacement3W {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                displacement3WVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1332:1, end:1332:15))"]
#[derive(Clone, Debug)]
struct branchTarget3WVar0 {
    w: u8,
    w1: u8,
    w2_2: u8,
    w2less2: u16,
}
impl branchTarget3WVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_target: i128 = 0;
        calc_target = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    (((u32::try_from(16i128)
                        .ok()
                        .and_then(|shl| {
                            (-1i128)
                                .wrapping_mul(i128::try_from(self.w).unwrap())
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)
                        | u32::try_from(11i128)
                            .ok()
                            .and_then(|shl| i128::try_from(self.w1).unwrap().checked_shl(shl))
                            .unwrap_or(0))
                        | u32::try_from(10i128)
                            .ok()
                            .and_then(|shl| i128::try_from(self.w2_2).unwrap().checked_shl(shl))
                            .unwrap_or(0))
                        | i128::try_from(self.w2less2).unwrap()),
                ),
            );
        global_set.set(Some(inst_next), |context| {
            context.write_branchImmDest(
                u32::try_from(i128::try_from(context.read_branchImmDest()).unwrap() & 4294967295)
                    .unwrap(),
            )
        });
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_target.is_negative(),
            calc_target.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 4;
        calc_target = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    (((u32::try_from(16i128)
                        .ok()
                        .and_then(|shl| {
                            (-1i128)
                                .wrapping_mul(i128::try_from(token_57(tokens_current)).unwrap())
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)
                        | u32::try_from(11i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(token_6(tokens_current))
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0))
                        | u32::try_from(10i128)
                            .ok()
                            .and_then(|shl| {
                                i128::try_from(token_44(tokens_current))
                                    .unwrap()
                                    .checked_shl(shl)
                            })
                            .unwrap_or(0))
                        | i128::try_from(token_45(tokens_current)).unwrap()),
                ),
            );
        context_instance.write_temp32(
            u32::try_from(
                i128::try_from(context_instance.read_branchImmDest()).unwrap() & 4294967295,
            )
            .unwrap(),
        );
        context_instance.write_branchImmDest(u32::try_from(calc_target & 4294967295).unwrap());
        let w1 = token_6(tokens_current);
        let w2less2 = token_45(tokens_current);
        let w = token_57(tokens_current);
        let w2_2 = token_44(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                w,
                w1,
                w2_2,
                w2less2,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TablebranchTarget3W {
    Var0(branchTarget3WVar0),
}
impl TablebranchTarget3W {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                branchTarget3WVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1349:1, end:1349:24))"]
#[derive(Clone, Debug)]
struct IPRelativeIndexedTargetVar0 {
    RX: TableRX,
}
impl IPRelativeIndexedTargetVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX }))
    }
}
#[derive(Clone, Debug)]
enum TableIPRelativeIndexedTarget {
    Var0(IPRelativeIndexedTargetVar0),
}
impl TableIPRelativeIndexedTarget {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                IPRelativeIndexedTargetVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1357:1, end:1357:14))"]
#[derive(Clone, Debug)]
struct IndexedTargetVar0 {
    RB: TableRB,
    RX: TableRX,
}
impl IndexedTargetVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB, RX }))
    }
}
#[derive(Clone, Debug)]
enum TableIndexedTarget {
    Var0(IndexedTargetVar0),
}
impl TableIndexedTarget {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                IndexedTargetVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1365:1, end:1365:13))"]
#[derive(Clone, Debug)]
struct ReturnTargetVar0 {
    RB: TableRB,
}
impl ReturnTargetVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB }))
    }
}
#[derive(Clone, Debug)]
enum TableReturnTarget {
    Var0(ReturnTargetVar0),
}
impl TableReturnTarget {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                ReturnTargetVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1372:1, end:1372:15))"]
#[derive(Clone, Debug)]
struct externalTargetVar0 {
    displacement3W: Tabledisplacement3W,
    SRRB3bit: TableSRRB3bit,
    RB: TableRB,
}
impl externalTargetVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.displacement3W
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB3bit
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let displacement3W = if let Some((len, table)) =
            Tabledisplacement3W::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) =
            TableSRRB3bit::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                displacement3W,
                SRRB3bit,
                RB,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableexternalTarget {
    Var0(externalTargetVar0),
}
impl TableexternalTarget {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                externalTargetVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1383:1, end:1383:7))"]
#[derive(Clone, Debug)]
struct shiftCVar0 {
    cp: u8,
}
impl shiftCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_shift: i128 = 0;
        calc_shift = 31i128.wrapping_sub(i128::try_from(self.cp).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_shift.is_negative(),
            calc_shift.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_shift: i128 = 0;
        let mut block_0_len = 4;
        calc_shift = 31i128.wrapping_sub(i128::try_from(token_41(tokens_current)).unwrap());
        let cp = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cp }))
    }
}
#[derive(Clone, Debug)]
enum TableshiftC {
    Var0(shiftCVar0),
}
impl TableshiftC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                shiftCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1384:1, end:1384:10))"]
#[derive(Clone, Debug)]
struct shiftCLenVar0 {
    im5: u8,
}
impl shiftCLenVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_shift: i128 = 0;
        calc_shift = 32i128.wrapping_sub(i128::try_from(self.im5).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_shift.is_negative(),
            calc_shift.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_shift: i128 = 0;
        let mut block_0_len = 4;
        calc_shift = 32i128.wrapping_sub(i128::try_from(token_55(tokens_current)).unwrap());
        let im5 = token_55(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im5 }))
    }
}
#[derive(Clone, Debug)]
enum TableshiftCLen {
    Var0(shiftCLenVar0),
}
impl TableshiftCLen {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                shiftCLenVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1388:1, end:1388:6))"]
#[derive(Clone, Debug)]
struct lse14Var0 {
    bit0: u8,
    im14less0: u16,
}
impl lse14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off: i128 = 0;
        calc_off = (u32::try_from(13i128)
            .ok()
            .and_then(|shl| {
                (-1i128)
                    .wrapping_mul(i128::try_from(self.bit0).unwrap())
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(self.im14less0).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_off.is_negative(),
            calc_off.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 4;
        calc_off = (u32::try_from(13i128)
            .ok()
            .and_then(|shl| {
                (-1i128)
                    .wrapping_mul(i128::try_from(token_57(tokens_current)).unwrap())
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_53(tokens_current)).unwrap());
        let bit0 = token_57(tokens_current);
        let im14less0 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bit0, im14less0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelse14 {
    Var0(lse14Var0),
}
impl Tablelse14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                lse14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1392:1, end:1392:5))"]
#[derive(Clone, Debug)]
struct lse5Var0 {
    bit0: u8,
    im5less0: u8,
}
impl lse5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off: i128 = 0;
        calc_off = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                (-1i128)
                    .wrapping_mul(i128::try_from(self.bit0).unwrap())
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(self.im5less0).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_off.is_negative(),
            calc_off.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 4;
        calc_off = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                (-1i128)
                    .wrapping_mul(i128::try_from(token_57(tokens_current)).unwrap())
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_56(tokens_current)).unwrap());
        let im5less0 = token_56(tokens_current);
        let bit0 = token_57(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bit0, im5less0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelse5 {
    Var0(lse5Var0),
}
impl Tablelse5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                lse5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1395:1, end:1395:9))"]
#[derive(Clone, Debug)]
struct highlse5Var0 {
    bit16: u8,
    highIm5less16: u8,
}
impl highlse5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off: i128 = 0;
        calc_off = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                (-1i128)
                    .wrapping_mul(i128::try_from(self.bit16).unwrap())
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(self.highIm5less16).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_off.is_negative(),
            calc_off.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 4;
        calc_off = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                (-1i128)
                    .wrapping_mul(i128::try_from(token_7(tokens_current)).unwrap())
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_4(tokens_current)).unwrap());
        let highIm5less16 = token_4(tokens_current);
        let bit16 = token_7(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bit16,
                highIm5less16,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tablehighlse5 {
    Var0(highlse5Var0),
}
impl Tablehighlse5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                highlse5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1398:1, end:1398:6))"]
#[derive(Clone, Debug)]
struct lse21Var0 {
    bit0: u8,
    im21_1_12: u16,
    im21_14_16: u8,
    im21_16_21: u8,
    im21_12_14: u8,
}
impl lse21Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off: i128 = 0;
        calc_off = u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                ((((u32::try_from(20i128)
                    .ok()
                    .and_then(|shl| {
                        (-1i128)
                            .wrapping_mul(i128::try_from(self.bit0).unwrap())
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | u32::try_from(9i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.im21_1_12).unwrap().checked_shl(shl))
                        .unwrap_or(0))
                    | u32::try_from(7i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.im21_14_16).unwrap().checked_shl(shl))
                        .unwrap_or(0))
                    | u32::try_from(2i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.im21_16_21).unwrap().checked_shl(shl))
                        .unwrap_or(0))
                    | i128::try_from(self.im21_12_14).unwrap())
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_off.is_negative(),
            calc_off.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 4;
        calc_off = u32::try_from(11i128)
            .ok()
            .and_then(|shl| {
                ((((u32::try_from(20i128)
                    .ok()
                    .and_then(|shl| {
                        (-1i128)
                            .wrapping_mul(i128::try_from(token_57(tokens_current)).unwrap())
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | u32::try_from(9i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_51(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(7i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_10(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(2i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_6(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | i128::try_from(token_52(tokens_current)).unwrap())
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let im21_12_14 = token_52(tokens_current);
        let im21_1_12 = token_51(tokens_current);
        let im21less0 = token_50(tokens_current);
        let bit0 = token_57(tokens_current);
        let im21_14_16 = token_10(tokens_current);
        let im21_16_21 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bit0,
                im21_1_12,
                im21_14_16,
                im21_16_21,
                im21_12_14,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tablelse21 {
    Var0(lse21Var0),
}
impl Tablelse21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                lse21Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1414:1, end:1414:6))"]
#[derive(Clone, Debug)]
struct lse11Var0 {
    bit0: u8,
    im11less0: u16,
}
impl lse11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_immed: i128 = 0;
        calc_immed = (u32::try_from(10i128)
            .ok()
            .and_then(|shl| {
                (-1i128)
                    .wrapping_mul(i128::try_from(self.bit0).unwrap())
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(self.im11less0).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_immed.is_negative(),
            calc_immed.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_immed: i128 = 0;
        let mut block_0_len = 4;
        calc_immed = (u32::try_from(10i128)
            .ok()
            .and_then(|shl| {
                (-1i128)
                    .wrapping_mul(i128::try_from(token_57(tokens_current)).unwrap())
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_51(tokens_current)).unwrap());
        context_instance.write_temp32(u32::try_from(calc_immed & 4294967295).unwrap());
        let im11less0 = token_51(tokens_current);
        let bit0 = token_57(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bit0, im11less0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelse11 {
    Var0(lse11Var0),
}
impl Tablelse11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                lse11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1419:1, end:1419:12))"]
#[derive(Clone, Debug)]
struct OFF_BASE_14Var0 {
    SPCBASE: TableSPCBASE,
    lse14: Tablelse14,
    SRRB: TableSRRB,
}
impl OFF_BASE_14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.lse14
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SRRB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SPCBASE,
                lse14,
                SRRB,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableOFF_BASE_14 {
    Var0(OFF_BASE_14Var0),
}
impl TableOFF_BASE_14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                OFF_BASE_14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1426:1, end:1426:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar0 {}
impl ShiftCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1427:1, end:1427:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar1 {
    RT: TableRT,
}
impl ShiftCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1428:1, end:1428:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar2 {
    RT: TableRT,
}
impl ShiftCondVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1429:1, end:1429:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar3 {
    RT: TableRT,
}
impl ShiftCondVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1430:1, end:1430:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar4 {}
impl ShiftCondVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1431:1, end:1431:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar5 {
    RT: TableRT,
}
impl ShiftCondVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1432:1, end:1432:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar6 {
    RT: TableRT,
}
impl ShiftCondVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1433:1, end:1433:10))"]
#[derive(Clone, Debug)]
struct ShiftCondVar7 {
    RT: TableRT,
}
impl ShiftCondVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[derive(Clone, Debug)]
enum TableShiftCond {
    Var0(ShiftCondVar0),
    Var1(ShiftCondVar1),
    Var2(ShiftCondVar2),
    Var3(ShiftCondVar3),
    Var4(ShiftCondVar4),
    Var5(ShiftCondVar5),
    Var6(ShiftCondVar6),
    Var7(ShiftCondVar7),
}
impl TableShiftCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                ShiftCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                ShiftCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                ShiftCondVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                ShiftCondVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 {
            if let Some((inst_len, parsed)) =
                ShiftCondVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 {
            if let Some((inst_len, parsed)) =
                ShiftCondVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                ShiftCondVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                ShiftCondVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1435:1, end:1435:17))"]
#[derive(Clone, Debug)]
struct ShiftCondNullifyVar0 {}
impl ShiftCondNullifyVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1436:1, end:1436:17))"]
#[derive(Clone, Debug)]
struct ShiftCondNullifyVar1 {
    ShiftCond: TableShiftCond,
}
impl ShiftCondNullifyVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_nullifyEnable(
                u8::try_from(i128::try_from(context.read_nullifyEnable()).unwrap() & 1).unwrap(),
            )
        });
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_nullifyEnable(u8::try_from(1i128 & 1).unwrap());
        let ShiftCond = if let Some((len, table)) =
            TableShiftCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ShiftCond }))
    }
}
#[derive(Clone, Debug)]
enum TableShiftCondNullify {
    Var0(ShiftCondNullifyVar0),
    Var1(ShiftCondNullifyVar1),
}
impl TableShiftCondNullify {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                ShiftCondNullifyVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                ShiftCondNullifyVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1442:1, end:1442:8))"]
#[derive(Clone, Debug)]
struct DepCondVar0 {}
impl DepCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1443:1, end:1443:8))"]
#[derive(Clone, Debug)]
struct DepCondVar1 {}
impl DepCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1444:1, end:1444:8))"]
#[derive(Clone, Debug)]
struct DepCondVar2 {}
impl DepCondVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1445:1, end:1445:8))"]
#[derive(Clone, Debug)]
struct DepCondVar3 {}
impl DepCondVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1446:1, end:1446:8))"]
#[derive(Clone, Debug)]
struct DepCondVar4 {}
impl DepCondVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1447:1, end:1447:8))"]
#[derive(Clone, Debug)]
struct DepCondVar5 {}
impl DepCondVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1448:1, end:1448:8))"]
#[derive(Clone, Debug)]
struct DepCondVar6 {}
impl DepCondVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1449:1, end:1449:8))"]
#[derive(Clone, Debug)]
struct DepCondVar7 {}
impl DepCondVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableDepCond {
    Var0(DepCondVar0),
    Var1(DepCondVar1),
    Var2(DepCondVar2),
    Var3(DepCondVar3),
    Var4(DepCondVar4),
    Var5(DepCondVar5),
    Var6(DepCondVar6),
    Var7(DepCondVar7),
}
impl TableDepCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                DepCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                DepCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                DepCondVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                DepCondVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 {
            if let Some((inst_len, parsed)) =
                DepCondVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 {
            if let Some((inst_len, parsed)) =
                DepCondVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                DepCondVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                DepCondVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1451:1, end:1451:15))"]
#[derive(Clone, Debug)]
struct DepCondNullifyVar0 {}
impl DepCondNullifyVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1452:1, end:1452:15))"]
#[derive(Clone, Debug)]
struct DepCondNullifyVar1 {
    DepCond: TableDepCond,
}
impl DepCondNullifyVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_nullifyEnable(
                u8::try_from(i128::try_from(context.read_nullifyEnable()).unwrap() & 1).unwrap(),
            )
        });
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_nullifyEnable(u8::try_from(1i128 & 1).unwrap());
        let DepCond = if let Some((len, table)) =
            TableDepCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { DepCond }))
    }
}
#[derive(Clone, Debug)]
enum TableDepCondNullify {
    Var0(DepCondNullifyVar0),
    Var1(DepCondNullifyVar1),
}
impl TableDepCondNullify {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                DepCondNullifyVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DepCondNullifyVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1458:1, end:1458:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar0 {}
impl ExtrCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1459:1, end:1459:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar1 {}
impl ExtrCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1460:1, end:1460:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar2 {}
impl ExtrCondVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1461:1, end:1461:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar3 {}
impl ExtrCondVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1462:1, end:1462:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar4 {}
impl ExtrCondVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1463:1, end:1463:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar5 {}
impl ExtrCondVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1464:1, end:1464:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar6 {}
impl ExtrCondVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1465:1, end:1465:9))"]
#[derive(Clone, Debug)]
struct ExtrCondVar7 {}
impl ExtrCondVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableExtrCond {
    Var0(ExtrCondVar0),
    Var1(ExtrCondVar1),
    Var2(ExtrCondVar2),
    Var3(ExtrCondVar3),
    Var4(ExtrCondVar4),
    Var5(ExtrCondVar5),
    Var6(ExtrCondVar6),
    Var7(ExtrCondVar7),
}
impl TableExtrCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                ExtrCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                ExtrCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                ExtrCondVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                ExtrCondVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 {
            if let Some((inst_len, parsed)) =
                ExtrCondVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 {
            if let Some((inst_len, parsed)) =
                ExtrCondVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                ExtrCondVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                ExtrCondVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1467:1, end:1467:16))"]
#[derive(Clone, Debug)]
struct ExtrCondNullifyVar0 {}
impl ExtrCondNullifyVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1468:1, end:1468:16))"]
#[derive(Clone, Debug)]
struct ExtrCondNullifyVar1 {
    ExtrCond: TableExtrCond,
}
impl ExtrCondNullifyVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_nullifyEnable(
                u8::try_from(i128::try_from(context.read_nullifyEnable()).unwrap() & 1).unwrap(),
            )
        });
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_nullifyEnable(u8::try_from(1i128 & 1).unwrap());
        let ExtrCond = if let Some((len, table)) =
            TableExtrCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ExtrCond }))
    }
}
#[derive(Clone, Debug)]
enum TableExtrCondNullify {
    Var0(ExtrCondNullifyVar0),
    Var1(ExtrCondNullifyVar1),
}
impl TableExtrCondNullify {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                ExtrCondNullifyVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                ExtrCondNullifyVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1475:1, end:1475:8))"]
#[derive(Clone, Debug)]
struct BVBCondVar0 {
    R1: TableR1,
}
impl BVBCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1476:1, end:1476:8))"]
#[derive(Clone, Debug)]
struct BVBCondVar1 {
    R1: TableR1,
}
impl BVBCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[derive(Clone, Debug)]
enum TableBVBCond {
    Var0(BVBCondVar0),
    Var1(BVBCondVar1),
}
impl TableBVBCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                BVBCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                BVBCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1478:1, end:1478:7))"]
#[derive(Clone, Debug)]
struct BBCondVar0 {
    R1: TableR1,
}
impl BBCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let bboffset = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1479:1, end:1479:7))"]
#[derive(Clone, Debug)]
struct BBCondVar1 {
    R1: TableR1,
}
impl BBCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let bboffset = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[derive(Clone, Debug)]
enum TableBBCond {
    Var0(BBCondVar0),
    Var1(BBCondVar1),
}
impl TableBBCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                BBCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                BBCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1484:1, end:1484:12))"]
#[derive(Clone, Debug)]
struct RegUnitCondVar0 {}
impl RegUnitCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1485:1, end:1485:12))"]
#[derive(Clone, Debug)]
struct RegUnitCondVar1 {
    RT: TableRT,
}
impl RegUnitCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1486:1, end:1486:12))"]
#[derive(Clone, Debug)]
struct RegUnitCondVar2 {
    RT: TableRT,
}
impl RegUnitCondVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1487:1, end:1487:12))"]
#[derive(Clone, Debug)]
struct RegUnitCondVar3 {}
impl RegUnitCondVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1488:1, end:1488:12))"]
#[derive(Clone, Debug)]
struct RegUnitCondVar4 {}
impl RegUnitCondVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1489:1, end:1489:12))"]
#[derive(Clone, Debug)]
struct RegUnitCondVar5 {}
impl RegUnitCondVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableRegUnitCond {
    Var0(RegUnitCondVar0),
    Var1(RegUnitCondVar1),
    Var2(RegUnitCondVar2),
    Var3(RegUnitCondVar3),
    Var4(RegUnitCondVar4),
    Var5(RegUnitCondVar5),
}
impl TableRegUnitCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                RegUnitCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                RegUnitCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                RegUnitCondVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 {
            if let Some((inst_len, parsed)) =
                RegUnitCondVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                RegUnitCondVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                RegUnitCondVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1491:1, end:1491:9))"]
#[derive(Clone, Debug)]
struct UnitCondVar0 {
    RegUnitCond: TableRegUnitCond,
}
impl UnitCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegUnitCond = if let Some((len, table)) =
            TableRegUnitCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegUnitCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1492:1, end:1492:9))"]
#[derive(Clone, Debug)]
struct UnitCondVar1 {
    RegUnitCond: TableRegUnitCond,
}
impl UnitCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegUnitCond = if let Some((len, table)) =
            TableRegUnitCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegUnitCond }))
    }
}
#[derive(Clone, Debug)]
enum TableUnitCond {
    Var0(UnitCondVar0),
    Var1(UnitCondVar1),
}
impl TableUnitCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                UnitCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                UnitCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1494:1, end:1494:16))"]
#[derive(Clone, Debug)]
struct UnitCondNullifyVar0 {}
impl UnitCondNullifyVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1495:1, end:1495:16))"]
#[derive(Clone, Debug)]
struct UnitCondNullifyVar1 {
    UnitCond: TableUnitCond,
}
impl UnitCondNullifyVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_nullifyEnable(
                u8::try_from(i128::try_from(context.read_nullifyEnable()).unwrap() & 1).unwrap(),
            )
        });
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_nullifyEnable(u8::try_from(1i128 & 1).unwrap());
        let UnitCond = if let Some((len, table)) =
            TableUnitCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { UnitCond }))
    }
}
#[derive(Clone, Debug)]
enum TableUnitCondNullify {
    Var0(UnitCondNullifyVar0),
    Var1(UnitCondNullifyVar1),
}
impl TableUnitCondNullify {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                UnitCondNullifyVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                UnitCondNullifyVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1500:1, end:1500:12))"]
#[derive(Clone, Debug)]
struct UnitCondSymVar0 {
    RegUnitCondSym: u8,
}
impl UnitCondSymVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_10_display(self.RegUnitCondSym)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegUnitCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegUnitCondSym }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1501:1, end:1501:12))"]
#[derive(Clone, Debug)]
struct UnitCondSymVar1 {
    InvUnitCondSym: u8,
}
impl UnitCondSymVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_11_display(self.InvUnitCondSym)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let InvUnitCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { InvUnitCondSym }))
    }
}
#[derive(Clone, Debug)]
enum TableUnitCondSym {
    Var0(UnitCondSymVar0),
    Var1(UnitCondSymVar1),
}
impl TableUnitCondSym {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                UnitCondSymVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                UnitCondSymVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1506:1, end:1506:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar0 {}
impl RegAddCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1507:1, end:1507:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar1 {
    R2: TableR2,
    R1: TableR1,
}
impl RegAddCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1508:1, end:1508:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar2 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1509:1, end:1509:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar3 {
    R2: TableR2,
    R1: TableR1,
}
impl RegAddCondVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1510:1, end:1510:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar4 {
    R2: TableR2,
    R1: TableR1,
}
impl RegAddCondVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1511:1, end:1511:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar5 {
    R2: TableR2,
    R1: TableR1,
}
impl RegAddCondVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1512:1, end:1512:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar6 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1513:1, end:1513:11))"]
#[derive(Clone, Debug)]
struct RegAddCondVar7 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegAddCond {
    Var0(RegAddCondVar0),
    Var1(RegAddCondVar1),
    Var2(RegAddCondVar2),
    Var3(RegAddCondVar3),
    Var4(RegAddCondVar4),
    Var5(RegAddCondVar5),
    Var6(RegAddCondVar6),
    Var7(RegAddCondVar7),
}
impl TableRegAddCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                RegAddCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                RegAddCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                RegAddCondVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                RegAddCondVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 {
            if let Some((inst_len, parsed)) =
                RegAddCondVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 {
            if let Some((inst_len, parsed)) =
                RegAddCondVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                RegAddCondVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                RegAddCondVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1515:1, end:1515:8))"]
#[derive(Clone, Debug)]
struct AddCondVar0 {
    RegAddCond: TableRegAddCond,
}
impl AddCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegAddCond = if let Some((len, table)) =
            TableRegAddCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1516:1, end:1516:8))"]
#[derive(Clone, Debug)]
struct AddCondVar1 {
    RegAddCond: TableRegAddCond,
}
impl AddCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegAddCond = if let Some((len, table)) =
            TableRegAddCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCond }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCond {
    Var0(AddCondVar0),
    Var1(AddCondVar1),
}
impl TableAddCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                AddCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                AddCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1518:1, end:1518:15))"]
#[derive(Clone, Debug)]
struct AddCondNullifyVar0 {}
impl AddCondNullifyVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1519:1, end:1519:15))"]
#[derive(Clone, Debug)]
struct AddCondNullifyVar1 {
    AddCond: TableAddCond,
}
impl AddCondNullifyVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_nullifyEnable(
                u8::try_from(i128::try_from(context.read_nullifyEnable()).unwrap() & 1).unwrap(),
            )
        });
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_nullifyEnable(u8::try_from(1i128 & 1).unwrap());
        let AddCond = if let Some((len, table)) =
            TableAddCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AddCond }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCondNullify {
    Var0(AddCondNullifyVar0),
    Var1(AddCondNullifyVar1),
}
impl TableAddCondNullify {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                AddCondNullifyVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                AddCondNullifyVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1524:1, end:1524:11))"]
#[derive(Clone, Debug)]
struct AddCondSymVar0 {
    RegAddCondSym: u8,
}
impl AddCondSymVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_14_display(self.RegAddCondSym)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegAddCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCondSym }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1525:1, end:1525:11))"]
#[derive(Clone, Debug)]
struct AddCondSymVar1 {
    InvAddCondSym: u8,
}
impl AddCondSymVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_15_display(self.InvAddCondSym)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let InvAddCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { InvAddCondSym }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCondSym {
    Var0(AddCondSymVar0),
    Var1(AddCondSymVar1),
}
impl TableAddCondSym {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                AddCondSymVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                AddCondSymVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1527:1, end:1527:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar0 {}
impl RegAddCondIVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1528:1, end:1528:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar1 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegAddCondIVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1529:1, end:1529:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar2 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegAddCondIVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1530:1, end:1530:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar3 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegAddCondIVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1531:1, end:1531:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar4 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1532:1, end:1532:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar5 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1533:1, end:1533:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar6 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegAddCondIVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1534:1, end:1534:12))"]
#[derive(Clone, Debug)]
struct RegAddCondIVar7 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegAddCondI {
    Var0(RegAddCondIVar0),
    Var1(RegAddCondIVar1),
    Var2(RegAddCondIVar2),
    Var3(RegAddCondIVar3),
    Var4(RegAddCondIVar4),
    Var5(RegAddCondIVar5),
    Var6(RegAddCondIVar6),
    Var7(RegAddCondIVar7),
}
impl TableRegAddCondI {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                RegAddCondIVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                RegAddCondIVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                RegAddCondIVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                RegAddCondIVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 {
            if let Some((inst_len, parsed)) =
                RegAddCondIVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 {
            if let Some((inst_len, parsed)) =
                RegAddCondIVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                RegAddCondIVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                RegAddCondIVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1544:1, end:1544:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var0 {}
impl RegAddCondI11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1546:1, end:1546:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var1 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegAddCondI11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1550:1, end:1550:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var2 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegAddCondI11Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1554:1, end:1554:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var3 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegAddCondI11Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1558:1, end:1558:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var4 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1562:1, end:1562:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var5 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegAddCondI11Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1567:1, end:1567:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var6 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegAddCondI11Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1571:1, end:1571:14))"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var7 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegAddCondI11 {
    Var0(RegAddCondI11Var0),
    Var1(RegAddCondI11Var1),
    Var2(RegAddCondI11Var2),
    Var3(RegAddCondI11Var3),
    Var4(RegAddCondI11Var4),
    Var5(RegAddCondI11Var5),
    Var6(RegAddCondI11Var6),
    Var7(RegAddCondI11Var7),
}
impl TableRegAddCondI11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                RegAddCondI11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                RegAddCondI11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                RegAddCondI11Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                RegAddCondI11Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 {
            if let Some((inst_len, parsed)) =
                RegAddCondI11Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 {
            if let Some((inst_len, parsed)) =
                RegAddCondI11Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                RegAddCondI11Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                RegAddCondI11Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1575:1, end:1575:11))"]
#[derive(Clone, Debug)]
struct AddCondI11Var0 {
    RegAddCondI11: TableRegAddCondI11,
}
impl AddCondI11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegAddCondI11 = if let Some((len, table)) =
            TableRegAddCondI11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCondI11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1576:1, end:1576:11))"]
#[derive(Clone, Debug)]
struct AddCondI11Var1 {
    RegAddCondI11: TableRegAddCondI11,
}
impl AddCondI11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegAddCondI11 = if let Some((len, table)) =
            TableRegAddCondI11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCondI11 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCondI11 {
    Var0(AddCondI11Var0),
    Var1(AddCondI11Var1),
}
impl TableAddCondI11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                AddCondI11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                AddCondI11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1578:1, end:1578:18))"]
#[derive(Clone, Debug)]
struct AddCondI11NullifyVar0 {}
impl AddCondI11NullifyVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1579:1, end:1579:18))"]
#[derive(Clone, Debug)]
struct AddCondI11NullifyVar1 {
    AddCondI11: TableAddCondI11,
}
impl AddCondI11NullifyVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_nullifyEnable(
                u8::try_from(i128::try_from(context.read_nullifyEnable()).unwrap() & 1).unwrap(),
            )
        });
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_nullifyEnable(u8::try_from(1i128 & 1).unwrap());
        let AddCondI11 = if let Some((len, table)) =
            TableAddCondI11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AddCondI11 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCondI11Nullify {
    Var0(AddCondI11NullifyVar0),
    Var1(AddCondI11NullifyVar1),
}
impl TableAddCondI11Nullify {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                AddCondI11NullifyVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                AddCondI11NullifyVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1587:1, end:1587:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar0 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1588:1, end:1588:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar1 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1589:1, end:1589:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar2 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1590:1, end:1590:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar3 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1591:1, end:1591:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar4 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1592:1, end:1592:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar5 {
    R2: TableR2,
    R1: TableR1,
}
impl RegCSCondVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, R1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1593:1, end:1593:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar6 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1594:1, end:1594:10))"]
#[derive(Clone, Debug)]
struct RegCSCondVar7 {
    R2: TableR2,
    R1: TableR1,
}
impl RegCSCondVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, R1 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegCSCond {
    Var0(RegCSCondVar0),
    Var1(RegCSCondVar1),
    Var2(RegCSCondVar2),
    Var3(RegCSCondVar3),
    Var4(RegCSCondVar4),
    Var5(RegCSCondVar5),
    Var6(RegCSCondVar6),
    Var7(RegCSCondVar7),
}
impl TableRegCSCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                RegCSCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                RegCSCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                RegCSCondVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                RegCSCondVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 {
            if let Some((inst_len, parsed)) =
                RegCSCondVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 {
            if let Some((inst_len, parsed)) =
                RegCSCondVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                RegCSCondVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                RegCSCondVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1596:1, end:1596:7))"]
#[derive(Clone, Debug)]
struct CSCondVar0 {
    RegCSCond: TableRegCSCond,
}
impl CSCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegCSCond = if let Some((len, table)) =
            TableRegCSCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1597:1, end:1597:7))"]
#[derive(Clone, Debug)]
struct CSCondVar1 {
    RegCSCond: TableRegCSCond,
}
impl CSCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegCSCond = if let Some((len, table)) =
            TableRegCSCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCond }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCond {
    Var0(CSCondVar0),
    Var1(CSCondVar1),
}
impl TableCSCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                CSCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                CSCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1599:1, end:1599:14))"]
#[derive(Clone, Debug)]
struct CSCondNullifyVar0 {}
impl CSCondNullifyVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1600:1, end:1600:14))"]
#[derive(Clone, Debug)]
struct CSCondNullifyVar1 {
    CSCond: TableCSCond,
}
impl CSCondNullifyVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_nullifyEnable(
                u8::try_from(i128::try_from(context.read_nullifyEnable()).unwrap() & 1).unwrap(),
            )
        });
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_nullifyEnable(u8::try_from(1i128 & 1).unwrap());
        let CSCond = if let Some((len, table)) =
            TableCSCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CSCond }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCondNullify {
    Var0(CSCondNullifyVar0),
    Var1(CSCondNullifyVar1),
}
impl TableCSCondNullify {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                CSCondNullifyVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                CSCondNullifyVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1605:1, end:1605:10))"]
#[derive(Clone, Debug)]
struct CSCondSymVar0 {
    RegCSCondSym: u8,
}
impl CSCondSymVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_16_display(self.RegCSCondSym)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegCSCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCondSym }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1606:1, end:1606:10))"]
#[derive(Clone, Debug)]
struct CSCondSymVar1 {
    InvCSCondSym: u8,
}
impl CSCondSymVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_17_display(self.InvCSCondSym)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let InvCSCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { InvCSCondSym }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCondSym {
    Var0(CSCondSymVar0),
    Var1(CSCondSymVar1),
}
impl TableCSCondSym {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                CSCondSymVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                CSCondSymVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1610:1, end:1610:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar0 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1611:1, end:1611:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar1 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1612:1, end:1612:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar2 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1613:1, end:1613:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar3 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1614:1, end:1614:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar4 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegCSCondIVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1615:1, end:1615:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar5 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1616:1, end:1616:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar6 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1617:1, end:1617:11))"]
#[derive(Clone, Debug)]
struct RegCSCondIVar7 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegCSCondIVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegCSCondI {
    Var0(RegCSCondIVar0),
    Var1(RegCSCondIVar1),
    Var2(RegCSCondIVar2),
    Var3(RegCSCondIVar3),
    Var4(RegCSCondIVar4),
    Var5(RegCSCondIVar5),
    Var6(RegCSCondIVar6),
    Var7(RegCSCondIVar7),
}
impl TableRegCSCondI {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                RegCSCondIVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                RegCSCondIVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                RegCSCondIVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                RegCSCondIVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 {
            if let Some((inst_len, parsed)) =
                RegCSCondIVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 {
            if let Some((inst_len, parsed)) =
                RegCSCondIVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                RegCSCondIVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                RegCSCondIVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1620:1, end:1620:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var0 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1621:1, end:1621:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var1 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegCSCondI11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1622:1, end:1622:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var2 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1623:1, end:1623:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var3 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegCSCondI11Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1624:1, end:1624:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var4 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegCSCondI11Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1625:1, end:1625:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var5 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1626:1, end:1626:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var6 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegCSCondI11Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1627:1, end:1627:13))"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var7 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegCSCondI11 {
    Var0(RegCSCondI11Var0),
    Var1(RegCSCondI11Var1),
    Var2(RegCSCondI11Var2),
    Var3(RegCSCondI11Var3),
    Var4(RegCSCondI11Var4),
    Var5(RegCSCondI11Var5),
    Var6(RegCSCondI11Var6),
    Var7(RegCSCondI11Var7),
}
impl TableRegCSCondI11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                RegCSCondI11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                RegCSCondI11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                RegCSCondI11Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                RegCSCondI11Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 {
            if let Some((inst_len, parsed)) =
                RegCSCondI11Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 {
            if let Some((inst_len, parsed)) =
                RegCSCondI11Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                RegCSCondI11Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                RegCSCondI11Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1629:1, end:1629:10))"]
#[derive(Clone, Debug)]
struct CSCondI11Var0 {
    RegCSCondI11: TableRegCSCondI11,
}
impl CSCondI11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegCSCondI11 = if let Some((len, table)) =
            TableRegCSCondI11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCondI11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1630:1, end:1630:10))"]
#[derive(Clone, Debug)]
struct CSCondI11Var1 {
    RegCSCondI11: TableRegCSCondI11,
}
impl CSCondI11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegCSCondI11 = if let Some((len, table)) =
            TableRegCSCondI11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCondI11 }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCondI11 {
    Var0(CSCondI11Var0),
    Var1(CSCondI11Var1),
}
impl TableCSCondI11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                CSCondI11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                CSCondI11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1632:1, end:1632:17))"]
#[derive(Clone, Debug)]
struct CSCondI11NullifyVar0 {}
impl CSCondI11NullifyVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1633:1, end:1633:17))"]
#[derive(Clone, Debug)]
struct CSCondI11NullifyVar1 {
    CSCondI11: TableCSCondI11,
}
impl CSCondI11NullifyVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_nullifyEnable(
                u8::try_from(i128::try_from(context.read_nullifyEnable()).unwrap() & 1).unwrap(),
            )
        });
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_nullifyEnable(u8::try_from(1i128 & 1).unwrap());
        let CSCondI11 = if let Some((len, table)) =
            TableCSCondI11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CSCondI11 }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCondI11Nullify {
    Var0(CSCondI11NullifyVar0),
    Var1(CSCondI11NullifyVar1),
}
impl TableCSCondI11Nullify {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                CSCondI11NullifyVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                CSCondI11NullifyVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1641:1, end:1641:13))"]
#[derive(Clone, Debug)]
struct RegLogicCondVar0 {}
impl RegLogicCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1642:1, end:1642:13))"]
#[derive(Clone, Debug)]
struct RegLogicCondVar1 {
    RT: TableRT,
}
impl RegLogicCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1643:1, end:1643:13))"]
#[derive(Clone, Debug)]
struct RegLogicCondVar2 {
    RT: TableRT,
}
impl RegLogicCondVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1644:1, end:1644:13))"]
#[derive(Clone, Debug)]
struct RegLogicCondVar3 {
    RT: TableRT,
}
impl RegLogicCondVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1645:1, end:1645:13))"]
#[derive(Clone, Debug)]
struct RegLogicCondVar4 {
    RT: TableRT,
}
impl RegLogicCondVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[derive(Clone, Debug)]
enum TableRegLogicCond {
    Var0(RegLogicCondVar0),
    Var1(RegLogicCondVar1),
    Var2(RegLogicCondVar2),
    Var3(RegLogicCondVar3),
    Var4(RegLogicCondVar4),
}
impl TableRegLogicCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 {
            if let Some((inst_len, parsed)) =
                RegLogicCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                RegLogicCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                RegLogicCondVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                RegLogicCondVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                RegLogicCondVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1647:1, end:1647:10))"]
#[derive(Clone, Debug)]
struct LogicCondVar0 {
    RegLogicCond: TableRegLogicCond,
}
impl LogicCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegLogicCond = if let Some((len, table)) =
            TableRegLogicCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegLogicCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1648:1, end:1648:10))"]
#[derive(Clone, Debug)]
struct LogicCondVar1 {
    RegLogicCond: TableRegLogicCond,
}
impl LogicCondVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegLogicCond = if let Some((len, table)) =
            TableRegLogicCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegLogicCond }))
    }
}
#[derive(Clone, Debug)]
enum TableLogicCond {
    Var0(LogicCondVar0),
    Var1(LogicCondVar1),
}
impl TableLogicCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                LogicCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                LogicCondVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1650:1, end:1650:13))"]
#[derive(Clone, Debug)]
struct LogicCondSymVar0 {
    RegLogicCondSym: u8,
}
impl LogicCondSymVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_12_display(self.RegLogicCondSym)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RegLogicCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegLogicCondSym }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1651:1, end:1651:13))"]
#[derive(Clone, Debug)]
struct LogicCondSymVar1 {
    InvLogicCondSym: u8,
}
impl LogicCondSymVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_13_display(self.InvLogicCondSym)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let InvLogicCondSym = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { InvLogicCondSym }))
    }
}
#[derive(Clone, Debug)]
enum TableLogicCondSym {
    Var0(LogicCondSymVar0),
    Var1(LogicCondSymVar1),
}
impl TableLogicCondSym {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                LogicCondSymVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                LogicCondSymVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1653:1, end:1653:17))"]
#[derive(Clone, Debug)]
struct LogicCondNullifyVar0 {}
impl LogicCondNullifyVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1654:1, end:1654:17))"]
#[derive(Clone, Debug)]
struct LogicCondNullifyVar1 {
    LogicCond: TableLogicCond,
}
impl LogicCondNullifyVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_nullifyEnable(
                u8::try_from(i128::try_from(context.read_nullifyEnable()).unwrap() & 1).unwrap(),
            )
        });
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_nullifyEnable(u8::try_from(1i128 & 1).unwrap());
        let LogicCond = if let Some((len, table)) =
            TableLogicCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LogicCond }))
    }
}
#[derive(Clone, Debug)]
enum TableLogicCondNullify {
    Var0(LogicCondNullifyVar0),
    Var1(LogicCondNullifyVar1),
}
impl TableLogicCondNullify {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                LogicCondNullifyVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                LogicCondNullifyVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1665:1, end:1665:23))"]
#[derive(Clone, Debug)]
struct indexedByteAccessCmpltVar0 {
    SPCBASE: TableSPCBASE,
    RX: TableRX,
}
impl indexedByteAccessCmpltVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, RX }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1666:1, end:1666:23))"]
#[derive(Clone, Debug)]
struct indexedByteAccessCmpltVar1 {
    SPCBASE: TableSPCBASE,
    RX: TableRX,
    RB: TableRB,
}
impl indexedByteAccessCmpltVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, RX, RB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1667:1, end:1667:23))"]
#[derive(Clone, Debug)]
struct indexedByteAccessCmpltVar2 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedByteAccessCmpltVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",S")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1668:1, end:1668:23))"]
#[derive(Clone, Debug)]
struct indexedByteAccessCmpltVar3 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl indexedByteAccessCmpltVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",SM")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE, RB }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedByteAccessCmplt {
    Var0(indexedByteAccessCmpltVar0),
    Var1(indexedByteAccessCmpltVar1),
    Var2(indexedByteAccessCmpltVar2),
    Var3(indexedByteAccessCmpltVar3),
}
impl TableindexedByteAccessCmplt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                indexedByteAccessCmpltVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                indexedByteAccessCmpltVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                indexedByteAccessCmpltVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                indexedByteAccessCmpltVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1671:1, end:1671:27))"]
#[derive(Clone, Debug)]
struct indexedHalfwordAccessCmpltVar0 {
    SPCBASE: TableSPCBASE,
    RX: TableRX,
}
impl indexedHalfwordAccessCmpltVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, RX }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1672:1, end:1672:27))"]
#[derive(Clone, Debug)]
struct indexedHalfwordAccessCmpltVar1 {
    SPCBASE: TableSPCBASE,
    RX: TableRX,
    RB: TableRB,
}
impl indexedHalfwordAccessCmpltVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, RX, RB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1673:1, end:1673:27))"]
#[derive(Clone, Debug)]
struct indexedHalfwordAccessCmpltVar2 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedHalfwordAccessCmpltVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",S")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1674:1, end:1674:27))"]
#[derive(Clone, Debug)]
struct indexedHalfwordAccessCmpltVar3 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedHalfwordAccessCmpltVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",SM")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedHalfwordAccessCmplt {
    Var0(indexedHalfwordAccessCmpltVar0),
    Var1(indexedHalfwordAccessCmpltVar1),
    Var2(indexedHalfwordAccessCmpltVar2),
    Var3(indexedHalfwordAccessCmpltVar3),
}
impl TableindexedHalfwordAccessCmplt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) = indexedHalfwordAccessCmpltVar0::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) = indexedHalfwordAccessCmpltVar1::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) = indexedHalfwordAccessCmpltVar2::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) = indexedHalfwordAccessCmpltVar3::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1677:1, end:1677:23))"]
#[derive(Clone, Debug)]
struct indexedWordAccessCmpltVar0 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedWordAccessCmpltVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1678:1, end:1678:23))"]
#[derive(Clone, Debug)]
struct indexedWordAccessCmpltVar1 {
    SPCBASE: TableSPCBASE,
    RB: TableRB,
    RX: TableRX,
}
impl indexedWordAccessCmpltVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, RB, RX }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1679:1, end:1679:23))"]
#[derive(Clone, Debug)]
struct indexedWordAccessCmpltVar2 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedWordAccessCmpltVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",S")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1680:1, end:1680:23))"]
#[derive(Clone, Debug)]
struct indexedWordAccessCmpltVar3 {
    RB: TableRB,
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedWordAccessCmpltVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",SM")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB, RX, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedWordAccessCmplt {
    Var0(indexedWordAccessCmpltVar0),
    Var1(indexedWordAccessCmpltVar1),
    Var2(indexedWordAccessCmpltVar2),
    Var3(indexedWordAccessCmpltVar3),
}
impl TableindexedWordAccessCmplt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                indexedWordAccessCmpltVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                indexedWordAccessCmpltVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                indexedWordAccessCmpltVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                indexedWordAccessCmpltVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1683:1, end:1683:29))"]
#[derive(Clone, Debug)]
struct indexedDoublewordAccessCmpltVar0 {
    SPCBASE: TableSPCBASE,
    RX: TableRX,
}
impl indexedDoublewordAccessCmpltVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, RX }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1684:1, end:1684:29))"]
#[derive(Clone, Debug)]
struct indexedDoublewordAccessCmpltVar1 {
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    RX: TableRX,
}
impl indexedDoublewordAccessCmpltVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB, SPCBASE, RX }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1685:1, end:1685:29))"]
#[derive(Clone, Debug)]
struct indexedDoublewordAccessCmpltVar2 {
    SPCBASE: TableSPCBASE,
    RX: TableRX,
}
impl indexedDoublewordAccessCmpltVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",S")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, RX }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1686:1, end:1686:29))"]
#[derive(Clone, Debug)]
struct indexedDoublewordAccessCmpltVar3 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedDoublewordAccessCmpltVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",SM")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedDoublewordAccessCmplt {
    Var0(indexedDoublewordAccessCmpltVar0),
    Var1(indexedDoublewordAccessCmpltVar1),
    Var2(indexedDoublewordAccessCmpltVar2),
    Var3(indexedDoublewordAccessCmpltVar3),
}
impl TableindexedDoublewordAccessCmplt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) = indexedDoublewordAccessCmpltVar0::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) = indexedDoublewordAccessCmpltVar1::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) = indexedDoublewordAccessCmpltVar2::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) = indexedDoublewordAccessCmpltVar3::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1691:1, end:1691:15))"]
#[derive(Clone, Debug)]
struct shortDispCmpltVar0 {
    RB: TableRB,
    highlse5: Tablehighlse5,
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl shortDispCmpltVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",MA")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                highlse5,
                RX,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1692:1, end:1692:15))"]
#[derive(Clone, Debug)]
struct shortDispCmpltVar1 {
    RX: TableRX,
    RB: TableRB,
    highlse5: Tablehighlse5,
    SPCBASE: TableSPCBASE,
}
impl shortDispCmpltVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",MB")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                RB,
                highlse5,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1690:1, end:1690:15))"]
#[derive(Clone, Debug)]
struct shortDispCmpltVar2 {
    SPCBASE: TableSPCBASE,
    highlse5: Tablehighlse5,
}
impl shortDispCmpltVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let highlse5 = if let Some((len, table)) =
            Tablehighlse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, highlse5 }))
    }
}
#[derive(Clone, Debug)]
enum TableshortDispCmplt {
    Var0(shortDispCmpltVar0),
    Var1(shortDispCmpltVar1),
    Var2(shortDispCmpltVar2),
}
impl TableshortDispCmplt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                shortDispCmpltVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                shortDispCmpltVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                shortDispCmpltVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1696:1, end:1696:20))"]
#[derive(Clone, Debug)]
struct storeShortDispCmpltVar0 {
    SPCBASE: TableSPCBASE,
    RB: TableRB,
    RX: TableRX,
    lse5: Tablelse5,
}
impl storeShortDispCmpltVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",MA")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SPCBASE,
                RB,
                RX,
                lse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1697:1, end:1697:20))"]
#[derive(Clone, Debug)]
struct storeShortDispCmpltVar1 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
    lse5: Tablelse5,
}
impl storeShortDispCmpltVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",MB")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SPCBASE,
                RB,
                lse5,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1695:1, end:1695:20))"]
#[derive(Clone, Debug)]
struct storeShortDispCmpltVar2 {
    SPCBASE: TableSPCBASE,
    lse5: Tablelse5,
}
impl storeShortDispCmpltVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, lse5 }))
    }
}
#[derive(Clone, Debug)]
enum TablestoreShortDispCmplt {
    Var0(storeShortDispCmpltVar0),
    Var1(storeShortDispCmpltVar1),
    Var2(storeShortDispCmpltVar2),
}
impl TablestoreShortDispCmplt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                storeShortDispCmpltVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                storeShortDispCmpltVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                storeShortDispCmpltVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1700:1, end:1700:21))"]
#[derive(Clone, Debug)]
struct storeBytesShortCmpltVar0 {
    lse5: Tablelse5,
    SPCBASE: TableSPCBASE,
}
impl storeBytesShortCmpltVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse5, SPCBASE }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1701:1, end:1701:21))"]
#[derive(Clone, Debug)]
struct storeBytesShortCmpltVar1 {
    RR: TableRR,
    SPCBASE: TableSPCBASE,
    lse5: Tablelse5,
}
impl storeBytesShortCmpltVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",BM")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RR, SPCBASE, lse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1702:1, end:1702:21))"]
#[derive(Clone, Debug)]
struct storeBytesShortCmpltVar2 {
    SPCBASE: TableSPCBASE,
    lse5: Tablelse5,
}
impl storeBytesShortCmpltVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",E")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, lse5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1703:1, end:1703:21))"]
#[derive(Clone, Debug)]
struct storeBytesShortCmpltVar3 {
    SPCBASE: TableSPCBASE,
    RR: TableRR,
    lse5: Tablelse5,
}
impl storeBytesShortCmpltVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",EM")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SPCBASE = if let Some((len, table)) =
            TableSPCBASE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, RR, lse5 }))
    }
}
#[derive(Clone, Debug)]
enum TablestoreBytesShortCmplt {
    Var0(storeBytesShortCmpltVar0),
    Var1(storeBytesShortCmpltVar1),
    Var2(storeBytesShortCmpltVar2),
    Var3(storeBytesShortCmpltVar3),
}
impl TablestoreBytesShortCmplt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                storeBytesShortCmpltVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                storeBytesShortCmpltVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                storeBytesShortCmpltVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                storeBytesShortCmpltVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1706:1, end:1706:9))"]
#[derive(Clone, Debug)]
struct sysCmpltVar0 {}
impl sysCmpltVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1707:1, end:1707:9))"]
#[derive(Clone, Debug)]
struct sysCmpltVar1 {}
impl sysCmpltVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablesysCmplt {
    Var0(sysCmpltVar0),
    Var1(sysCmpltVar1),
}
impl TablesysCmplt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                sysCmpltVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                sysCmpltVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1710:1, end:1710:7))"]
#[derive(Clone, Debug)]
struct loadCCVar0 {}
impl loadCCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1711:1, end:1711:7))"]
#[derive(Clone, Debug)]
struct loadCCVar1 {}
impl loadCCVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",SL")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableloadCC {
    Var0(loadCCVar0),
    Var1(loadCCVar1),
}
impl TableloadCC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 12) == 0 {
            if let Some((inst_len, parsed)) =
                loadCCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 12) == 8 {
            if let Some((inst_len, parsed)) =
                loadCCVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1714:1, end:1714:8))"]
#[derive(Clone, Debug)]
struct storeCCVar0 {}
impl storeCCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1715:1, end:1715:8))"]
#[derive(Clone, Debug)]
struct storeCCVar1 {}
impl storeCCVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",BC")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1716:1, end:1716:8))"]
#[derive(Clone, Debug)]
struct storeCCVar2 {}
impl storeCCVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",SL")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablestoreCC {
    Var0(storeCCVar0),
    Var1(storeCCVar1),
    Var2(storeCCVar2),
}
impl TablestoreCC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 12) == 0 {
            if let Some((inst_len, parsed)) =
                storeCCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 12) == 4 {
            if let Some((inst_len, parsed)) =
                storeCCVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 12) == 8 {
            if let Some((inst_len, parsed)) =
                storeCCVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1719:1, end:1719:12))"]
#[derive(Clone, Debug)]
struct loadClearCCVar0 {}
impl loadClearCCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1720:1, end:1720:12))"]
#[derive(Clone, Debug)]
struct loadClearCCVar1 {}
impl loadClearCCVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",CO")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableloadClearCC {
    Var0(loadClearCCVar0),
    Var1(loadClearCCVar1),
}
impl TableloadClearCC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 12) == 0 {
            if let Some((inst_len, parsed)) =
                loadClearCCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 12) == 4 {
            if let Some((inst_len, parsed)) =
                loadClearCCVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1726:1, end:1726:17))"]
#[derive(Clone, Debug)]
struct nullifyForBranchVar0 {}
impl nullifyForBranchVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1727:1, end:1727:17))"]
#[derive(Clone, Debug)]
struct nullifyForBranchVar1 {}
impl nullifyForBranchVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_nullifyEnable(
                u8::try_from(i128::try_from(context.read_nullifyEnable()).unwrap() & 1).unwrap(),
            )
        });
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",N")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_nullifyEnable(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablenullifyForBranch {
    Var0(nullifyForBranchVar0),
    Var1(nullifyForBranchVar1),
}
impl TablenullifyForBranch {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                nullifyForBranchVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                nullifyForBranchVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1729:1, end:1729:20))"]
#[derive(Clone, Debug)]
struct nullifySymForBranchVar0 {}
impl nullifySymForBranchVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1730:1, end:1730:20))"]
#[derive(Clone, Debug)]
struct nullifySymForBranchVar1 {}
impl nullifySymForBranchVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",N")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablenullifySymForBranch {
    Var0(nullifySymForBranchVar0),
    Var1(nullifySymForBranchVar1),
}
impl TablenullifySymForBranch {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                nullifySymForBranchVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                nullifySymForBranchVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1733:1, end:1733:18))"]
#[derive(Clone, Debug)]
struct nullifyForSpecialVar0 {}
impl nullifyForSpecialVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1734:1, end:1734:18))"]
#[derive(Clone, Debug)]
struct nullifyForSpecialVar1 {}
impl nullifyForSpecialVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",N")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablenullifyForSpecial {
    Var0(nullifyForSpecialVar0),
    Var1(nullifyForSpecialVar1),
}
impl TablenullifyForSpecial {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                nullifyForSpecialVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                nullifyForSpecialVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc, start:1744:1, end:1744:4))"]
#[derive(Clone, Debug)]
struct SFUVar0 {
    sfu: u8,
}
impl SFUVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.sfu as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sfu = token_37(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sfu }))
    }
}
#[derive(Clone, Debug)]
enum TableSFU {
    Var0(SFUVar0),
}
impl TableSFU {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                SFUVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
pub fn parse_instruction(
    tokens: &[u8],
    context: &mut ContextMemory,
    inst_start: AddrType,
    global_set: &mut GlobalSet,
) -> Option<(u32, Vec<DisplayElement>)> {
    let (inst_len, instruction) = Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(&mut display, context, inst_start, inst_next, global_set);
    Some((inst_next, display))
}
